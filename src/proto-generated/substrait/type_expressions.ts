// @generated by protobuf-ts 2.2.4
// @generated from protobuf file "substrait/type_expressions.proto" (package "substrait", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Type_Nullability } from "./type";
import { Type_UUID } from "./type";
import { Type_TimestampTZ } from "./type";
import { Type_IntervalDay } from "./type";
import { Type_IntervalYear } from "./type";
import { Type_Time } from "./type";
import { Type_Date } from "./type";
import { Type_Timestamp } from "./type";
import { Type_Binary } from "./type";
import { Type_String } from "./type";
import { Type_FP64 } from "./type";
import { Type_FP32 } from "./type";
import { Type_I64 } from "./type";
import { Type_I32 } from "./type";
import { Type_I16 } from "./type";
import { Type_I8 } from "./type";
import { Type_Boolean } from "./type";
/**
 * @generated from protobuf message substrait.DerivationExpression
 */
export interface DerivationExpression {
    /**
     * @generated from protobuf oneof: kind
     */
    kind: {
        oneofKind: "bool";
        /**
         * @generated from protobuf field: substrait.Type.Boolean bool = 1;
         */
        bool: Type_Boolean;
    } | {
        oneofKind: "i8";
        /**
         * @generated from protobuf field: substrait.Type.I8 i8 = 2;
         */
        i8: Type_I8;
    } | {
        oneofKind: "i16";
        /**
         * @generated from protobuf field: substrait.Type.I16 i16 = 3;
         */
        i16: Type_I16;
    } | {
        oneofKind: "i32";
        /**
         * @generated from protobuf field: substrait.Type.I32 i32 = 5;
         */
        i32: Type_I32;
    } | {
        oneofKind: "i64";
        /**
         * @generated from protobuf field: substrait.Type.I64 i64 = 7;
         */
        i64: Type_I64;
    } | {
        oneofKind: "fp32";
        /**
         * @generated from protobuf field: substrait.Type.FP32 fp32 = 10;
         */
        fp32: Type_FP32;
    } | {
        oneofKind: "fp64";
        /**
         * @generated from protobuf field: substrait.Type.FP64 fp64 = 11;
         */
        fp64: Type_FP64;
    } | {
        oneofKind: "string";
        /**
         * @generated from protobuf field: substrait.Type.String string = 12;
         */
        string: Type_String;
    } | {
        oneofKind: "binary";
        /**
         * @generated from protobuf field: substrait.Type.Binary binary = 13;
         */
        binary: Type_Binary;
    } | {
        oneofKind: "timestamp";
        /**
         * @generated from protobuf field: substrait.Type.Timestamp timestamp = 14;
         */
        timestamp: Type_Timestamp;
    } | {
        oneofKind: "date";
        /**
         * @generated from protobuf field: substrait.Type.Date date = 16;
         */
        date: Type_Date;
    } | {
        oneofKind: "time";
        /**
         * @generated from protobuf field: substrait.Type.Time time = 17;
         */
        time: Type_Time;
    } | {
        oneofKind: "intervalYear";
        /**
         * @generated from protobuf field: substrait.Type.IntervalYear interval_year = 19;
         */
        intervalYear: Type_IntervalYear;
    } | {
        oneofKind: "intervalDay";
        /**
         * @generated from protobuf field: substrait.Type.IntervalDay interval_day = 20;
         */
        intervalDay: Type_IntervalDay;
    } | {
        oneofKind: "timestampTz";
        /**
         * @generated from protobuf field: substrait.Type.TimestampTZ timestamp_tz = 29;
         */
        timestampTz: Type_TimestampTZ;
    } | {
        oneofKind: "uuid";
        /**
         * @generated from protobuf field: substrait.Type.UUID uuid = 32;
         */
        uuid: Type_UUID;
    } | {
        oneofKind: "fixedChar";
        /**
         * @generated from protobuf field: substrait.DerivationExpression.ExpressionFixedChar fixed_char = 21;
         */
        fixedChar: DerivationExpression_ExpressionFixedChar;
    } | {
        oneofKind: "varchar";
        /**
         * @generated from protobuf field: substrait.DerivationExpression.ExpressionVarChar varchar = 22;
         */
        varchar: DerivationExpression_ExpressionVarChar;
    } | {
        oneofKind: "fixedBinary";
        /**
         * @generated from protobuf field: substrait.DerivationExpression.ExpressionFixedBinary fixed_binary = 23;
         */
        fixedBinary: DerivationExpression_ExpressionFixedBinary;
    } | {
        oneofKind: "decimal";
        /**
         * @generated from protobuf field: substrait.DerivationExpression.ExpressionDecimal decimal = 24;
         */
        decimal: DerivationExpression_ExpressionDecimal;
    } | {
        oneofKind: "struct";
        /**
         * @generated from protobuf field: substrait.DerivationExpression.ExpressionStruct struct = 25;
         */
        struct: DerivationExpression_ExpressionStruct;
    } | {
        oneofKind: "list";
        /**
         * @generated from protobuf field: substrait.DerivationExpression.ExpressionList list = 27;
         */
        list: DerivationExpression_ExpressionList;
    } | {
        oneofKind: "map";
        /**
         * @generated from protobuf field: substrait.DerivationExpression.ExpressionMap map = 28;
         */
        map: DerivationExpression_ExpressionMap;
    } | {
        oneofKind: "userDefinedPointer";
        /**
         * @generated from protobuf field: uint32 user_defined_pointer = 31;
         */
        userDefinedPointer: number;
    } | {
        oneofKind: "typeParameterName";
        /**
         * @generated from protobuf field: string type_parameter_name = 33;
         */
        typeParameterName: string;
    } | {
        oneofKind: "integerParameterName";
        /**
         * @generated from protobuf field: string integer_parameter_name = 34;
         */
        integerParameterName: string;
    } | {
        oneofKind: "integerLiteral";
        /**
         * @generated from protobuf field: int32 integer_literal = 35;
         */
        integerLiteral: number;
    } | {
        oneofKind: "unaryOp";
        /**
         * @generated from protobuf field: substrait.DerivationExpression.UnaryOp unary_op = 36;
         */
        unaryOp: DerivationExpression_UnaryOp;
    } | {
        oneofKind: "binaryOp";
        /**
         * @generated from protobuf field: substrait.DerivationExpression.BinaryOp binary_op = 37;
         */
        binaryOp: DerivationExpression_BinaryOp;
    } | {
        oneofKind: "ifElse";
        /**
         * @generated from protobuf field: substrait.DerivationExpression.IfElse if_else = 38;
         */
        ifElse: DerivationExpression_IfElse;
    } | {
        oneofKind: "returnProgram";
        /**
         * @generated from protobuf field: substrait.DerivationExpression.ReturnProgram return_program = 39;
         */
        returnProgram: DerivationExpression_ReturnProgram;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message substrait.DerivationExpression.ExpressionFixedChar
 */
export interface DerivationExpression_ExpressionFixedChar {
    /**
     * @generated from protobuf field: substrait.DerivationExpression length = 1;
     */
    length?: DerivationExpression;
    /**
     * @generated from protobuf field: uint32 variation_pointer = 2;
     */
    variationPointer: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 3;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.DerivationExpression.ExpressionVarChar
 */
export interface DerivationExpression_ExpressionVarChar {
    /**
     * @generated from protobuf field: substrait.DerivationExpression length = 1;
     */
    length?: DerivationExpression;
    /**
     * @generated from protobuf field: uint32 variation_pointer = 2;
     */
    variationPointer: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 3;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.DerivationExpression.ExpressionFixedBinary
 */
export interface DerivationExpression_ExpressionFixedBinary {
    /**
     * @generated from protobuf field: substrait.DerivationExpression length = 1;
     */
    length?: DerivationExpression;
    /**
     * @generated from protobuf field: uint32 variation_pointer = 2;
     */
    variationPointer: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 3;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.DerivationExpression.ExpressionDecimal
 */
export interface DerivationExpression_ExpressionDecimal {
    /**
     * @generated from protobuf field: substrait.DerivationExpression scale = 1;
     */
    scale?: DerivationExpression;
    /**
     * @generated from protobuf field: substrait.DerivationExpression precision = 2;
     */
    precision?: DerivationExpression;
    /**
     * @generated from protobuf field: uint32 variation_pointer = 3;
     */
    variationPointer: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 4;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.DerivationExpression.ExpressionStruct
 */
export interface DerivationExpression_ExpressionStruct {
    /**
     * @generated from protobuf field: repeated substrait.DerivationExpression types = 1;
     */
    types: DerivationExpression[];
    /**
     * @generated from protobuf field: uint32 variation_pointer = 2;
     */
    variationPointer: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 3;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.DerivationExpression.ExpressionNamedStruct
 */
export interface DerivationExpression_ExpressionNamedStruct {
    /**
     * @generated from protobuf field: repeated string names = 1;
     */
    names: string[];
    /**
     * @generated from protobuf field: substrait.DerivationExpression.ExpressionStruct struct = 2;
     */
    struct?: DerivationExpression_ExpressionStruct;
}
/**
 * @generated from protobuf message substrait.DerivationExpression.ExpressionList
 */
export interface DerivationExpression_ExpressionList {
    /**
     * @generated from protobuf field: substrait.DerivationExpression type = 1;
     */
    type?: DerivationExpression;
    /**
     * @generated from protobuf field: uint32 variation_pointer = 2;
     */
    variationPointer: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 3;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.DerivationExpression.ExpressionMap
 */
export interface DerivationExpression_ExpressionMap {
    /**
     * @generated from protobuf field: substrait.DerivationExpression key = 1;
     */
    key?: DerivationExpression;
    /**
     * @generated from protobuf field: substrait.DerivationExpression value = 2;
     */
    value?: DerivationExpression;
    /**
     * @generated from protobuf field: uint32 variation_pointer = 3;
     */
    variationPointer: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 4;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.DerivationExpression.IfElse
 */
export interface DerivationExpression_IfElse {
    /**
     * @generated from protobuf field: substrait.DerivationExpression if_condition = 1;
     */
    ifCondition?: DerivationExpression;
    /**
     * @generated from protobuf field: substrait.DerivationExpression if_return = 2;
     */
    ifReturn?: DerivationExpression;
    /**
     * @generated from protobuf field: substrait.DerivationExpression else_return = 3;
     */
    elseReturn?: DerivationExpression;
}
/**
 * @generated from protobuf message substrait.DerivationExpression.UnaryOp
 */
export interface DerivationExpression_UnaryOp {
    /**
     * @generated from protobuf field: substrait.DerivationExpression.UnaryOp.UnaryOpType op_type = 1;
     */
    opType: DerivationExpression_UnaryOp_UnaryOpType;
    /**
     * @generated from protobuf field: substrait.DerivationExpression arg = 2;
     */
    arg?: DerivationExpression;
}
/**
 * @generated from protobuf enum substrait.DerivationExpression.UnaryOp.UnaryOpType
 */
export enum DerivationExpression_UnaryOp_UnaryOpType {
    /**
     * @generated from protobuf enum value: UNARY_OP_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: UNARY_OP_TYPE_BOOLEAN_NOT = 1;
     */
    BOOLEAN_NOT = 1
}
/**
 * @generated from protobuf message substrait.DerivationExpression.BinaryOp
 */
export interface DerivationExpression_BinaryOp {
    /**
     * @generated from protobuf field: substrait.DerivationExpression.BinaryOp.BinaryOpType op_type = 1;
     */
    opType: DerivationExpression_BinaryOp_BinaryOpType;
    /**
     * @generated from protobuf field: substrait.DerivationExpression arg1 = 2;
     */
    arg1?: DerivationExpression;
    /**
     * @generated from protobuf field: substrait.DerivationExpression arg2 = 3;
     */
    arg2?: DerivationExpression;
}
/**
 * @generated from protobuf enum substrait.DerivationExpression.BinaryOp.BinaryOpType
 */
export enum DerivationExpression_BinaryOp_BinaryOpType {
    /**
     * @generated from protobuf enum value: BINARY_OP_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: BINARY_OP_TYPE_PLUS = 1;
     */
    PLUS = 1,
    /**
     * @generated from protobuf enum value: BINARY_OP_TYPE_MINUS = 2;
     */
    MINUS = 2,
    /**
     * @generated from protobuf enum value: BINARY_OP_TYPE_MULTIPLY = 3;
     */
    MULTIPLY = 3,
    /**
     * @generated from protobuf enum value: BINARY_OP_TYPE_DIVIDE = 4;
     */
    DIVIDE = 4,
    /**
     * @generated from protobuf enum value: BINARY_OP_TYPE_MIN = 5;
     */
    MIN = 5,
    /**
     * @generated from protobuf enum value: BINARY_OP_TYPE_MAX = 6;
     */
    MAX = 6,
    /**
     * @generated from protobuf enum value: BINARY_OP_TYPE_GREATER_THAN = 7;
     */
    GREATER_THAN = 7,
    /**
     * @generated from protobuf enum value: BINARY_OP_TYPE_LESS_THAN = 8;
     */
    LESS_THAN = 8,
    /**
     * @generated from protobuf enum value: BINARY_OP_TYPE_AND = 9;
     */
    AND = 9,
    /**
     * @generated from protobuf enum value: BINARY_OP_TYPE_OR = 10;
     */
    OR = 10,
    /**
     * @generated from protobuf enum value: BINARY_OP_TYPE_EQUALS = 11;
     */
    EQUALS = 11,
    /**
     * @generated from protobuf enum value: BINARY_OP_TYPE_COVERS = 12;
     */
    COVERS = 12
}
/**
 * @generated from protobuf message substrait.DerivationExpression.ReturnProgram
 */
export interface DerivationExpression_ReturnProgram {
    /**
     * @generated from protobuf field: repeated substrait.DerivationExpression.ReturnProgram.Assignment assignments = 1;
     */
    assignments: DerivationExpression_ReturnProgram_Assignment[];
    /**
     * @generated from protobuf field: substrait.DerivationExpression final_expression = 2;
     */
    finalExpression?: DerivationExpression;
}
/**
 * @generated from protobuf message substrait.DerivationExpression.ReturnProgram.Assignment
 */
export interface DerivationExpression_ReturnProgram_Assignment {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: substrait.DerivationExpression expression = 2;
     */
    expression?: DerivationExpression;
}
// @generated message type with reflection information, may provide speed optimized methods
class DerivationExpression$Type extends MessageType<DerivationExpression> {
    constructor() {
        super("substrait.DerivationExpression", [
            { no: 1, name: "bool", kind: "message", oneof: "kind", T: () => Type_Boolean },
            { no: 2, name: "i8", kind: "message", oneof: "kind", T: () => Type_I8 },
            { no: 3, name: "i16", kind: "message", oneof: "kind", T: () => Type_I16 },
            { no: 5, name: "i32", kind: "message", oneof: "kind", T: () => Type_I32 },
            { no: 7, name: "i64", kind: "message", oneof: "kind", T: () => Type_I64 },
            { no: 10, name: "fp32", kind: "message", oneof: "kind", T: () => Type_FP32 },
            { no: 11, name: "fp64", kind: "message", oneof: "kind", T: () => Type_FP64 },
            { no: 12, name: "string", kind: "message", oneof: "kind", T: () => Type_String },
            { no: 13, name: "binary", kind: "message", oneof: "kind", T: () => Type_Binary },
            { no: 14, name: "timestamp", kind: "message", oneof: "kind", T: () => Type_Timestamp },
            { no: 16, name: "date", kind: "message", oneof: "kind", T: () => Type_Date },
            { no: 17, name: "time", kind: "message", oneof: "kind", T: () => Type_Time },
            { no: 19, name: "interval_year", kind: "message", oneof: "kind", T: () => Type_IntervalYear },
            { no: 20, name: "interval_day", kind: "message", oneof: "kind", T: () => Type_IntervalDay },
            { no: 29, name: "timestamp_tz", kind: "message", oneof: "kind", T: () => Type_TimestampTZ },
            { no: 32, name: "uuid", kind: "message", oneof: "kind", T: () => Type_UUID },
            { no: 21, name: "fixed_char", kind: "message", oneof: "kind", T: () => DerivationExpression_ExpressionFixedChar },
            { no: 22, name: "varchar", kind: "message", oneof: "kind", T: () => DerivationExpression_ExpressionVarChar },
            { no: 23, name: "fixed_binary", kind: "message", oneof: "kind", T: () => DerivationExpression_ExpressionFixedBinary },
            { no: 24, name: "decimal", kind: "message", oneof: "kind", T: () => DerivationExpression_ExpressionDecimal },
            { no: 25, name: "struct", kind: "message", oneof: "kind", T: () => DerivationExpression_ExpressionStruct },
            { no: 27, name: "list", kind: "message", oneof: "kind", T: () => DerivationExpression_ExpressionList },
            { no: 28, name: "map", kind: "message", oneof: "kind", T: () => DerivationExpression_ExpressionMap },
            { no: 31, name: "user_defined_pointer", kind: "scalar", oneof: "kind", T: 13 /*ScalarType.UINT32*/ },
            { no: 33, name: "type_parameter_name", kind: "scalar", oneof: "kind", T: 9 /*ScalarType.STRING*/ },
            { no: 34, name: "integer_parameter_name", kind: "scalar", oneof: "kind", T: 9 /*ScalarType.STRING*/ },
            { no: 35, name: "integer_literal", kind: "scalar", oneof: "kind", T: 5 /*ScalarType.INT32*/ },
            { no: 36, name: "unary_op", kind: "message", oneof: "kind", T: () => DerivationExpression_UnaryOp },
            { no: 37, name: "binary_op", kind: "message", oneof: "kind", T: () => DerivationExpression_BinaryOp },
            { no: 38, name: "if_else", kind: "message", oneof: "kind", T: () => DerivationExpression_IfElse },
            { no: 39, name: "return_program", kind: "message", oneof: "kind", T: () => DerivationExpression_ReturnProgram }
        ]);
    }
    create(value?: PartialMessage<DerivationExpression>): DerivationExpression {
        const message = { kind: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DerivationExpression>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivationExpression): DerivationExpression {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Type.Boolean bool */ 1:
                    message.kind = {
                        oneofKind: "bool",
                        bool: Type_Boolean.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).bool)
                    };
                    break;
                case /* substrait.Type.I8 i8 */ 2:
                    message.kind = {
                        oneofKind: "i8",
                        i8: Type_I8.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).i8)
                    };
                    break;
                case /* substrait.Type.I16 i16 */ 3:
                    message.kind = {
                        oneofKind: "i16",
                        i16: Type_I16.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).i16)
                    };
                    break;
                case /* substrait.Type.I32 i32 */ 5:
                    message.kind = {
                        oneofKind: "i32",
                        i32: Type_I32.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).i32)
                    };
                    break;
                case /* substrait.Type.I64 i64 */ 7:
                    message.kind = {
                        oneofKind: "i64",
                        i64: Type_I64.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).i64)
                    };
                    break;
                case /* substrait.Type.FP32 fp32 */ 10:
                    message.kind = {
                        oneofKind: "fp32",
                        fp32: Type_FP32.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).fp32)
                    };
                    break;
                case /* substrait.Type.FP64 fp64 */ 11:
                    message.kind = {
                        oneofKind: "fp64",
                        fp64: Type_FP64.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).fp64)
                    };
                    break;
                case /* substrait.Type.String string */ 12:
                    message.kind = {
                        oneofKind: "string",
                        string: Type_String.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).string)
                    };
                    break;
                case /* substrait.Type.Binary binary */ 13:
                    message.kind = {
                        oneofKind: "binary",
                        binary: Type_Binary.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).binary)
                    };
                    break;
                case /* substrait.Type.Timestamp timestamp */ 14:
                    message.kind = {
                        oneofKind: "timestamp",
                        timestamp: Type_Timestamp.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).timestamp)
                    };
                    break;
                case /* substrait.Type.Date date */ 16:
                    message.kind = {
                        oneofKind: "date",
                        date: Type_Date.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).date)
                    };
                    break;
                case /* substrait.Type.Time time */ 17:
                    message.kind = {
                        oneofKind: "time",
                        time: Type_Time.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).time)
                    };
                    break;
                case /* substrait.Type.IntervalYear interval_year */ 19:
                    message.kind = {
                        oneofKind: "intervalYear",
                        intervalYear: Type_IntervalYear.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).intervalYear)
                    };
                    break;
                case /* substrait.Type.IntervalDay interval_day */ 20:
                    message.kind = {
                        oneofKind: "intervalDay",
                        intervalDay: Type_IntervalDay.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).intervalDay)
                    };
                    break;
                case /* substrait.Type.TimestampTZ timestamp_tz */ 29:
                    message.kind = {
                        oneofKind: "timestampTz",
                        timestampTz: Type_TimestampTZ.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).timestampTz)
                    };
                    break;
                case /* substrait.Type.UUID uuid */ 32:
                    message.kind = {
                        oneofKind: "uuid",
                        uuid: Type_UUID.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).uuid)
                    };
                    break;
                case /* substrait.DerivationExpression.ExpressionFixedChar fixed_char */ 21:
                    message.kind = {
                        oneofKind: "fixedChar",
                        fixedChar: DerivationExpression_ExpressionFixedChar.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).fixedChar)
                    };
                    break;
                case /* substrait.DerivationExpression.ExpressionVarChar varchar */ 22:
                    message.kind = {
                        oneofKind: "varchar",
                        varchar: DerivationExpression_ExpressionVarChar.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).varchar)
                    };
                    break;
                case /* substrait.DerivationExpression.ExpressionFixedBinary fixed_binary */ 23:
                    message.kind = {
                        oneofKind: "fixedBinary",
                        fixedBinary: DerivationExpression_ExpressionFixedBinary.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).fixedBinary)
                    };
                    break;
                case /* substrait.DerivationExpression.ExpressionDecimal decimal */ 24:
                    message.kind = {
                        oneofKind: "decimal",
                        decimal: DerivationExpression_ExpressionDecimal.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).decimal)
                    };
                    break;
                case /* substrait.DerivationExpression.ExpressionStruct struct */ 25:
                    message.kind = {
                        oneofKind: "struct",
                        struct: DerivationExpression_ExpressionStruct.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).struct)
                    };
                    break;
                case /* substrait.DerivationExpression.ExpressionList list */ 27:
                    message.kind = {
                        oneofKind: "list",
                        list: DerivationExpression_ExpressionList.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).list)
                    };
                    break;
                case /* substrait.DerivationExpression.ExpressionMap map */ 28:
                    message.kind = {
                        oneofKind: "map",
                        map: DerivationExpression_ExpressionMap.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).map)
                    };
                    break;
                case /* uint32 user_defined_pointer */ 31:
                    message.kind = {
                        oneofKind: "userDefinedPointer",
                        userDefinedPointer: reader.uint32()
                    };
                    break;
                case /* string type_parameter_name */ 33:
                    message.kind = {
                        oneofKind: "typeParameterName",
                        typeParameterName: reader.string()
                    };
                    break;
                case /* string integer_parameter_name */ 34:
                    message.kind = {
                        oneofKind: "integerParameterName",
                        integerParameterName: reader.string()
                    };
                    break;
                case /* int32 integer_literal */ 35:
                    message.kind = {
                        oneofKind: "integerLiteral",
                        integerLiteral: reader.int32()
                    };
                    break;
                case /* substrait.DerivationExpression.UnaryOp unary_op */ 36:
                    message.kind = {
                        oneofKind: "unaryOp",
                        unaryOp: DerivationExpression_UnaryOp.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).unaryOp)
                    };
                    break;
                case /* substrait.DerivationExpression.BinaryOp binary_op */ 37:
                    message.kind = {
                        oneofKind: "binaryOp",
                        binaryOp: DerivationExpression_BinaryOp.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).binaryOp)
                    };
                    break;
                case /* substrait.DerivationExpression.IfElse if_else */ 38:
                    message.kind = {
                        oneofKind: "ifElse",
                        ifElse: DerivationExpression_IfElse.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).ifElse)
                    };
                    break;
                case /* substrait.DerivationExpression.ReturnProgram return_program */ 39:
                    message.kind = {
                        oneofKind: "returnProgram",
                        returnProgram: DerivationExpression_ReturnProgram.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).returnProgram)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivationExpression, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Type.Boolean bool = 1; */
        if (message.kind.oneofKind === "bool")
            Type_Boolean.internalBinaryWrite(message.kind.bool, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.I8 i8 = 2; */
        if (message.kind.oneofKind === "i8")
            Type_I8.internalBinaryWrite(message.kind.i8, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.I16 i16 = 3; */
        if (message.kind.oneofKind === "i16")
            Type_I16.internalBinaryWrite(message.kind.i16, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.I32 i32 = 5; */
        if (message.kind.oneofKind === "i32")
            Type_I32.internalBinaryWrite(message.kind.i32, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.I64 i64 = 7; */
        if (message.kind.oneofKind === "i64")
            Type_I64.internalBinaryWrite(message.kind.i64, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.FP32 fp32 = 10; */
        if (message.kind.oneofKind === "fp32")
            Type_FP32.internalBinaryWrite(message.kind.fp32, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.FP64 fp64 = 11; */
        if (message.kind.oneofKind === "fp64")
            Type_FP64.internalBinaryWrite(message.kind.fp64, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.String string = 12; */
        if (message.kind.oneofKind === "string")
            Type_String.internalBinaryWrite(message.kind.string, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.Binary binary = 13; */
        if (message.kind.oneofKind === "binary")
            Type_Binary.internalBinaryWrite(message.kind.binary, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.Timestamp timestamp = 14; */
        if (message.kind.oneofKind === "timestamp")
            Type_Timestamp.internalBinaryWrite(message.kind.timestamp, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.Date date = 16; */
        if (message.kind.oneofKind === "date")
            Type_Date.internalBinaryWrite(message.kind.date, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.Time time = 17; */
        if (message.kind.oneofKind === "time")
            Type_Time.internalBinaryWrite(message.kind.time, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.IntervalYear interval_year = 19; */
        if (message.kind.oneofKind === "intervalYear")
            Type_IntervalYear.internalBinaryWrite(message.kind.intervalYear, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.IntervalDay interval_day = 20; */
        if (message.kind.oneofKind === "intervalDay")
            Type_IntervalDay.internalBinaryWrite(message.kind.intervalDay, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.TimestampTZ timestamp_tz = 29; */
        if (message.kind.oneofKind === "timestampTz")
            Type_TimestampTZ.internalBinaryWrite(message.kind.timestampTz, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.UUID uuid = 32; */
        if (message.kind.oneofKind === "uuid")
            Type_UUID.internalBinaryWrite(message.kind.uuid, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression.ExpressionFixedChar fixed_char = 21; */
        if (message.kind.oneofKind === "fixedChar")
            DerivationExpression_ExpressionFixedChar.internalBinaryWrite(message.kind.fixedChar, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression.ExpressionVarChar varchar = 22; */
        if (message.kind.oneofKind === "varchar")
            DerivationExpression_ExpressionVarChar.internalBinaryWrite(message.kind.varchar, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression.ExpressionFixedBinary fixed_binary = 23; */
        if (message.kind.oneofKind === "fixedBinary")
            DerivationExpression_ExpressionFixedBinary.internalBinaryWrite(message.kind.fixedBinary, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression.ExpressionDecimal decimal = 24; */
        if (message.kind.oneofKind === "decimal")
            DerivationExpression_ExpressionDecimal.internalBinaryWrite(message.kind.decimal, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression.ExpressionStruct struct = 25; */
        if (message.kind.oneofKind === "struct")
            DerivationExpression_ExpressionStruct.internalBinaryWrite(message.kind.struct, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression.ExpressionList list = 27; */
        if (message.kind.oneofKind === "list")
            DerivationExpression_ExpressionList.internalBinaryWrite(message.kind.list, writer.tag(27, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression.ExpressionMap map = 28; */
        if (message.kind.oneofKind === "map")
            DerivationExpression_ExpressionMap.internalBinaryWrite(message.kind.map, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* uint32 user_defined_pointer = 31; */
        if (message.kind.oneofKind === "userDefinedPointer")
            writer.tag(31, WireType.Varint).uint32(message.kind.userDefinedPointer);
        /* string type_parameter_name = 33; */
        if (message.kind.oneofKind === "typeParameterName")
            writer.tag(33, WireType.LengthDelimited).string(message.kind.typeParameterName);
        /* string integer_parameter_name = 34; */
        if (message.kind.oneofKind === "integerParameterName")
            writer.tag(34, WireType.LengthDelimited).string(message.kind.integerParameterName);
        /* int32 integer_literal = 35; */
        if (message.kind.oneofKind === "integerLiteral")
            writer.tag(35, WireType.Varint).int32(message.kind.integerLiteral);
        /* substrait.DerivationExpression.UnaryOp unary_op = 36; */
        if (message.kind.oneofKind === "unaryOp")
            DerivationExpression_UnaryOp.internalBinaryWrite(message.kind.unaryOp, writer.tag(36, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression.BinaryOp binary_op = 37; */
        if (message.kind.oneofKind === "binaryOp")
            DerivationExpression_BinaryOp.internalBinaryWrite(message.kind.binaryOp, writer.tag(37, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression.IfElse if_else = 38; */
        if (message.kind.oneofKind === "ifElse")
            DerivationExpression_IfElse.internalBinaryWrite(message.kind.ifElse, writer.tag(38, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression.ReturnProgram return_program = 39; */
        if (message.kind.oneofKind === "returnProgram")
            DerivationExpression_ReturnProgram.internalBinaryWrite(message.kind.returnProgram, writer.tag(39, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.DerivationExpression
 */
export const DerivationExpression = new DerivationExpression$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivationExpression_ExpressionFixedChar$Type extends MessageType<DerivationExpression_ExpressionFixedChar> {
    constructor() {
        super("substrait.DerivationExpression.ExpressionFixedChar", [
            { no: 1, name: "length", kind: "message", T: () => DerivationExpression },
            { no: 2, name: "variation_pointer", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<DerivationExpression_ExpressionFixedChar>): DerivationExpression_ExpressionFixedChar {
        const message = { variationPointer: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DerivationExpression_ExpressionFixedChar>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivationExpression_ExpressionFixedChar): DerivationExpression_ExpressionFixedChar {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.DerivationExpression length */ 1:
                    message.length = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.length);
                    break;
                case /* uint32 variation_pointer */ 2:
                    message.variationPointer = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 3:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivationExpression_ExpressionFixedChar, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.DerivationExpression length = 1; */
        if (message.length)
            DerivationExpression.internalBinaryWrite(message.length, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 variation_pointer = 2; */
        if (message.variationPointer !== 0)
            writer.tag(2, WireType.Varint).uint32(message.variationPointer);
        /* substrait.Type.Nullability nullability = 3; */
        if (message.nullability !== 0)
            writer.tag(3, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.DerivationExpression.ExpressionFixedChar
 */
export const DerivationExpression_ExpressionFixedChar = new DerivationExpression_ExpressionFixedChar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivationExpression_ExpressionVarChar$Type extends MessageType<DerivationExpression_ExpressionVarChar> {
    constructor() {
        super("substrait.DerivationExpression.ExpressionVarChar", [
            { no: 1, name: "length", kind: "message", T: () => DerivationExpression },
            { no: 2, name: "variation_pointer", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<DerivationExpression_ExpressionVarChar>): DerivationExpression_ExpressionVarChar {
        const message = { variationPointer: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DerivationExpression_ExpressionVarChar>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivationExpression_ExpressionVarChar): DerivationExpression_ExpressionVarChar {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.DerivationExpression length */ 1:
                    message.length = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.length);
                    break;
                case /* uint32 variation_pointer */ 2:
                    message.variationPointer = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 3:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivationExpression_ExpressionVarChar, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.DerivationExpression length = 1; */
        if (message.length)
            DerivationExpression.internalBinaryWrite(message.length, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 variation_pointer = 2; */
        if (message.variationPointer !== 0)
            writer.tag(2, WireType.Varint).uint32(message.variationPointer);
        /* substrait.Type.Nullability nullability = 3; */
        if (message.nullability !== 0)
            writer.tag(3, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.DerivationExpression.ExpressionVarChar
 */
export const DerivationExpression_ExpressionVarChar = new DerivationExpression_ExpressionVarChar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivationExpression_ExpressionFixedBinary$Type extends MessageType<DerivationExpression_ExpressionFixedBinary> {
    constructor() {
        super("substrait.DerivationExpression.ExpressionFixedBinary", [
            { no: 1, name: "length", kind: "message", T: () => DerivationExpression },
            { no: 2, name: "variation_pointer", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<DerivationExpression_ExpressionFixedBinary>): DerivationExpression_ExpressionFixedBinary {
        const message = { variationPointer: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DerivationExpression_ExpressionFixedBinary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivationExpression_ExpressionFixedBinary): DerivationExpression_ExpressionFixedBinary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.DerivationExpression length */ 1:
                    message.length = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.length);
                    break;
                case /* uint32 variation_pointer */ 2:
                    message.variationPointer = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 3:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivationExpression_ExpressionFixedBinary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.DerivationExpression length = 1; */
        if (message.length)
            DerivationExpression.internalBinaryWrite(message.length, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 variation_pointer = 2; */
        if (message.variationPointer !== 0)
            writer.tag(2, WireType.Varint).uint32(message.variationPointer);
        /* substrait.Type.Nullability nullability = 3; */
        if (message.nullability !== 0)
            writer.tag(3, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.DerivationExpression.ExpressionFixedBinary
 */
export const DerivationExpression_ExpressionFixedBinary = new DerivationExpression_ExpressionFixedBinary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivationExpression_ExpressionDecimal$Type extends MessageType<DerivationExpression_ExpressionDecimal> {
    constructor() {
        super("substrait.DerivationExpression.ExpressionDecimal", [
            { no: 1, name: "scale", kind: "message", T: () => DerivationExpression },
            { no: 2, name: "precision", kind: "message", T: () => DerivationExpression },
            { no: 3, name: "variation_pointer", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<DerivationExpression_ExpressionDecimal>): DerivationExpression_ExpressionDecimal {
        const message = { variationPointer: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DerivationExpression_ExpressionDecimal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivationExpression_ExpressionDecimal): DerivationExpression_ExpressionDecimal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.DerivationExpression scale */ 1:
                    message.scale = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.scale);
                    break;
                case /* substrait.DerivationExpression precision */ 2:
                    message.precision = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.precision);
                    break;
                case /* uint32 variation_pointer */ 3:
                    message.variationPointer = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 4:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivationExpression_ExpressionDecimal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.DerivationExpression scale = 1; */
        if (message.scale)
            DerivationExpression.internalBinaryWrite(message.scale, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression precision = 2; */
        if (message.precision)
            DerivationExpression.internalBinaryWrite(message.precision, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 variation_pointer = 3; */
        if (message.variationPointer !== 0)
            writer.tag(3, WireType.Varint).uint32(message.variationPointer);
        /* substrait.Type.Nullability nullability = 4; */
        if (message.nullability !== 0)
            writer.tag(4, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.DerivationExpression.ExpressionDecimal
 */
export const DerivationExpression_ExpressionDecimal = new DerivationExpression_ExpressionDecimal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivationExpression_ExpressionStruct$Type extends MessageType<DerivationExpression_ExpressionStruct> {
    constructor() {
        super("substrait.DerivationExpression.ExpressionStruct", [
            { no: 1, name: "types", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DerivationExpression },
            { no: 2, name: "variation_pointer", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<DerivationExpression_ExpressionStruct>): DerivationExpression_ExpressionStruct {
        const message = { types: [], variationPointer: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DerivationExpression_ExpressionStruct>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivationExpression_ExpressionStruct): DerivationExpression_ExpressionStruct {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.DerivationExpression types */ 1:
                    message.types.push(DerivationExpression.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 variation_pointer */ 2:
                    message.variationPointer = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 3:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivationExpression_ExpressionStruct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.DerivationExpression types = 1; */
        for (let i = 0; i < message.types.length; i++)
            DerivationExpression.internalBinaryWrite(message.types[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 variation_pointer = 2; */
        if (message.variationPointer !== 0)
            writer.tag(2, WireType.Varint).uint32(message.variationPointer);
        /* substrait.Type.Nullability nullability = 3; */
        if (message.nullability !== 0)
            writer.tag(3, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.DerivationExpression.ExpressionStruct
 */
export const DerivationExpression_ExpressionStruct = new DerivationExpression_ExpressionStruct$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivationExpression_ExpressionNamedStruct$Type extends MessageType<DerivationExpression_ExpressionNamedStruct> {
    constructor() {
        super("substrait.DerivationExpression.ExpressionNamedStruct", [
            { no: 1, name: "names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "struct", kind: "message", T: () => DerivationExpression_ExpressionStruct }
        ]);
    }
    create(value?: PartialMessage<DerivationExpression_ExpressionNamedStruct>): DerivationExpression_ExpressionNamedStruct {
        const message = { names: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DerivationExpression_ExpressionNamedStruct>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivationExpression_ExpressionNamedStruct): DerivationExpression_ExpressionNamedStruct {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string names */ 1:
                    message.names.push(reader.string());
                    break;
                case /* substrait.DerivationExpression.ExpressionStruct struct */ 2:
                    message.struct = DerivationExpression_ExpressionStruct.internalBinaryRead(reader, reader.uint32(), options, message.struct);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivationExpression_ExpressionNamedStruct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string names = 1; */
        for (let i = 0; i < message.names.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.names[i]);
        /* substrait.DerivationExpression.ExpressionStruct struct = 2; */
        if (message.struct)
            DerivationExpression_ExpressionStruct.internalBinaryWrite(message.struct, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.DerivationExpression.ExpressionNamedStruct
 */
export const DerivationExpression_ExpressionNamedStruct = new DerivationExpression_ExpressionNamedStruct$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivationExpression_ExpressionList$Type extends MessageType<DerivationExpression_ExpressionList> {
    constructor() {
        super("substrait.DerivationExpression.ExpressionList", [
            { no: 1, name: "type", kind: "message", T: () => DerivationExpression },
            { no: 2, name: "variation_pointer", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<DerivationExpression_ExpressionList>): DerivationExpression_ExpressionList {
        const message = { variationPointer: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DerivationExpression_ExpressionList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivationExpression_ExpressionList): DerivationExpression_ExpressionList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.DerivationExpression type */ 1:
                    message.type = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.type);
                    break;
                case /* uint32 variation_pointer */ 2:
                    message.variationPointer = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 3:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivationExpression_ExpressionList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.DerivationExpression type = 1; */
        if (message.type)
            DerivationExpression.internalBinaryWrite(message.type, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 variation_pointer = 2; */
        if (message.variationPointer !== 0)
            writer.tag(2, WireType.Varint).uint32(message.variationPointer);
        /* substrait.Type.Nullability nullability = 3; */
        if (message.nullability !== 0)
            writer.tag(3, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.DerivationExpression.ExpressionList
 */
export const DerivationExpression_ExpressionList = new DerivationExpression_ExpressionList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivationExpression_ExpressionMap$Type extends MessageType<DerivationExpression_ExpressionMap> {
    constructor() {
        super("substrait.DerivationExpression.ExpressionMap", [
            { no: 1, name: "key", kind: "message", T: () => DerivationExpression },
            { no: 2, name: "value", kind: "message", T: () => DerivationExpression },
            { no: 3, name: "variation_pointer", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<DerivationExpression_ExpressionMap>): DerivationExpression_ExpressionMap {
        const message = { variationPointer: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DerivationExpression_ExpressionMap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivationExpression_ExpressionMap): DerivationExpression_ExpressionMap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.DerivationExpression key */ 1:
                    message.key = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.key);
                    break;
                case /* substrait.DerivationExpression value */ 2:
                    message.value = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* uint32 variation_pointer */ 3:
                    message.variationPointer = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 4:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivationExpression_ExpressionMap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.DerivationExpression key = 1; */
        if (message.key)
            DerivationExpression.internalBinaryWrite(message.key, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression value = 2; */
        if (message.value)
            DerivationExpression.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 variation_pointer = 3; */
        if (message.variationPointer !== 0)
            writer.tag(3, WireType.Varint).uint32(message.variationPointer);
        /* substrait.Type.Nullability nullability = 4; */
        if (message.nullability !== 0)
            writer.tag(4, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.DerivationExpression.ExpressionMap
 */
export const DerivationExpression_ExpressionMap = new DerivationExpression_ExpressionMap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivationExpression_IfElse$Type extends MessageType<DerivationExpression_IfElse> {
    constructor() {
        super("substrait.DerivationExpression.IfElse", [
            { no: 1, name: "if_condition", kind: "message", T: () => DerivationExpression },
            { no: 2, name: "if_return", kind: "message", T: () => DerivationExpression },
            { no: 3, name: "else_return", kind: "message", T: () => DerivationExpression }
        ]);
    }
    create(value?: PartialMessage<DerivationExpression_IfElse>): DerivationExpression_IfElse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DerivationExpression_IfElse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivationExpression_IfElse): DerivationExpression_IfElse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.DerivationExpression if_condition */ 1:
                    message.ifCondition = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.ifCondition);
                    break;
                case /* substrait.DerivationExpression if_return */ 2:
                    message.ifReturn = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.ifReturn);
                    break;
                case /* substrait.DerivationExpression else_return */ 3:
                    message.elseReturn = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.elseReturn);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivationExpression_IfElse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.DerivationExpression if_condition = 1; */
        if (message.ifCondition)
            DerivationExpression.internalBinaryWrite(message.ifCondition, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression if_return = 2; */
        if (message.ifReturn)
            DerivationExpression.internalBinaryWrite(message.ifReturn, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression else_return = 3; */
        if (message.elseReturn)
            DerivationExpression.internalBinaryWrite(message.elseReturn, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.DerivationExpression.IfElse
 */
export const DerivationExpression_IfElse = new DerivationExpression_IfElse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivationExpression_UnaryOp$Type extends MessageType<DerivationExpression_UnaryOp> {
    constructor() {
        super("substrait.DerivationExpression.UnaryOp", [
            { no: 1, name: "op_type", kind: "enum", T: () => ["substrait.DerivationExpression.UnaryOp.UnaryOpType", DerivationExpression_UnaryOp_UnaryOpType, "UNARY_OP_TYPE_"] },
            { no: 2, name: "arg", kind: "message", T: () => DerivationExpression }
        ]);
    }
    create(value?: PartialMessage<DerivationExpression_UnaryOp>): DerivationExpression_UnaryOp {
        const message = { opType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DerivationExpression_UnaryOp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivationExpression_UnaryOp): DerivationExpression_UnaryOp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.DerivationExpression.UnaryOp.UnaryOpType op_type */ 1:
                    message.opType = reader.int32();
                    break;
                case /* substrait.DerivationExpression arg */ 2:
                    message.arg = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.arg);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivationExpression_UnaryOp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.DerivationExpression.UnaryOp.UnaryOpType op_type = 1; */
        if (message.opType !== 0)
            writer.tag(1, WireType.Varint).int32(message.opType);
        /* substrait.DerivationExpression arg = 2; */
        if (message.arg)
            DerivationExpression.internalBinaryWrite(message.arg, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.DerivationExpression.UnaryOp
 */
export const DerivationExpression_UnaryOp = new DerivationExpression_UnaryOp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivationExpression_BinaryOp$Type extends MessageType<DerivationExpression_BinaryOp> {
    constructor() {
        super("substrait.DerivationExpression.BinaryOp", [
            { no: 1, name: "op_type", kind: "enum", T: () => ["substrait.DerivationExpression.BinaryOp.BinaryOpType", DerivationExpression_BinaryOp_BinaryOpType, "BINARY_OP_TYPE_"] },
            { no: 2, name: "arg1", kind: "message", T: () => DerivationExpression },
            { no: 3, name: "arg2", kind: "message", T: () => DerivationExpression }
        ]);
    }
    create(value?: PartialMessage<DerivationExpression_BinaryOp>): DerivationExpression_BinaryOp {
        const message = { opType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DerivationExpression_BinaryOp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivationExpression_BinaryOp): DerivationExpression_BinaryOp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.DerivationExpression.BinaryOp.BinaryOpType op_type */ 1:
                    message.opType = reader.int32();
                    break;
                case /* substrait.DerivationExpression arg1 */ 2:
                    message.arg1 = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.arg1);
                    break;
                case /* substrait.DerivationExpression arg2 */ 3:
                    message.arg2 = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.arg2);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivationExpression_BinaryOp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.DerivationExpression.BinaryOp.BinaryOpType op_type = 1; */
        if (message.opType !== 0)
            writer.tag(1, WireType.Varint).int32(message.opType);
        /* substrait.DerivationExpression arg1 = 2; */
        if (message.arg1)
            DerivationExpression.internalBinaryWrite(message.arg1, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression arg2 = 3; */
        if (message.arg2)
            DerivationExpression.internalBinaryWrite(message.arg2, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.DerivationExpression.BinaryOp
 */
export const DerivationExpression_BinaryOp = new DerivationExpression_BinaryOp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivationExpression_ReturnProgram$Type extends MessageType<DerivationExpression_ReturnProgram> {
    constructor() {
        super("substrait.DerivationExpression.ReturnProgram", [
            { no: 1, name: "assignments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DerivationExpression_ReturnProgram_Assignment },
            { no: 2, name: "final_expression", kind: "message", T: () => DerivationExpression }
        ]);
    }
    create(value?: PartialMessage<DerivationExpression_ReturnProgram>): DerivationExpression_ReturnProgram {
        const message = { assignments: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DerivationExpression_ReturnProgram>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivationExpression_ReturnProgram): DerivationExpression_ReturnProgram {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.DerivationExpression.ReturnProgram.Assignment assignments */ 1:
                    message.assignments.push(DerivationExpression_ReturnProgram_Assignment.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* substrait.DerivationExpression final_expression */ 2:
                    message.finalExpression = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.finalExpression);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivationExpression_ReturnProgram, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.DerivationExpression.ReturnProgram.Assignment assignments = 1; */
        for (let i = 0; i < message.assignments.length; i++)
            DerivationExpression_ReturnProgram_Assignment.internalBinaryWrite(message.assignments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression final_expression = 2; */
        if (message.finalExpression)
            DerivationExpression.internalBinaryWrite(message.finalExpression, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.DerivationExpression.ReturnProgram
 */
export const DerivationExpression_ReturnProgram = new DerivationExpression_ReturnProgram$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DerivationExpression_ReturnProgram_Assignment$Type extends MessageType<DerivationExpression_ReturnProgram_Assignment> {
    constructor() {
        super("substrait.DerivationExpression.ReturnProgram.Assignment", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "expression", kind: "message", T: () => DerivationExpression }
        ]);
    }
    create(value?: PartialMessage<DerivationExpression_ReturnProgram_Assignment>): DerivationExpression_ReturnProgram_Assignment {
        const message = { name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DerivationExpression_ReturnProgram_Assignment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DerivationExpression_ReturnProgram_Assignment): DerivationExpression_ReturnProgram_Assignment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* substrait.DerivationExpression expression */ 2:
                    message.expression = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.expression);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DerivationExpression_ReturnProgram_Assignment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* substrait.DerivationExpression expression = 2; */
        if (message.expression)
            DerivationExpression.internalBinaryWrite(message.expression, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.DerivationExpression.ReturnProgram.Assignment
 */
export const DerivationExpression_ReturnProgram_Assignment = new DerivationExpression_ReturnProgram_Assignment$Type();
