// @generated by protobuf-ts 2.2.4
// @generated from protobuf file "substrait/extensions/extensions.proto" (package "substrait.extensions", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Any } from "../../google/protobuf/any";
/**
 * @generated from protobuf message substrait.extensions.SimpleExtensionURI
 */
export interface SimpleExtensionURI {
    /**
     * A surrogate key used in the context of a single plan used to reference the
     * URI associated with an extension.
     *
     * @generated from protobuf field: uint32 extension_uri_anchor = 1;
     */
    extensionUriAnchor: number;
    /**
     * The URI where this extension YAML can be retrieved. This is the "namespace"
     * of this extension.
     *
     * @generated from protobuf field: string uri = 2;
     */
    uri: string;
}
/**
 * Describes a mapping between a specific extension entity and the uri where
 * that extension can be found.
 *
 * @generated from protobuf message substrait.extensions.SimpleExtensionDeclaration
 */
export interface SimpleExtensionDeclaration {
    /**
     * @generated from protobuf oneof: mapping_type
     */
    mappingType: {
        oneofKind: "extensionType";
        /**
         * @generated from protobuf field: substrait.extensions.SimpleExtensionDeclaration.ExtensionType extension_type = 1;
         */
        extensionType: SimpleExtensionDeclaration_ExtensionType;
    } | {
        oneofKind: "extensionTypeVariation";
        /**
         * @generated from protobuf field: substrait.extensions.SimpleExtensionDeclaration.ExtensionTypeVariation extension_type_variation = 2;
         */
        extensionTypeVariation: SimpleExtensionDeclaration_ExtensionTypeVariation;
    } | {
        oneofKind: "extensionFunction";
        /**
         * @generated from protobuf field: substrait.extensions.SimpleExtensionDeclaration.ExtensionFunction extension_function = 3;
         */
        extensionFunction: SimpleExtensionDeclaration_ExtensionFunction;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Describes a Type
 *
 * @generated from protobuf message substrait.extensions.SimpleExtensionDeclaration.ExtensionType
 */
export interface SimpleExtensionDeclaration_ExtensionType {
    /**
     * references the extension_uri_anchor defined for a specific extension URI.
     *
     * @generated from protobuf field: uint32 extension_uri_reference = 1;
     */
    extensionUriReference: number;
    /**
     * A surrogate key used in the context of a single plan to reference a
     * specific extension type
     *
     * @generated from protobuf field: uint32 type_anchor = 2;
     */
    typeAnchor: number;
    /**
     * the name of the type in the defined extension YAML.
     *
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message substrait.extensions.SimpleExtensionDeclaration.ExtensionTypeVariation
 */
export interface SimpleExtensionDeclaration_ExtensionTypeVariation {
    /**
     * references the extension_uri_anchor defined for a specific extension URI.
     *
     * @generated from protobuf field: uint32 extension_uri_reference = 1;
     */
    extensionUriReference: number;
    /**
     * A surrogate key used in the context of a single plan to reference a
     * specific type variation
     *
     * @generated from protobuf field: uint32 type_variation_anchor = 2;
     */
    typeVariationAnchor: number;
    /**
     * the name of the type in the defined extension YAML.
     *
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message substrait.extensions.SimpleExtensionDeclaration.ExtensionFunction
 */
export interface SimpleExtensionDeclaration_ExtensionFunction {
    /**
     * references the extension_uri_anchor defined for a specific extension URI.
     *
     * @generated from protobuf field: uint32 extension_uri_reference = 1;
     */
    extensionUriReference: number;
    /**
     * A surrogate key used in the context of a single plan to reference a
     * specific function
     *
     * @generated from protobuf field: uint32 function_anchor = 2;
     */
    functionAnchor: number;
    /**
     * A simple name if there is only one impl for the function within the YAML.
     * A compound name, referencing that includes type short names if there is
     * more than one impl per name in the YAML.
     *
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * A generic object that can be used to embed additional extension information
 * into the serialized substrait plan.
 *
 * @generated from protobuf message substrait.extensions.AdvancedExtension
 */
export interface AdvancedExtension {
    /**
     * An optimization is helpful information that don't influence semantics. May
     * be ignored by a consumer.
     *
     * @generated from protobuf field: google.protobuf.Any optimization = 1;
     */
    optimization?: Any;
    /**
     * An enhancement alter semantics. Cannot be ignored by a consumer.
     *
     * @generated from protobuf field: google.protobuf.Any enhancement = 2;
     */
    enhancement?: Any;
}
// @generated message type with reflection information, may provide speed optimized methods
class SimpleExtensionURI$Type extends MessageType<SimpleExtensionURI> {
    constructor() {
        super("substrait.extensions.SimpleExtensionURI", [
            { no: 1, name: "extension_uri_anchor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SimpleExtensionURI>): SimpleExtensionURI {
        const message = { extensionUriAnchor: 0, uri: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SimpleExtensionURI>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleExtensionURI): SimpleExtensionURI {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 extension_uri_anchor */ 1:
                    message.extensionUriAnchor = reader.uint32();
                    break;
                case /* string uri */ 2:
                    message.uri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleExtensionURI, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 extension_uri_anchor = 1; */
        if (message.extensionUriAnchor !== 0)
            writer.tag(1, WireType.Varint).uint32(message.extensionUriAnchor);
        /* string uri = 2; */
        if (message.uri !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.extensions.SimpleExtensionURI
 */
export const SimpleExtensionURI = new SimpleExtensionURI$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimpleExtensionDeclaration$Type extends MessageType<SimpleExtensionDeclaration> {
    constructor() {
        super("substrait.extensions.SimpleExtensionDeclaration", [
            { no: 1, name: "extension_type", kind: "message", oneof: "mappingType", T: () => SimpleExtensionDeclaration_ExtensionType },
            { no: 2, name: "extension_type_variation", kind: "message", oneof: "mappingType", T: () => SimpleExtensionDeclaration_ExtensionTypeVariation },
            { no: 3, name: "extension_function", kind: "message", oneof: "mappingType", T: () => SimpleExtensionDeclaration_ExtensionFunction }
        ]);
    }
    create(value?: PartialMessage<SimpleExtensionDeclaration>): SimpleExtensionDeclaration {
        const message = { mappingType: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SimpleExtensionDeclaration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleExtensionDeclaration): SimpleExtensionDeclaration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.extensions.SimpleExtensionDeclaration.ExtensionType extension_type */ 1:
                    message.mappingType = {
                        oneofKind: "extensionType",
                        extensionType: SimpleExtensionDeclaration_ExtensionType.internalBinaryRead(reader, reader.uint32(), options, (message.mappingType as any).extensionType)
                    };
                    break;
                case /* substrait.extensions.SimpleExtensionDeclaration.ExtensionTypeVariation extension_type_variation */ 2:
                    message.mappingType = {
                        oneofKind: "extensionTypeVariation",
                        extensionTypeVariation: SimpleExtensionDeclaration_ExtensionTypeVariation.internalBinaryRead(reader, reader.uint32(), options, (message.mappingType as any).extensionTypeVariation)
                    };
                    break;
                case /* substrait.extensions.SimpleExtensionDeclaration.ExtensionFunction extension_function */ 3:
                    message.mappingType = {
                        oneofKind: "extensionFunction",
                        extensionFunction: SimpleExtensionDeclaration_ExtensionFunction.internalBinaryRead(reader, reader.uint32(), options, (message.mappingType as any).extensionFunction)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleExtensionDeclaration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.extensions.SimpleExtensionDeclaration.ExtensionType extension_type = 1; */
        if (message.mappingType.oneofKind === "extensionType")
            SimpleExtensionDeclaration_ExtensionType.internalBinaryWrite(message.mappingType.extensionType, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.extensions.SimpleExtensionDeclaration.ExtensionTypeVariation extension_type_variation = 2; */
        if (message.mappingType.oneofKind === "extensionTypeVariation")
            SimpleExtensionDeclaration_ExtensionTypeVariation.internalBinaryWrite(message.mappingType.extensionTypeVariation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.extensions.SimpleExtensionDeclaration.ExtensionFunction extension_function = 3; */
        if (message.mappingType.oneofKind === "extensionFunction")
            SimpleExtensionDeclaration_ExtensionFunction.internalBinaryWrite(message.mappingType.extensionFunction, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.extensions.SimpleExtensionDeclaration
 */
export const SimpleExtensionDeclaration = new SimpleExtensionDeclaration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimpleExtensionDeclaration_ExtensionType$Type extends MessageType<SimpleExtensionDeclaration_ExtensionType> {
    constructor() {
        super("substrait.extensions.SimpleExtensionDeclaration.ExtensionType", [
            { no: 1, name: "extension_uri_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "type_anchor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SimpleExtensionDeclaration_ExtensionType>): SimpleExtensionDeclaration_ExtensionType {
        const message = { extensionUriReference: 0, typeAnchor: 0, name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SimpleExtensionDeclaration_ExtensionType>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleExtensionDeclaration_ExtensionType): SimpleExtensionDeclaration_ExtensionType {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 extension_uri_reference */ 1:
                    message.extensionUriReference = reader.uint32();
                    break;
                case /* uint32 type_anchor */ 2:
                    message.typeAnchor = reader.uint32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleExtensionDeclaration_ExtensionType, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 extension_uri_reference = 1; */
        if (message.extensionUriReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.extensionUriReference);
        /* uint32 type_anchor = 2; */
        if (message.typeAnchor !== 0)
            writer.tag(2, WireType.Varint).uint32(message.typeAnchor);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.extensions.SimpleExtensionDeclaration.ExtensionType
 */
export const SimpleExtensionDeclaration_ExtensionType = new SimpleExtensionDeclaration_ExtensionType$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimpleExtensionDeclaration_ExtensionTypeVariation$Type extends MessageType<SimpleExtensionDeclaration_ExtensionTypeVariation> {
    constructor() {
        super("substrait.extensions.SimpleExtensionDeclaration.ExtensionTypeVariation", [
            { no: 1, name: "extension_uri_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "type_variation_anchor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SimpleExtensionDeclaration_ExtensionTypeVariation>): SimpleExtensionDeclaration_ExtensionTypeVariation {
        const message = { extensionUriReference: 0, typeVariationAnchor: 0, name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SimpleExtensionDeclaration_ExtensionTypeVariation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleExtensionDeclaration_ExtensionTypeVariation): SimpleExtensionDeclaration_ExtensionTypeVariation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 extension_uri_reference */ 1:
                    message.extensionUriReference = reader.uint32();
                    break;
                case /* uint32 type_variation_anchor */ 2:
                    message.typeVariationAnchor = reader.uint32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleExtensionDeclaration_ExtensionTypeVariation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 extension_uri_reference = 1; */
        if (message.extensionUriReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.extensionUriReference);
        /* uint32 type_variation_anchor = 2; */
        if (message.typeVariationAnchor !== 0)
            writer.tag(2, WireType.Varint).uint32(message.typeVariationAnchor);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.extensions.SimpleExtensionDeclaration.ExtensionTypeVariation
 */
export const SimpleExtensionDeclaration_ExtensionTypeVariation = new SimpleExtensionDeclaration_ExtensionTypeVariation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SimpleExtensionDeclaration_ExtensionFunction$Type extends MessageType<SimpleExtensionDeclaration_ExtensionFunction> {
    constructor() {
        super("substrait.extensions.SimpleExtensionDeclaration.ExtensionFunction", [
            { no: 1, name: "extension_uri_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "function_anchor", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SimpleExtensionDeclaration_ExtensionFunction>): SimpleExtensionDeclaration_ExtensionFunction {
        const message = { extensionUriReference: 0, functionAnchor: 0, name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SimpleExtensionDeclaration_ExtensionFunction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SimpleExtensionDeclaration_ExtensionFunction): SimpleExtensionDeclaration_ExtensionFunction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 extension_uri_reference */ 1:
                    message.extensionUriReference = reader.uint32();
                    break;
                case /* uint32 function_anchor */ 2:
                    message.functionAnchor = reader.uint32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SimpleExtensionDeclaration_ExtensionFunction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 extension_uri_reference = 1; */
        if (message.extensionUriReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.extensionUriReference);
        /* uint32 function_anchor = 2; */
        if (message.functionAnchor !== 0)
            writer.tag(2, WireType.Varint).uint32(message.functionAnchor);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.extensions.SimpleExtensionDeclaration.ExtensionFunction
 */
export const SimpleExtensionDeclaration_ExtensionFunction = new SimpleExtensionDeclaration_ExtensionFunction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdvancedExtension$Type extends MessageType<AdvancedExtension> {
    constructor() {
        super("substrait.extensions.AdvancedExtension", [
            { no: 1, name: "optimization", kind: "message", T: () => Any },
            { no: 2, name: "enhancement", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<AdvancedExtension>): AdvancedExtension {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdvancedExtension>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdvancedExtension): AdvancedExtension {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any optimization */ 1:
                    message.optimization = Any.internalBinaryRead(reader, reader.uint32(), options, message.optimization);
                    break;
                case /* google.protobuf.Any enhancement */ 2:
                    message.enhancement = Any.internalBinaryRead(reader, reader.uint32(), options, message.enhancement);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdvancedExtension, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any optimization = 1; */
        if (message.optimization)
            Any.internalBinaryWrite(message.optimization, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any enhancement = 2; */
        if (message.enhancement)
            Any.internalBinaryWrite(message.enhancement, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.extensions.AdvancedExtension
 */
export const AdvancedExtension = new AdvancedExtension$Type();
