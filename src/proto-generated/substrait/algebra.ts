// @generated by protobuf-ts 2.2.4
// @generated from protobuf file "substrait/algebra.proto" (package "substrait", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Type_Map } from "./type";
import { Type_List } from "./type";
import { Type } from "./type";
import { Any } from "../google/protobuf/any";
import { NamedStruct } from "./type";
import { AdvancedExtension } from "./extensions/extensions";
/**
 * @generated from protobuf message substrait.RelCommon
 */
export interface RelCommon {
    /**
     * @generated from protobuf oneof: emit_kind
     */
    emitKind: {
        oneofKind: "direct";
        /**
         * @generated from protobuf field: substrait.RelCommon.Direct direct = 1;
         */
        direct: RelCommon_Direct;
    } | {
        oneofKind: "emit";
        /**
         * @generated from protobuf field: substrait.RelCommon.Emit emit = 2;
         */
        emit: RelCommon_Emit;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: substrait.RelCommon.Hint hint = 3;
     */
    hint?: RelCommon_Hint;
    /**
     * @generated from protobuf field: substrait.extensions.AdvancedExtension advanced_extension = 4;
     */
    advancedExtension?: AdvancedExtension;
}
/**
 * @generated from protobuf message substrait.RelCommon.Direct
 */
export interface RelCommon_Direct {
}
/**
 * @generated from protobuf message substrait.RelCommon.Emit
 */
export interface RelCommon_Emit {
    /**
     * @generated from protobuf field: repeated int32 output_mapping = 1;
     */
    outputMapping: number[];
}
/**
 * Changes to the operation that can influence efficiency/performance but
 * should not impact correctness.
 *
 * @generated from protobuf message substrait.RelCommon.Hint
 */
export interface RelCommon_Hint {
    /**
     * @generated from protobuf field: substrait.RelCommon.Hint.Stats stats = 1;
     */
    stats?: RelCommon_Hint_Stats;
    /**
     * @generated from protobuf field: substrait.RelCommon.Hint.RuntimeConstraint constraint = 2;
     */
    constraint?: RelCommon_Hint_RuntimeConstraint;
    /**
     * @generated from protobuf field: substrait.extensions.AdvancedExtension advanced_extension = 10;
     */
    advancedExtension?: AdvancedExtension;
}
/**
 * @generated from protobuf message substrait.RelCommon.Hint.Stats
 */
export interface RelCommon_Hint_Stats {
    /**
     * @generated from protobuf field: double row_count = 1;
     */
    rowCount: number;
    /**
     * @generated from protobuf field: double record_size = 2;
     */
    recordSize: number;
    /**
     * @generated from protobuf field: substrait.extensions.AdvancedExtension advanced_extension = 10;
     */
    advancedExtension?: AdvancedExtension;
}
/**
 * TODO: nodes, cpu threads/%, memory, iops, etc.
 *
 * @generated from protobuf message substrait.RelCommon.Hint.RuntimeConstraint
 */
export interface RelCommon_Hint_RuntimeConstraint {
    /**
     * @generated from protobuf field: substrait.extensions.AdvancedExtension advanced_extension = 10;
     */
    advancedExtension?: AdvancedExtension;
}
/**
 * @generated from protobuf message substrait.ReadRel
 */
export interface ReadRel {
    /**
     * @generated from protobuf field: substrait.RelCommon common = 1;
     */
    common?: RelCommon;
    /**
     * @generated from protobuf field: substrait.NamedStruct base_schema = 2;
     */
    baseSchema?: NamedStruct;
    /**
     * @generated from protobuf field: substrait.Expression filter = 3;
     */
    filter?: Expression;
    /**
     * @generated from protobuf field: substrait.Expression.MaskExpression projection = 4;
     */
    projection?: Expression_MaskExpression;
    /**
     * @generated from protobuf field: substrait.extensions.AdvancedExtension advanced_extension = 10;
     */
    advancedExtension?: AdvancedExtension;
    /**
     * @generated from protobuf oneof: read_type
     */
    readType: {
        oneofKind: "virtualTable";
        /**
         * @generated from protobuf field: substrait.ReadRel.VirtualTable virtual_table = 5;
         */
        virtualTable: ReadRel_VirtualTable;
    } | {
        oneofKind: "localFiles";
        /**
         * @generated from protobuf field: substrait.ReadRel.LocalFiles local_files = 6;
         */
        localFiles: ReadRel_LocalFiles;
    } | {
        oneofKind: "namedTable";
        /**
         * @generated from protobuf field: substrait.ReadRel.NamedTable named_table = 7;
         */
        namedTable: ReadRel_NamedTable;
    } | {
        oneofKind: "extensionTable";
        /**
         * @generated from protobuf field: substrait.ReadRel.ExtensionTable extension_table = 8;
         */
        extensionTable: ReadRel_ExtensionTable;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message substrait.ReadRel.NamedTable
 */
export interface ReadRel_NamedTable {
    /**
     * @generated from protobuf field: repeated string names = 1;
     */
    names: string[];
    /**
     * @generated from protobuf field: substrait.extensions.AdvancedExtension advanced_extension = 10;
     */
    advancedExtension?: AdvancedExtension;
}
/**
 * a table composed of literals.
 *
 * @generated from protobuf message substrait.ReadRel.VirtualTable
 */
export interface ReadRel_VirtualTable {
    /**
     * @generated from protobuf field: repeated substrait.Expression.Literal.Struct values = 1;
     */
    values: Expression_Literal_Struct[];
}
/**
 * a stub type that can be used to extend/introduce new table types outside
 * the specification.
 *
 * @generated from protobuf message substrait.ReadRel.ExtensionTable
 */
export interface ReadRel_ExtensionTable {
    /**
     * @generated from protobuf field: google.protobuf.Any detail = 1;
     */
    detail?: Any;
}
/**
 * @generated from protobuf message substrait.ReadRel.LocalFiles
 */
export interface ReadRel_LocalFiles {
    /**
     * @generated from protobuf field: repeated substrait.ReadRel.LocalFiles.FileOrFiles items = 1;
     */
    items: ReadRel_LocalFiles_FileOrFiles[];
    /**
     * @generated from protobuf field: substrait.extensions.AdvancedExtension advanced_extension = 10;
     */
    advancedExtension?: AdvancedExtension;
}
/**
 * Many files consist of indivisible chunks (e.g. parquet row groups
 * or CSV rows).  If a slice partially selects an indivisible chunk
 * then the consumer should employ some rule to decide which slice to
 * include the chunk in (e.g. include it in the slice that contains
 * the midpoint of the chunk)
 *
 * @generated from protobuf message substrait.ReadRel.LocalFiles.FileOrFiles
 */
export interface ReadRel_LocalFiles_FileOrFiles {
    /**
     * @generated from protobuf oneof: path_type
     */
    pathType: {
        oneofKind: "uriPath";
        /**
         * @generated from protobuf field: string uri_path = 1;
         */
        uriPath: string;
    } | {
        oneofKind: "uriPathGlob";
        /**
         * @generated from protobuf field: string uri_path_glob = 2;
         */
        uriPathGlob: string;
    } | {
        oneofKind: "uriFile";
        /**
         * @generated from protobuf field: string uri_file = 3;
         */
        uriFile: string;
    } | {
        oneofKind: "uriFolder";
        /**
         * @generated from protobuf field: string uri_folder = 4;
         */
        uriFolder: string;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: substrait.ReadRel.LocalFiles.FileOrFiles.FileFormat format = 5;
     */
    format: ReadRel_LocalFiles_FileOrFiles_FileFormat;
    /**
     * the index of the partition this item belongs to
     *
     * @generated from protobuf field: uint64 partition_index = 6;
     */
    partitionIndex: bigint;
    /**
     * the start position in byte to read from this item
     *
     * @generated from protobuf field: uint64 start = 7;
     */
    start: bigint;
    /**
     * the length in byte to read from this item
     *
     * @generated from protobuf field: uint64 length = 8;
     */
    length: bigint;
}
/**
 * @generated from protobuf enum substrait.ReadRel.LocalFiles.FileOrFiles.FileFormat
 */
export enum ReadRel_LocalFiles_FileOrFiles_FileFormat {
    /**
     * @generated from protobuf enum value: FILE_FORMAT_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: FILE_FORMAT_PARQUET = 1;
     */
    PARQUET = 1
}
/**
 * @generated from protobuf message substrait.ProjectRel
 */
export interface ProjectRel {
    /**
     * @generated from protobuf field: substrait.RelCommon common = 1;
     */
    common?: RelCommon;
    /**
     * @generated from protobuf field: substrait.Rel input = 2;
     */
    input?: Rel;
    /**
     * @generated from protobuf field: repeated substrait.Expression expressions = 3;
     */
    expressions: Expression[];
    /**
     * @generated from protobuf field: substrait.extensions.AdvancedExtension advanced_extension = 10;
     */
    advancedExtension?: AdvancedExtension;
}
/**
 * @generated from protobuf message substrait.JoinRel
 */
export interface JoinRel {
    /**
     * @generated from protobuf field: substrait.RelCommon common = 1;
     */
    common?: RelCommon;
    /**
     * @generated from protobuf field: substrait.Rel left = 2;
     */
    left?: Rel;
    /**
     * @generated from protobuf field: substrait.Rel right = 3;
     */
    right?: Rel;
    /**
     * @generated from protobuf field: substrait.Expression expression = 4;
     */
    expression?: Expression;
    /**
     * @generated from protobuf field: substrait.Expression post_join_filter = 5;
     */
    postJoinFilter?: Expression;
    /**
     * @generated from protobuf field: substrait.JoinRel.JoinType type = 6;
     */
    type: JoinRel_JoinType;
    /**
     * @generated from protobuf field: substrait.extensions.AdvancedExtension advanced_extension = 10;
     */
    advancedExtension?: AdvancedExtension;
}
/**
 * @generated from protobuf enum substrait.JoinRel.JoinType
 */
export enum JoinRel_JoinType {
    /**
     * @generated from protobuf enum value: JOIN_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: JOIN_TYPE_INNER = 1;
     */
    INNER = 1,
    /**
     * @generated from protobuf enum value: JOIN_TYPE_OUTER = 2;
     */
    OUTER = 2,
    /**
     * @generated from protobuf enum value: JOIN_TYPE_LEFT = 3;
     */
    LEFT = 3,
    /**
     * @generated from protobuf enum value: JOIN_TYPE_RIGHT = 4;
     */
    RIGHT = 4,
    /**
     * @generated from protobuf enum value: JOIN_TYPE_SEMI = 5;
     */
    SEMI = 5,
    /**
     * @generated from protobuf enum value: JOIN_TYPE_ANTI = 6;
     */
    ANTI = 6,
    /**
     * @generated from protobuf enum value: JOIN_TYPE_SINGLE = 7;
     */
    SINGLE = 7
}
/**
 * @generated from protobuf message substrait.CrossRel
 */
export interface CrossRel {
    /**
     * @generated from protobuf field: substrait.RelCommon common = 1;
     */
    common?: RelCommon;
    /**
     * @generated from protobuf field: substrait.Rel left = 2;
     */
    left?: Rel;
    /**
     * @generated from protobuf field: substrait.Rel right = 3;
     */
    right?: Rel;
    /**
     * @generated from protobuf field: substrait.extensions.AdvancedExtension advanced_extension = 10;
     */
    advancedExtension?: AdvancedExtension;
}
/**
 * @generated from protobuf message substrait.FetchRel
 */
export interface FetchRel {
    /**
     * @generated from protobuf field: substrait.RelCommon common = 1;
     */
    common?: RelCommon;
    /**
     * @generated from protobuf field: substrait.Rel input = 2;
     */
    input?: Rel;
    /**
     * @generated from protobuf field: int64 offset = 3;
     */
    offset: bigint;
    /**
     * @generated from protobuf field: int64 count = 4;
     */
    count: bigint;
    /**
     * @generated from protobuf field: substrait.extensions.AdvancedExtension advanced_extension = 10;
     */
    advancedExtension?: AdvancedExtension;
}
/**
 * @generated from protobuf message substrait.AggregateRel
 */
export interface AggregateRel {
    /**
     * @generated from protobuf field: substrait.RelCommon common = 1;
     */
    common?: RelCommon;
    /**
     * @generated from protobuf field: substrait.Rel input = 2;
     */
    input?: Rel;
    /**
     * @generated from protobuf field: repeated substrait.AggregateRel.Grouping groupings = 3;
     */
    groupings: AggregateRel_Grouping[];
    /**
     * @generated from protobuf field: repeated substrait.AggregateRel.Measure measures = 4;
     */
    measures: AggregateRel_Measure[];
    /**
     * @generated from protobuf field: substrait.extensions.AdvancedExtension advanced_extension = 10;
     */
    advancedExtension?: AdvancedExtension;
}
/**
 * @generated from protobuf message substrait.AggregateRel.Grouping
 */
export interface AggregateRel_Grouping {
    /**
     * @generated from protobuf field: repeated substrait.Expression grouping_expressions = 1;
     */
    groupingExpressions: Expression[];
}
/**
 * @generated from protobuf message substrait.AggregateRel.Measure
 */
export interface AggregateRel_Measure {
    /**
     * @generated from protobuf field: substrait.AggregateFunction measure = 1;
     */
    measure?: AggregateFunction;
    /**
     * An optional boolean expression that acts to filter which records are
     * included in the measure. True means include this record for calculation
     * within the measure.
     *
     * @generated from protobuf field: substrait.Expression filter = 2;
     */
    filter?: Expression;
}
/**
 * @generated from protobuf message substrait.SortRel
 */
export interface SortRel {
    /**
     * @generated from protobuf field: substrait.RelCommon common = 1;
     */
    common?: RelCommon;
    /**
     * @generated from protobuf field: substrait.Rel input = 2;
     */
    input?: Rel;
    /**
     * @generated from protobuf field: repeated substrait.SortField sorts = 3;
     */
    sorts: SortField[];
    /**
     * @generated from protobuf field: substrait.extensions.AdvancedExtension advanced_extension = 10;
     */
    advancedExtension?: AdvancedExtension;
}
/**
 * @generated from protobuf message substrait.FilterRel
 */
export interface FilterRel {
    /**
     * @generated from protobuf field: substrait.RelCommon common = 1;
     */
    common?: RelCommon;
    /**
     * @generated from protobuf field: substrait.Rel input = 2;
     */
    input?: Rel;
    /**
     * @generated from protobuf field: substrait.Expression condition = 3;
     */
    condition?: Expression;
    /**
     * @generated from protobuf field: substrait.extensions.AdvancedExtension advanced_extension = 10;
     */
    advancedExtension?: AdvancedExtension;
}
/**
 * @generated from protobuf message substrait.SetRel
 */
export interface SetRel {
    /**
     * @generated from protobuf field: substrait.RelCommon common = 1;
     */
    common?: RelCommon;
    /**
     * @generated from protobuf field: repeated substrait.Rel inputs = 2;
     */
    inputs: Rel[];
    /**
     * @generated from protobuf field: substrait.SetRel.SetOp op = 3;
     */
    op: SetRel_SetOp;
    /**
     * @generated from protobuf field: substrait.extensions.AdvancedExtension advanced_extension = 10;
     */
    advancedExtension?: AdvancedExtension;
}
/**
 * @generated from protobuf enum substrait.SetRel.SetOp
 */
export enum SetRel_SetOp {
    /**
     * @generated from protobuf enum value: SET_OP_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SET_OP_MINUS_PRIMARY = 1;
     */
    MINUS_PRIMARY = 1,
    /**
     * @generated from protobuf enum value: SET_OP_MINUS_MULTISET = 2;
     */
    MINUS_MULTISET = 2,
    /**
     * @generated from protobuf enum value: SET_OP_INTERSECTION_PRIMARY = 3;
     */
    INTERSECTION_PRIMARY = 3,
    /**
     * @generated from protobuf enum value: SET_OP_INTERSECTION_MULTISET = 4;
     */
    INTERSECTION_MULTISET = 4,
    /**
     * @generated from protobuf enum value: SET_OP_UNION_DISTINCT = 5;
     */
    UNION_DISTINCT = 5,
    /**
     * @generated from protobuf enum value: SET_OP_UNION_ALL = 6;
     */
    UNION_ALL = 6
}
/**
 * Stub to support extension with a single input
 *
 * @generated from protobuf message substrait.ExtensionSingleRel
 */
export interface ExtensionSingleRel {
    /**
     * @generated from protobuf field: substrait.RelCommon common = 1;
     */
    common?: RelCommon;
    /**
     * @generated from protobuf field: substrait.Rel input = 2;
     */
    input?: Rel;
    /**
     * @generated from protobuf field: google.protobuf.Any detail = 3;
     */
    detail?: Any;
}
/**
 * Stub to support extension with a zero inputs
 *
 * @generated from protobuf message substrait.ExtensionLeafRel
 */
export interface ExtensionLeafRel {
    /**
     * @generated from protobuf field: substrait.RelCommon common = 1;
     */
    common?: RelCommon;
    /**
     * @generated from protobuf field: google.protobuf.Any detail = 2;
     */
    detail?: Any;
}
/**
 * Stub to support extension with multiple inputs
 *
 * @generated from protobuf message substrait.ExtensionMultiRel
 */
export interface ExtensionMultiRel {
    /**
     * @generated from protobuf field: substrait.RelCommon common = 1;
     */
    common?: RelCommon;
    /**
     * @generated from protobuf field: repeated substrait.Rel inputs = 2;
     */
    inputs: Rel[];
    /**
     * @generated from protobuf field: google.protobuf.Any detail = 3;
     */
    detail?: Any;
}
/**
 * A relation with output field names.
 *
 * This is for use at the root of a `Rel` tree.
 *
 * @generated from protobuf message substrait.RelRoot
 */
export interface RelRoot {
    /**
     * A relation
     *
     * @generated from protobuf field: substrait.Rel input = 1;
     */
    input?: Rel;
    /**
     * Field names in depth-first order
     *
     * @generated from protobuf field: repeated string names = 2;
     */
    names: string[];
}
/**
 * @generated from protobuf message substrait.Rel
 */
export interface Rel {
    /**
     * @generated from protobuf oneof: rel_type
     */
    relType: {
        oneofKind: "read";
        /**
         * @generated from protobuf field: substrait.ReadRel read = 1;
         */
        read: ReadRel;
    } | {
        oneofKind: "filter";
        /**
         * @generated from protobuf field: substrait.FilterRel filter = 2;
         */
        filter: FilterRel;
    } | {
        oneofKind: "fetch";
        /**
         * @generated from protobuf field: substrait.FetchRel fetch = 3;
         */
        fetch: FetchRel;
    } | {
        oneofKind: "aggregate";
        /**
         * @generated from protobuf field: substrait.AggregateRel aggregate = 4;
         */
        aggregate: AggregateRel;
    } | {
        oneofKind: "sort";
        /**
         * @generated from protobuf field: substrait.SortRel sort = 5;
         */
        sort: SortRel;
    } | {
        oneofKind: "join";
        /**
         * @generated from protobuf field: substrait.JoinRel join = 6;
         */
        join: JoinRel;
    } | {
        oneofKind: "project";
        /**
         * @generated from protobuf field: substrait.ProjectRel project = 7;
         */
        project: ProjectRel;
    } | {
        oneofKind: "set";
        /**
         * @generated from protobuf field: substrait.SetRel set = 8;
         */
        set: SetRel;
    } | {
        oneofKind: "extensionSingle";
        /**
         * @generated from protobuf field: substrait.ExtensionSingleRel extension_single = 9;
         */
        extensionSingle: ExtensionSingleRel;
    } | {
        oneofKind: "extensionMulti";
        /**
         * @generated from protobuf field: substrait.ExtensionMultiRel extension_multi = 10;
         */
        extensionMulti: ExtensionMultiRel;
    } | {
        oneofKind: "extensionLeaf";
        /**
         * @generated from protobuf field: substrait.ExtensionLeafRel extension_leaf = 11;
         */
        extensionLeaf: ExtensionLeafRel;
    } | {
        oneofKind: "cross";
        /**
         * @generated from protobuf field: substrait.CrossRel cross = 12;
         */
        cross: CrossRel;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message substrait.Expression
 */
export interface Expression {
    /**
     * @generated from protobuf oneof: rex_type
     */
    rexType: {
        oneofKind: "literal";
        /**
         * @generated from protobuf field: substrait.Expression.Literal literal = 1;
         */
        literal: Expression_Literal;
    } | {
        oneofKind: "selection";
        /**
         * @generated from protobuf field: substrait.Expression.FieldReference selection = 2;
         */
        selection: Expression_FieldReference;
    } | {
        oneofKind: "scalarFunction";
        /**
         * @generated from protobuf field: substrait.Expression.ScalarFunction scalar_function = 3;
         */
        scalarFunction: Expression_ScalarFunction;
    } | {
        oneofKind: "windowFunction";
        /**
         * @generated from protobuf field: substrait.Expression.WindowFunction window_function = 5;
         */
        windowFunction: Expression_WindowFunction;
    } | {
        oneofKind: "ifThen";
        /**
         * @generated from protobuf field: substrait.Expression.IfThen if_then = 6;
         */
        ifThen: Expression_IfThen;
    } | {
        oneofKind: "switchExpression";
        /**
         * @generated from protobuf field: substrait.Expression.SwitchExpression switch_expression = 7;
         */
        switchExpression: Expression_SwitchExpression;
    } | {
        oneofKind: "singularOrList";
        /**
         * @generated from protobuf field: substrait.Expression.SingularOrList singular_or_list = 8;
         */
        singularOrList: Expression_SingularOrList;
    } | {
        oneofKind: "multiOrList";
        /**
         * @generated from protobuf field: substrait.Expression.MultiOrList multi_or_list = 9;
         */
        multiOrList: Expression_MultiOrList;
    } | {
        oneofKind: "enum";
        /**
         * @generated from protobuf field: substrait.Expression.Enum enum = 10;
         */
        enum: Expression_Enum;
    } | {
        oneofKind: "cast";
        /**
         * @generated from protobuf field: substrait.Expression.Cast cast = 11;
         */
        cast: Expression_Cast;
    } | {
        oneofKind: "subquery";
        /**
         * @generated from protobuf field: substrait.Expression.Subquery subquery = 12;
         */
        subquery: Expression_Subquery;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message substrait.Expression.Enum
 */
export interface Expression_Enum {
    /**
     * @generated from protobuf oneof: enum_kind
     */
    enumKind: {
        oneofKind: "specified";
        /**
         * @generated from protobuf field: string specified = 1;
         */
        specified: string;
    } | {
        oneofKind: "unspecified";
        /**
         * @generated from protobuf field: substrait.Expression.Enum.Empty unspecified = 2;
         */
        unspecified: Expression_Enum_Empty;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message substrait.Expression.Enum.Empty
 */
export interface Expression_Enum_Empty {
}
/**
 * @generated from protobuf message substrait.Expression.Literal
 */
export interface Expression_Literal {
    /**
     * @generated from protobuf oneof: literal_type
     */
    literalType: {
        oneofKind: "boolean";
        /**
         * @generated from protobuf field: bool boolean = 1;
         */
        boolean: boolean;
    } | {
        oneofKind: "i8";
        /**
         * @generated from protobuf field: int32 i8 = 2;
         */
        i8: number;
    } | {
        oneofKind: "i16";
        /**
         * @generated from protobuf field: int32 i16 = 3;
         */
        i16: number;
    } | {
        oneofKind: "i32";
        /**
         * @generated from protobuf field: int32 i32 = 5;
         */
        i32: number;
    } | {
        oneofKind: "i64";
        /**
         * @generated from protobuf field: int64 i64 = 7;
         */
        i64: bigint;
    } | {
        oneofKind: "fp32";
        /**
         * @generated from protobuf field: float fp32 = 10;
         */
        fp32: number;
    } | {
        oneofKind: "fp64";
        /**
         * @generated from protobuf field: double fp64 = 11;
         */
        fp64: number;
    } | {
        oneofKind: "string";
        /**
         * @generated from protobuf field: string string = 12;
         */
        string: string;
    } | {
        oneofKind: "binary";
        /**
         * @generated from protobuf field: bytes binary = 13;
         */
        binary: Uint8Array;
    } | {
        oneofKind: "timestamp";
        /**
         * Timestamp in units of microseconds since the UNIX epoch.
         *
         * @generated from protobuf field: int64 timestamp = 14;
         */
        timestamp: bigint;
    } | {
        oneofKind: "date";
        /**
         * Date in units of days since the UNIX epoch.
         *
         * @generated from protobuf field: int32 date = 16;
         */
        date: number;
    } | {
        oneofKind: "time";
        /**
         * Time in units of microseconds past midnight
         *
         * @generated from protobuf field: int64 time = 17;
         */
        time: bigint;
    } | {
        oneofKind: "intervalYearToMonth";
        /**
         * @generated from protobuf field: substrait.Expression.Literal.IntervalYearToMonth interval_year_to_month = 19;
         */
        intervalYearToMonth: Expression_Literal_IntervalYearToMonth;
    } | {
        oneofKind: "intervalDayToSecond";
        /**
         * @generated from protobuf field: substrait.Expression.Literal.IntervalDayToSecond interval_day_to_second = 20;
         */
        intervalDayToSecond: Expression_Literal_IntervalDayToSecond;
    } | {
        oneofKind: "fixedChar";
        /**
         * @generated from protobuf field: string fixed_char = 21;
         */
        fixedChar: string;
    } | {
        oneofKind: "varChar";
        /**
         * @generated from protobuf field: substrait.Expression.Literal.VarChar var_char = 22;
         */
        varChar: Expression_Literal_VarChar;
    } | {
        oneofKind: "fixedBinary";
        /**
         * @generated from protobuf field: bytes fixed_binary = 23;
         */
        fixedBinary: Uint8Array;
    } | {
        oneofKind: "decimal";
        /**
         * @generated from protobuf field: substrait.Expression.Literal.Decimal decimal = 24;
         */
        decimal: Expression_Literal_Decimal;
    } | {
        oneofKind: "struct";
        /**
         * @generated from protobuf field: substrait.Expression.Literal.Struct struct = 25;
         */
        struct: Expression_Literal_Struct;
    } | {
        oneofKind: "map";
        /**
         * @generated from protobuf field: substrait.Expression.Literal.Map map = 26;
         */
        map: Expression_Literal_Map;
    } | {
        oneofKind: "timestampTz";
        /**
         * Timestamp in units of microseconds since the UNIX epoch.
         *
         * @generated from protobuf field: int64 timestamp_tz = 27;
         */
        timestampTz: bigint;
    } | {
        oneofKind: "uuid";
        /**
         * @generated from protobuf field: bytes uuid = 28;
         */
        uuid: Uint8Array;
    } | {
        oneofKind: "null";
        /**
         * @generated from protobuf field: substrait.Type null = 29;
         */
        null: Type; // a typed null literal
    } | {
        oneofKind: "list";
        /**
         * @generated from protobuf field: substrait.Expression.Literal.List list = 30;
         */
        list: Expression_Literal_List;
    } | {
        oneofKind: "emptyList";
        /**
         * @generated from protobuf field: substrait.Type.List empty_list = 31;
         */
        emptyList: Type_List;
    } | {
        oneofKind: "emptyMap";
        /**
         * @generated from protobuf field: substrait.Type.Map empty_map = 32;
         */
        emptyMap: Type_Map;
    } | {
        oneofKind: undefined;
    };
    /**
     * whether the literal type should be treated as a nullable type. Applies to
     * all members of union other than the Typed null (which should directly
     * declare nullability).
     *
     * @generated from protobuf field: bool nullable = 50;
     */
    nullable: boolean;
}
/**
 * @generated from protobuf message substrait.Expression.Literal.VarChar
 */
export interface Expression_Literal_VarChar {
    /**
     * @generated from protobuf field: string value = 1;
     */
    value: string;
    /**
     * @generated from protobuf field: uint32 length = 2;
     */
    length: number;
}
/**
 * @generated from protobuf message substrait.Expression.Literal.Decimal
 */
export interface Expression_Literal_Decimal {
    /**
     * little-endian twos-complement integer representation of complete value
     * (ignoring precision) Always 16 bytes in length
     *
     * @generated from protobuf field: bytes value = 1;
     */
    value: Uint8Array;
    /**
     * The maximum number of digits allowed in the value.
     * the maximum precision is 38.
     *
     * @generated from protobuf field: int32 precision = 2;
     */
    precision: number;
    /**
     * declared scale of decimal literal
     *
     * @generated from protobuf field: int32 scale = 3;
     */
    scale: number;
}
/**
 * @generated from protobuf message substrait.Expression.Literal.Map
 */
export interface Expression_Literal_Map {
    /**
     * @generated from protobuf field: repeated substrait.Expression.Literal.Map.KeyValue key_values = 1;
     */
    keyValues: Expression_Literal_Map_KeyValue[];
}
/**
 * @generated from protobuf message substrait.Expression.Literal.Map.KeyValue
 */
export interface Expression_Literal_Map_KeyValue {
    /**
     * @generated from protobuf field: substrait.Expression.Literal key = 1;
     */
    key?: Expression_Literal;
    /**
     * @generated from protobuf field: substrait.Expression.Literal value = 2;
     */
    value?: Expression_Literal;
}
/**
 * @generated from protobuf message substrait.Expression.Literal.IntervalYearToMonth
 */
export interface Expression_Literal_IntervalYearToMonth {
    /**
     * @generated from protobuf field: int32 years = 1;
     */
    years: number;
    /**
     * @generated from protobuf field: int32 months = 2;
     */
    months: number;
}
/**
 * @generated from protobuf message substrait.Expression.Literal.IntervalDayToSecond
 */
export interface Expression_Literal_IntervalDayToSecond {
    /**
     * @generated from protobuf field: int32 days = 1;
     */
    days: number;
    /**
     * @generated from protobuf field: int32 seconds = 2;
     */
    seconds: number;
}
/**
 * @generated from protobuf message substrait.Expression.Literal.Struct
 */
export interface Expression_Literal_Struct {
    /**
     * A possibly heterogeneously typed list of literals
     *
     * @generated from protobuf field: repeated substrait.Expression.Literal fields = 1;
     */
    fields: Expression_Literal[];
}
/**
 * @generated from protobuf message substrait.Expression.Literal.List
 */
export interface Expression_Literal_List {
    /**
     * A homogeneously typed list of literals
     *
     * @generated from protobuf field: repeated substrait.Expression.Literal values = 1;
     */
    values: Expression_Literal[];
}
/**
 * @generated from protobuf message substrait.Expression.ScalarFunction
 */
export interface Expression_ScalarFunction {
    /**
     * points to a function_anchor defined in this plan
     *
     * @generated from protobuf field: uint32 function_reference = 1;
     */
    functionReference: number;
    /**
     * @generated from protobuf field: repeated substrait.Expression args = 2;
     */
    args: Expression[];
    /**
     * @generated from protobuf field: substrait.Type output_type = 3;
     */
    outputType?: Type;
}
/**
 * @generated from protobuf message substrait.Expression.WindowFunction
 */
export interface Expression_WindowFunction {
    /**
     * points to a function_anchor defined in this plan
     *
     * @generated from protobuf field: uint32 function_reference = 1;
     */
    functionReference: number;
    /**
     * @generated from protobuf field: repeated substrait.Expression partitions = 2;
     */
    partitions: Expression[];
    /**
     * @generated from protobuf field: repeated substrait.SortField sorts = 3;
     */
    sorts: SortField[];
    /**
     * @generated from protobuf field: substrait.Expression.WindowFunction.Bound upper_bound = 4;
     */
    upperBound?: Expression_WindowFunction_Bound;
    /**
     * @generated from protobuf field: substrait.Expression.WindowFunction.Bound lower_bound = 5;
     */
    lowerBound?: Expression_WindowFunction_Bound;
    /**
     * @generated from protobuf field: substrait.AggregationPhase phase = 6;
     */
    phase: AggregationPhase;
    /**
     * @generated from protobuf field: substrait.Type output_type = 7;
     */
    outputType?: Type;
    /**
     * @generated from protobuf field: repeated substrait.Expression args = 8;
     */
    args: Expression[];
}
/**
 * @generated from protobuf message substrait.Expression.WindowFunction.Bound
 */
export interface Expression_WindowFunction_Bound {
    /**
     * @generated from protobuf oneof: kind
     */
    kind: {
        oneofKind: "preceding";
        /**
         * @generated from protobuf field: substrait.Expression.WindowFunction.Bound.Preceding preceding = 1;
         */
        preceding: Expression_WindowFunction_Bound_Preceding;
    } | {
        oneofKind: "following";
        /**
         * @generated from protobuf field: substrait.Expression.WindowFunction.Bound.Following following = 2;
         */
        following: Expression_WindowFunction_Bound_Following;
    } | {
        oneofKind: "currentRow";
        /**
         * @generated from protobuf field: substrait.Expression.WindowFunction.Bound.CurrentRow current_row = 3;
         */
        currentRow: Expression_WindowFunction_Bound_CurrentRow;
    } | {
        oneofKind: "unbounded";
        /**
         * @generated from protobuf field: substrait.Expression.WindowFunction.Bound.Unbounded unbounded = 4;
         */
        unbounded: Expression_WindowFunction_Bound_Unbounded;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message substrait.Expression.WindowFunction.Bound.Preceding
 */
export interface Expression_WindowFunction_Bound_Preceding {
    /**
     * @generated from protobuf field: int64 offset = 1;
     */
    offset: bigint;
}
/**
 * @generated from protobuf message substrait.Expression.WindowFunction.Bound.Following
 */
export interface Expression_WindowFunction_Bound_Following {
    /**
     * @generated from protobuf field: int64 offset = 1;
     */
    offset: bigint;
}
/**
 * @generated from protobuf message substrait.Expression.WindowFunction.Bound.CurrentRow
 */
export interface Expression_WindowFunction_Bound_CurrentRow {
}
/**
 * @generated from protobuf message substrait.Expression.WindowFunction.Bound.Unbounded
 */
export interface Expression_WindowFunction_Bound_Unbounded {
}
/**
 * @generated from protobuf message substrait.Expression.IfThen
 */
export interface Expression_IfThen {
    /**
     * @generated from protobuf field: repeated substrait.Expression.IfThen.IfClause ifs = 1;
     */
    ifs: Expression_IfThen_IfClause[];
    /**
     * @generated from protobuf field: substrait.Expression else = 2;
     */
    else?: Expression;
}
/**
 * @generated from protobuf message substrait.Expression.IfThen.IfClause
 */
export interface Expression_IfThen_IfClause {
    /**
     * @generated from protobuf field: substrait.Expression if = 1;
     */
    if?: Expression;
    /**
     * @generated from protobuf field: substrait.Expression then = 2;
     */
    then?: Expression;
}
/**
 * @generated from protobuf message substrait.Expression.Cast
 */
export interface Expression_Cast {
    /**
     * @generated from protobuf field: substrait.Type type = 1;
     */
    type?: Type;
    /**
     * @generated from protobuf field: substrait.Expression input = 2;
     */
    input?: Expression;
}
/**
 * @generated from protobuf message substrait.Expression.SwitchExpression
 */
export interface Expression_SwitchExpression {
    /**
     * @generated from protobuf field: repeated substrait.Expression.SwitchExpression.IfValue ifs = 1;
     */
    ifs: Expression_SwitchExpression_IfValue[];
    /**
     * @generated from protobuf field: substrait.Expression else = 2;
     */
    else?: Expression;
}
/**
 * @generated from protobuf message substrait.Expression.SwitchExpression.IfValue
 */
export interface Expression_SwitchExpression_IfValue {
    /**
     * @generated from protobuf field: substrait.Expression.Literal if = 1;
     */
    if?: Expression_Literal;
    /**
     * @generated from protobuf field: substrait.Expression then = 2;
     */
    then?: Expression;
}
/**
 * @generated from protobuf message substrait.Expression.SingularOrList
 */
export interface Expression_SingularOrList {
    /**
     * @generated from protobuf field: substrait.Expression value = 1;
     */
    value?: Expression;
    /**
     * @generated from protobuf field: repeated substrait.Expression options = 2;
     */
    options: Expression[];
}
/**
 * @generated from protobuf message substrait.Expression.MultiOrList
 */
export interface Expression_MultiOrList {
    /**
     * @generated from protobuf field: repeated substrait.Expression value = 1;
     */
    value: Expression[];
    /**
     * @generated from protobuf field: repeated substrait.Expression.MultiOrList.Record options = 2;
     */
    options: Expression_MultiOrList_Record[];
}
/**
 * @generated from protobuf message substrait.Expression.MultiOrList.Record
 */
export interface Expression_MultiOrList_Record {
    /**
     * @generated from protobuf field: repeated substrait.Expression fields = 1;
     */
    fields: Expression[];
}
/**
 * @generated from protobuf message substrait.Expression.EmbeddedFunction
 */
export interface Expression_EmbeddedFunction {
    /**
     * @generated from protobuf field: repeated substrait.Expression arguments = 1;
     */
    arguments: Expression[];
    /**
     * @generated from protobuf field: substrait.Type output_type = 2;
     */
    outputType?: Type;
    /**
     * @generated from protobuf oneof: kind
     */
    kind: {
        oneofKind: "pythonPickleFunction";
        /**
         * @generated from protobuf field: substrait.Expression.EmbeddedFunction.PythonPickleFunction python_pickle_function = 3;
         */
        pythonPickleFunction: Expression_EmbeddedFunction_PythonPickleFunction;
    } | {
        oneofKind: "webAssemblyFunction";
        /**
         * @generated from protobuf field: substrait.Expression.EmbeddedFunction.WebAssemblyFunction web_assembly_function = 4;
         */
        webAssemblyFunction: Expression_EmbeddedFunction_WebAssemblyFunction;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message substrait.Expression.EmbeddedFunction.PythonPickleFunction
 */
export interface Expression_EmbeddedFunction_PythonPickleFunction {
    /**
     * @generated from protobuf field: bytes function = 1;
     */
    function: Uint8Array;
    /**
     * @generated from protobuf field: repeated string prerequisite = 2;
     */
    prerequisite: string[];
}
/**
 * @generated from protobuf message substrait.Expression.EmbeddedFunction.WebAssemblyFunction
 */
export interface Expression_EmbeddedFunction_WebAssemblyFunction {
    /**
     * @generated from protobuf field: bytes script = 1;
     */
    script: Uint8Array;
    /**
     * @generated from protobuf field: repeated string prerequisite = 2;
     */
    prerequisite: string[];
}
/**
 * A way to reference the inner property of a complex record. Can reference
 * either a map key by literal, a struct field by the ordinal position of
 * the desired field or a particular element in an array. Supports
 * expressions that would roughly translate to something similar to:
 * a.b[2].c['my_map_key'].x where a,b,c and x are struct field references
 * (ordinalized in the internal representation here), [2] is a list offset
 * and ['my_map_key'] is a reference into a map field.
 *
 * @generated from protobuf message substrait.Expression.ReferenceSegment
 */
export interface Expression_ReferenceSegment {
    /**
     * @generated from protobuf oneof: reference_type
     */
    referenceType: {
        oneofKind: "mapKey";
        /**
         * @generated from protobuf field: substrait.Expression.ReferenceSegment.MapKey map_key = 1;
         */
        mapKey: Expression_ReferenceSegment_MapKey;
    } | {
        oneofKind: "structField";
        /**
         * @generated from protobuf field: substrait.Expression.ReferenceSegment.StructField struct_field = 2;
         */
        structField: Expression_ReferenceSegment_StructField;
    } | {
        oneofKind: "listElement";
        /**
         * @generated from protobuf field: substrait.Expression.ReferenceSegment.ListElement list_element = 3;
         */
        listElement: Expression_ReferenceSegment_ListElement;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message substrait.Expression.ReferenceSegment.MapKey
 */
export interface Expression_ReferenceSegment_MapKey {
    /**
     * literal based reference to specific possible value in map.
     *
     * @generated from protobuf field: substrait.Expression.Literal map_key = 1;
     */
    mapKey?: Expression_Literal;
    /**
     * Optional child segment
     *
     * @generated from protobuf field: substrait.Expression.ReferenceSegment child = 2;
     */
    child?: Expression_ReferenceSegment;
}
/**
 * @generated from protobuf message substrait.Expression.ReferenceSegment.StructField
 */
export interface Expression_ReferenceSegment_StructField {
    /**
     * zero-indexed ordinal position of field in struct
     *
     * @generated from protobuf field: int32 field = 1;
     */
    field: number;
    /**
     * Optional child segment
     *
     * @generated from protobuf field: substrait.Expression.ReferenceSegment child = 2;
     */
    child?: Expression_ReferenceSegment;
}
/**
 * @generated from protobuf message substrait.Expression.ReferenceSegment.ListElement
 */
export interface Expression_ReferenceSegment_ListElement {
    /**
     * zero-indexed ordinal position of element in list
     *
     * @generated from protobuf field: int32 offset = 1;
     */
    offset: number;
    /**
     * Optional child segment
     *
     * @generated from protobuf field: substrait.Expression.ReferenceSegment child = 2;
     */
    child?: Expression_ReferenceSegment;
}
/**
 * A reference that takes an existing subtype and selectively removes fields
 * from it. For example, one might initially have an inner struct with 100
 * fields but a a particular operation only needs to interact with only 2 of
 * those 100 fields. In this situation, one would use a mask expression to
 * eliminate the 98 fields that are not relevant to the rest of the operation
 * pipeline.
 *
 * Note that this does not fundamentally alter the structure of data beyond
 * the elimination of unecessary elements.
 *
 * @generated from protobuf message substrait.Expression.MaskExpression
 */
export interface Expression_MaskExpression {
    /**
     * @generated from protobuf field: substrait.Expression.MaskExpression.StructSelect select = 1;
     */
    select?: Expression_MaskExpression_StructSelect;
    /**
     * @generated from protobuf field: bool maintain_singular_struct = 2;
     */
    maintainSingularStruct: boolean;
}
/**
 * @generated from protobuf message substrait.Expression.MaskExpression.Select
 */
export interface Expression_MaskExpression_Select {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "struct";
        /**
         * @generated from protobuf field: substrait.Expression.MaskExpression.StructSelect struct = 1;
         */
        struct: Expression_MaskExpression_StructSelect;
    } | {
        oneofKind: "list";
        /**
         * @generated from protobuf field: substrait.Expression.MaskExpression.ListSelect list = 2;
         */
        list: Expression_MaskExpression_ListSelect;
    } | {
        oneofKind: "map";
        /**
         * @generated from protobuf field: substrait.Expression.MaskExpression.MapSelect map = 3;
         */
        map: Expression_MaskExpression_MapSelect;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message substrait.Expression.MaskExpression.StructSelect
 */
export interface Expression_MaskExpression_StructSelect {
    /**
     * @generated from protobuf field: repeated substrait.Expression.MaskExpression.StructItem struct_items = 1;
     */
    structItems: Expression_MaskExpression_StructItem[];
}
/**
 * @generated from protobuf message substrait.Expression.MaskExpression.StructItem
 */
export interface Expression_MaskExpression_StructItem {
    /**
     * @generated from protobuf field: int32 field = 1;
     */
    field: number;
    /**
     * @generated from protobuf field: substrait.Expression.MaskExpression.Select child = 2;
     */
    child?: Expression_MaskExpression_Select;
}
/**
 * @generated from protobuf message substrait.Expression.MaskExpression.ListSelect
 */
export interface Expression_MaskExpression_ListSelect {
    /**
     * @generated from protobuf field: repeated substrait.Expression.MaskExpression.ListSelect.ListSelectItem selection = 1;
     */
    selection: Expression_MaskExpression_ListSelect_ListSelectItem[];
    /**
     * @generated from protobuf field: substrait.Expression.MaskExpression.Select child = 2;
     */
    child?: Expression_MaskExpression_Select;
}
/**
 * @generated from protobuf message substrait.Expression.MaskExpression.ListSelect.ListSelectItem
 */
export interface Expression_MaskExpression_ListSelect_ListSelectItem {
    /**
     * @generated from protobuf oneof: type
     */
    type: {
        oneofKind: "item";
        /**
         * @generated from protobuf field: substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement item = 1;
         */
        item: Expression_MaskExpression_ListSelect_ListSelectItem_ListElement;
    } | {
        oneofKind: "slice";
        /**
         * @generated from protobuf field: substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice slice = 2;
         */
        slice: Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement
 */
export interface Expression_MaskExpression_ListSelect_ListSelectItem_ListElement {
    /**
     * @generated from protobuf field: int32 field = 1;
     */
    field: number;
}
/**
 * @generated from protobuf message substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice
 */
export interface Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice {
    /**
     * @generated from protobuf field: int32 start = 1;
     */
    start: number;
    /**
     * @generated from protobuf field: int32 end = 2;
     */
    end: number;
}
/**
 * @generated from protobuf message substrait.Expression.MaskExpression.MapSelect
 */
export interface Expression_MaskExpression_MapSelect {
    /**
     * @generated from protobuf oneof: select
     */
    select: {
        oneofKind: "key";
        /**
         * @generated from protobuf field: substrait.Expression.MaskExpression.MapSelect.MapKey key = 1;
         */
        key: Expression_MaskExpression_MapSelect_MapKey;
    } | {
        oneofKind: "expression";
        /**
         * @generated from protobuf field: substrait.Expression.MaskExpression.MapSelect.MapKeyExpression expression = 2;
         */
        expression: Expression_MaskExpression_MapSelect_MapKeyExpression;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: substrait.Expression.MaskExpression.Select child = 3;
     */
    child?: Expression_MaskExpression_Select;
}
/**
 * @generated from protobuf message substrait.Expression.MaskExpression.MapSelect.MapKey
 */
export interface Expression_MaskExpression_MapSelect_MapKey {
    /**
     * @generated from protobuf field: string map_key = 1;
     */
    mapKey: string;
}
/**
 * @generated from protobuf message substrait.Expression.MaskExpression.MapSelect.MapKeyExpression
 */
export interface Expression_MaskExpression_MapSelect_MapKeyExpression {
    /**
     * @generated from protobuf field: string map_key_expression = 1;
     */
    mapKeyExpression: string;
}
/**
 * A reference to an inner part of a complex object. Can reference reference a
 * single element or a masked version of elements
 *
 * @generated from protobuf message substrait.Expression.FieldReference
 */
export interface Expression_FieldReference {
    /**
     * @generated from protobuf oneof: reference_type
     */
    referenceType: {
        oneofKind: "directReference";
        /**
         * @generated from protobuf field: substrait.Expression.ReferenceSegment direct_reference = 1;
         */
        directReference: Expression_ReferenceSegment;
    } | {
        oneofKind: "maskedReference";
        /**
         * @generated from protobuf field: substrait.Expression.MaskExpression masked_reference = 2;
         */
        maskedReference: Expression_MaskExpression;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf oneof: root_type
     */
    rootType: {
        oneofKind: "expression";
        /**
         * @generated from protobuf field: substrait.Expression expression = 3;
         */
        expression: Expression;
    } | {
        oneofKind: "rootReference";
        /**
         * @generated from protobuf field: substrait.Expression.FieldReference.RootReference root_reference = 4;
         */
        rootReference: Expression_FieldReference_RootReference;
    } | {
        oneofKind: "outerReference";
        /**
         * @generated from protobuf field: substrait.Expression.FieldReference.OuterReference outer_reference = 5;
         */
        outerReference: Expression_FieldReference_OuterReference;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Singleton that expresses this FieldReference is rooted off the root
 * incoming record type
 *
 * @generated from protobuf message substrait.Expression.FieldReference.RootReference
 */
export interface Expression_FieldReference_RootReference {
}
/**
 * A root reference for the outer relation's subquery
 *
 * @generated from protobuf message substrait.Expression.FieldReference.OuterReference
 */
export interface Expression_FieldReference_OuterReference {
    /**
     * number of subquery boundaries to traverse up for this field's reference
     *
     * This value must be >= 1
     *
     * @generated from protobuf field: uint32 steps_out = 1;
     */
    stepsOut: number;
}
/**
 * Subquery relation expression
 *
 * @generated from protobuf message substrait.Expression.Subquery
 */
export interface Expression_Subquery {
    /**
     * @generated from protobuf oneof: subquery_type
     */
    subqueryType: {
        oneofKind: "scalar";
        /**
         * Scalar subquery
         *
         * @generated from protobuf field: substrait.Expression.Subquery.Scalar scalar = 1;
         */
        scalar: Expression_Subquery_Scalar;
    } | {
        oneofKind: "inPredicate";
        /**
         * x IN y predicate
         *
         * @generated from protobuf field: substrait.Expression.Subquery.InPredicate in_predicate = 2;
         */
        inPredicate: Expression_Subquery_InPredicate;
    } | {
        oneofKind: "setPredicate";
        /**
         * EXISTS/UNIQUE predicate
         *
         * @generated from protobuf field: substrait.Expression.Subquery.SetPredicate set_predicate = 3;
         */
        setPredicate: Expression_Subquery_SetPredicate;
    } | {
        oneofKind: "setComparison";
        /**
         * ANY/ALL predicate
         *
         * @generated from protobuf field: substrait.Expression.Subquery.SetComparison set_comparison = 4;
         */
        setComparison: Expression_Subquery_SetComparison;
    } | {
        oneofKind: undefined;
    };
}
/**
 * A subquery with one row and one column. This is often an aggregate
 * though not required to be.
 *
 * @generated from protobuf message substrait.Expression.Subquery.Scalar
 */
export interface Expression_Subquery_Scalar {
    /**
     * @generated from protobuf field: substrait.Rel input = 1;
     */
    input?: Rel;
}
/**
 * Predicate checking that the left expression is contained in the right
 * subquery
 *
 * Examples:
 *
 * x IN (SELECT * FROM t)
 * (x, y) IN (SELECT a, b FROM t)
 *
 * @generated from protobuf message substrait.Expression.Subquery.InPredicate
 */
export interface Expression_Subquery_InPredicate {
    /**
     * @generated from protobuf field: repeated substrait.Expression needles = 1;
     */
    needles: Expression[];
    /**
     * @generated from protobuf field: substrait.Rel haystack = 2;
     */
    haystack?: Rel;
}
/**
 * A predicate over a set of rows in the form of a subquery
 * EXISTS and UNIQUE are common SQL forms of this operation.
 *
 * @generated from protobuf message substrait.Expression.Subquery.SetPredicate
 */
export interface Expression_Subquery_SetPredicate {
    /**
     * TODO: should allow expressions
     *
     * @generated from protobuf field: substrait.Expression.Subquery.SetPredicate.PredicateOp predicate_op = 1;
     */
    predicateOp: Expression_Subquery_SetPredicate_PredicateOp;
    /**
     * @generated from protobuf field: substrait.Rel tuples = 2;
     */
    tuples?: Rel;
}
/**
 * @generated from protobuf enum substrait.Expression.Subquery.SetPredicate.PredicateOp
 */
export enum Expression_Subquery_SetPredicate_PredicateOp {
    /**
     * @generated from protobuf enum value: PREDICATE_OP_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: PREDICATE_OP_EXISTS = 1;
     */
    EXISTS = 1,
    /**
     * @generated from protobuf enum value: PREDICATE_OP_UNIQUE = 2;
     */
    UNIQUE = 2
}
/**
 * A subquery comparison using ANY or ALL.
 * Examples:
 *
 * SELECT *
 * FROM t1
 * WHERE x < ANY(SELECT y from t2)
 *
 * @generated from protobuf message substrait.Expression.Subquery.SetComparison
 */
export interface Expression_Subquery_SetComparison {
    /**
     * ANY or ALL
     *
     * @generated from protobuf field: substrait.Expression.Subquery.SetComparison.ReductionOp reduction_op = 1;
     */
    reductionOp: Expression_Subquery_SetComparison_ReductionOp;
    /**
     * A comparison operator
     *
     * @generated from protobuf field: substrait.Expression.Subquery.SetComparison.ComparisonOp comparison_op = 2;
     */
    comparisonOp: Expression_Subquery_SetComparison_ComparisonOp;
    /**
     * left side of the expression
     *
     * @generated from protobuf field: substrait.Expression left = 3;
     */
    left?: Expression;
    /**
     * right side of the expression
     *
     * @generated from protobuf field: substrait.Rel right = 4;
     */
    right?: Rel;
}
/**
 * @generated from protobuf enum substrait.Expression.Subquery.SetComparison.ComparisonOp
 */
export enum Expression_Subquery_SetComparison_ComparisonOp {
    /**
     * @generated from protobuf enum value: COMPARISON_OP_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: COMPARISON_OP_EQ = 1;
     */
    EQ = 1,
    /**
     * @generated from protobuf enum value: COMPARISON_OP_NE = 2;
     */
    NE = 2,
    /**
     * @generated from protobuf enum value: COMPARISON_OP_LT = 3;
     */
    LT = 3,
    /**
     * @generated from protobuf enum value: COMPARISON_OP_GT = 4;
     */
    GT = 4,
    /**
     * @generated from protobuf enum value: COMPARISON_OP_LE = 5;
     */
    LE = 5,
    /**
     * @generated from protobuf enum value: COMPARISON_OP_GE = 6;
     */
    GE = 6
}
/**
 * @generated from protobuf enum substrait.Expression.Subquery.SetComparison.ReductionOp
 */
export enum Expression_Subquery_SetComparison_ReductionOp {
    /**
     * @generated from protobuf enum value: REDUCTION_OP_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: REDUCTION_OP_ANY = 1;
     */
    ANY = 1,
    /**
     * @generated from protobuf enum value: REDUCTION_OP_ALL = 2;
     */
    ALL = 2
}
/**
 * @generated from protobuf message substrait.SortField
 */
export interface SortField {
    /**
     * @generated from protobuf field: substrait.Expression expr = 1;
     */
    expr?: Expression;
    /**
     * @generated from protobuf oneof: sort_kind
     */
    sortKind: {
        oneofKind: "direction";
        /**
         * @generated from protobuf field: substrait.SortField.SortDirection direction = 2;
         */
        direction: SortField_SortDirection;
    } | {
        oneofKind: "comparisonFunctionReference";
        /**
         * @generated from protobuf field: uint32 comparison_function_reference = 3;
         */
        comparisonFunctionReference: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum substrait.SortField.SortDirection
 */
export enum SortField_SortDirection {
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_ASC_NULLS_FIRST = 1;
     */
    ASC_NULLS_FIRST = 1,
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_ASC_NULLS_LAST = 2;
     */
    ASC_NULLS_LAST = 2,
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_DESC_NULLS_FIRST = 3;
     */
    DESC_NULLS_FIRST = 3,
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_DESC_NULLS_LAST = 4;
     */
    DESC_NULLS_LAST = 4,
    /**
     * @generated from protobuf enum value: SORT_DIRECTION_CLUSTERED = 5;
     */
    CLUSTERED = 5
}
/**
 * @generated from protobuf message substrait.AggregateFunction
 */
export interface AggregateFunction {
    /**
     * points to a function_anchor defined in this plan
     *
     * @generated from protobuf field: uint32 function_reference = 1;
     */
    functionReference: number;
    /**
     * @generated from protobuf field: repeated substrait.Expression args = 2;
     */
    args: Expression[];
    /**
     * @generated from protobuf field: repeated substrait.SortField sorts = 3;
     */
    sorts: SortField[];
    /**
     * @generated from protobuf field: substrait.AggregationPhase phase = 4;
     */
    phase: AggregationPhase;
    /**
     * @generated from protobuf field: substrait.Type output_type = 5;
     */
    outputType?: Type;
}
/**
 * @generated from protobuf enum substrait.AggregationPhase
 */
export enum AggregationPhase {
    /**
     * @generated from protobuf enum value: AGGREGATION_PHASE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: AGGREGATION_PHASE_INITIAL_TO_INTERMEDIATE = 1;
     */
    INITIAL_TO_INTERMEDIATE = 1,
    /**
     * @generated from protobuf enum value: AGGREGATION_PHASE_INTERMEDIATE_TO_INTERMEDIATE = 2;
     */
    INTERMEDIATE_TO_INTERMEDIATE = 2,
    /**
     * @generated from protobuf enum value: AGGREGATION_PHASE_INITIAL_TO_RESULT = 3;
     */
    INITIAL_TO_RESULT = 3,
    /**
     * @generated from protobuf enum value: AGGREGATION_PHASE_INTERMEDIATE_TO_RESULT = 4;
     */
    INTERMEDIATE_TO_RESULT = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class RelCommon$Type extends MessageType<RelCommon> {
    constructor() {
        super("substrait.RelCommon", [
            { no: 1, name: "direct", kind: "message", oneof: "emitKind", T: () => RelCommon_Direct },
            { no: 2, name: "emit", kind: "message", oneof: "emitKind", T: () => RelCommon_Emit },
            { no: 3, name: "hint", kind: "message", T: () => RelCommon_Hint },
            { no: 4, name: "advanced_extension", kind: "message", T: () => AdvancedExtension }
        ]);
    }
    create(value?: PartialMessage<RelCommon>): RelCommon {
        const message = { emitKind: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelCommon>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelCommon): RelCommon {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.RelCommon.Direct direct */ 1:
                    message.emitKind = {
                        oneofKind: "direct",
                        direct: RelCommon_Direct.internalBinaryRead(reader, reader.uint32(), options, (message.emitKind as any).direct)
                    };
                    break;
                case /* substrait.RelCommon.Emit emit */ 2:
                    message.emitKind = {
                        oneofKind: "emit",
                        emit: RelCommon_Emit.internalBinaryRead(reader, reader.uint32(), options, (message.emitKind as any).emit)
                    };
                    break;
                case /* substrait.RelCommon.Hint hint */ 3:
                    message.hint = RelCommon_Hint.internalBinaryRead(reader, reader.uint32(), options, message.hint);
                    break;
                case /* substrait.extensions.AdvancedExtension advanced_extension */ 4:
                    message.advancedExtension = AdvancedExtension.internalBinaryRead(reader, reader.uint32(), options, message.advancedExtension);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelCommon, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.RelCommon.Direct direct = 1; */
        if (message.emitKind.oneofKind === "direct")
            RelCommon_Direct.internalBinaryWrite(message.emitKind.direct, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.RelCommon.Emit emit = 2; */
        if (message.emitKind.oneofKind === "emit")
            RelCommon_Emit.internalBinaryWrite(message.emitKind.emit, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.RelCommon.Hint hint = 3; */
        if (message.hint)
            RelCommon_Hint.internalBinaryWrite(message.hint, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.extensions.AdvancedExtension advanced_extension = 4; */
        if (message.advancedExtension)
            AdvancedExtension.internalBinaryWrite(message.advancedExtension, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.RelCommon
 */
export const RelCommon = new RelCommon$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelCommon_Direct$Type extends MessageType<RelCommon_Direct> {
    constructor() {
        super("substrait.RelCommon.Direct", []);
    }
    create(value?: PartialMessage<RelCommon_Direct>): RelCommon_Direct {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelCommon_Direct>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelCommon_Direct): RelCommon_Direct {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RelCommon_Direct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.RelCommon.Direct
 */
export const RelCommon_Direct = new RelCommon_Direct$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelCommon_Emit$Type extends MessageType<RelCommon_Emit> {
    constructor() {
        super("substrait.RelCommon.Emit", [
            { no: 1, name: "output_mapping", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RelCommon_Emit>): RelCommon_Emit {
        const message = { outputMapping: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelCommon_Emit>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelCommon_Emit): RelCommon_Emit {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 output_mapping */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.outputMapping.push(reader.int32());
                    else
                        message.outputMapping.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelCommon_Emit, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 output_mapping = 1; */
        if (message.outputMapping.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.outputMapping.length; i++)
                writer.int32(message.outputMapping[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.RelCommon.Emit
 */
export const RelCommon_Emit = new RelCommon_Emit$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelCommon_Hint$Type extends MessageType<RelCommon_Hint> {
    constructor() {
        super("substrait.RelCommon.Hint", [
            { no: 1, name: "stats", kind: "message", T: () => RelCommon_Hint_Stats },
            { no: 2, name: "constraint", kind: "message", T: () => RelCommon_Hint_RuntimeConstraint },
            { no: 10, name: "advanced_extension", kind: "message", T: () => AdvancedExtension }
        ]);
    }
    create(value?: PartialMessage<RelCommon_Hint>): RelCommon_Hint {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelCommon_Hint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelCommon_Hint): RelCommon_Hint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.RelCommon.Hint.Stats stats */ 1:
                    message.stats = RelCommon_Hint_Stats.internalBinaryRead(reader, reader.uint32(), options, message.stats);
                    break;
                case /* substrait.RelCommon.Hint.RuntimeConstraint constraint */ 2:
                    message.constraint = RelCommon_Hint_RuntimeConstraint.internalBinaryRead(reader, reader.uint32(), options, message.constraint);
                    break;
                case /* substrait.extensions.AdvancedExtension advanced_extension */ 10:
                    message.advancedExtension = AdvancedExtension.internalBinaryRead(reader, reader.uint32(), options, message.advancedExtension);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelCommon_Hint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.RelCommon.Hint.Stats stats = 1; */
        if (message.stats)
            RelCommon_Hint_Stats.internalBinaryWrite(message.stats, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.RelCommon.Hint.RuntimeConstraint constraint = 2; */
        if (message.constraint)
            RelCommon_Hint_RuntimeConstraint.internalBinaryWrite(message.constraint, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.extensions.AdvancedExtension advanced_extension = 10; */
        if (message.advancedExtension)
            AdvancedExtension.internalBinaryWrite(message.advancedExtension, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.RelCommon.Hint
 */
export const RelCommon_Hint = new RelCommon_Hint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelCommon_Hint_Stats$Type extends MessageType<RelCommon_Hint_Stats> {
    constructor() {
        super("substrait.RelCommon.Hint.Stats", [
            { no: 1, name: "row_count", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "record_size", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "advanced_extension", kind: "message", T: () => AdvancedExtension }
        ]);
    }
    create(value?: PartialMessage<RelCommon_Hint_Stats>): RelCommon_Hint_Stats {
        const message = { rowCount: 0, recordSize: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelCommon_Hint_Stats>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelCommon_Hint_Stats): RelCommon_Hint_Stats {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double row_count */ 1:
                    message.rowCount = reader.double();
                    break;
                case /* double record_size */ 2:
                    message.recordSize = reader.double();
                    break;
                case /* substrait.extensions.AdvancedExtension advanced_extension */ 10:
                    message.advancedExtension = AdvancedExtension.internalBinaryRead(reader, reader.uint32(), options, message.advancedExtension);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelCommon_Hint_Stats, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double row_count = 1; */
        if (message.rowCount !== 0)
            writer.tag(1, WireType.Bit64).double(message.rowCount);
        /* double record_size = 2; */
        if (message.recordSize !== 0)
            writer.tag(2, WireType.Bit64).double(message.recordSize);
        /* substrait.extensions.AdvancedExtension advanced_extension = 10; */
        if (message.advancedExtension)
            AdvancedExtension.internalBinaryWrite(message.advancedExtension, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.RelCommon.Hint.Stats
 */
export const RelCommon_Hint_Stats = new RelCommon_Hint_Stats$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelCommon_Hint_RuntimeConstraint$Type extends MessageType<RelCommon_Hint_RuntimeConstraint> {
    constructor() {
        super("substrait.RelCommon.Hint.RuntimeConstraint", [
            { no: 10, name: "advanced_extension", kind: "message", T: () => AdvancedExtension }
        ]);
    }
    create(value?: PartialMessage<RelCommon_Hint_RuntimeConstraint>): RelCommon_Hint_RuntimeConstraint {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelCommon_Hint_RuntimeConstraint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelCommon_Hint_RuntimeConstraint): RelCommon_Hint_RuntimeConstraint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.extensions.AdvancedExtension advanced_extension */ 10:
                    message.advancedExtension = AdvancedExtension.internalBinaryRead(reader, reader.uint32(), options, message.advancedExtension);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelCommon_Hint_RuntimeConstraint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.extensions.AdvancedExtension advanced_extension = 10; */
        if (message.advancedExtension)
            AdvancedExtension.internalBinaryWrite(message.advancedExtension, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.RelCommon.Hint.RuntimeConstraint
 */
export const RelCommon_Hint_RuntimeConstraint = new RelCommon_Hint_RuntimeConstraint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadRel$Type extends MessageType<ReadRel> {
    constructor() {
        super("substrait.ReadRel", [
            { no: 1, name: "common", kind: "message", T: () => RelCommon },
            { no: 2, name: "base_schema", kind: "message", T: () => NamedStruct },
            { no: 3, name: "filter", kind: "message", T: () => Expression },
            { no: 4, name: "projection", kind: "message", T: () => Expression_MaskExpression },
            { no: 10, name: "advanced_extension", kind: "message", T: () => AdvancedExtension },
            { no: 5, name: "virtual_table", kind: "message", oneof: "readType", T: () => ReadRel_VirtualTable },
            { no: 6, name: "local_files", kind: "message", oneof: "readType", T: () => ReadRel_LocalFiles },
            { no: 7, name: "named_table", kind: "message", oneof: "readType", T: () => ReadRel_NamedTable },
            { no: 8, name: "extension_table", kind: "message", oneof: "readType", T: () => ReadRel_ExtensionTable }
        ]);
    }
    create(value?: PartialMessage<ReadRel>): ReadRel {
        const message = { readType: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadRel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadRel): ReadRel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.RelCommon common */ 1:
                    message.common = RelCommon.internalBinaryRead(reader, reader.uint32(), options, message.common);
                    break;
                case /* substrait.NamedStruct base_schema */ 2:
                    message.baseSchema = NamedStruct.internalBinaryRead(reader, reader.uint32(), options, message.baseSchema);
                    break;
                case /* substrait.Expression filter */ 3:
                    message.filter = Expression.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                case /* substrait.Expression.MaskExpression projection */ 4:
                    message.projection = Expression_MaskExpression.internalBinaryRead(reader, reader.uint32(), options, message.projection);
                    break;
                case /* substrait.extensions.AdvancedExtension advanced_extension */ 10:
                    message.advancedExtension = AdvancedExtension.internalBinaryRead(reader, reader.uint32(), options, message.advancedExtension);
                    break;
                case /* substrait.ReadRel.VirtualTable virtual_table */ 5:
                    message.readType = {
                        oneofKind: "virtualTable",
                        virtualTable: ReadRel_VirtualTable.internalBinaryRead(reader, reader.uint32(), options, (message.readType as any).virtualTable)
                    };
                    break;
                case /* substrait.ReadRel.LocalFiles local_files */ 6:
                    message.readType = {
                        oneofKind: "localFiles",
                        localFiles: ReadRel_LocalFiles.internalBinaryRead(reader, reader.uint32(), options, (message.readType as any).localFiles)
                    };
                    break;
                case /* substrait.ReadRel.NamedTable named_table */ 7:
                    message.readType = {
                        oneofKind: "namedTable",
                        namedTable: ReadRel_NamedTable.internalBinaryRead(reader, reader.uint32(), options, (message.readType as any).namedTable)
                    };
                    break;
                case /* substrait.ReadRel.ExtensionTable extension_table */ 8:
                    message.readType = {
                        oneofKind: "extensionTable",
                        extensionTable: ReadRel_ExtensionTable.internalBinaryRead(reader, reader.uint32(), options, (message.readType as any).extensionTable)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadRel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.RelCommon common = 1; */
        if (message.common)
            RelCommon.internalBinaryWrite(message.common, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.NamedStruct base_schema = 2; */
        if (message.baseSchema)
            NamedStruct.internalBinaryWrite(message.baseSchema, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression filter = 3; */
        if (message.filter)
            Expression.internalBinaryWrite(message.filter, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.MaskExpression projection = 4; */
        if (message.projection)
            Expression_MaskExpression.internalBinaryWrite(message.projection, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* substrait.extensions.AdvancedExtension advanced_extension = 10; */
        if (message.advancedExtension)
            AdvancedExtension.internalBinaryWrite(message.advancedExtension, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* substrait.ReadRel.VirtualTable virtual_table = 5; */
        if (message.readType.oneofKind === "virtualTable")
            ReadRel_VirtualTable.internalBinaryWrite(message.readType.virtualTable, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* substrait.ReadRel.LocalFiles local_files = 6; */
        if (message.readType.oneofKind === "localFiles")
            ReadRel_LocalFiles.internalBinaryWrite(message.readType.localFiles, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* substrait.ReadRel.NamedTable named_table = 7; */
        if (message.readType.oneofKind === "namedTable")
            ReadRel_NamedTable.internalBinaryWrite(message.readType.namedTable, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* substrait.ReadRel.ExtensionTable extension_table = 8; */
        if (message.readType.oneofKind === "extensionTable")
            ReadRel_ExtensionTable.internalBinaryWrite(message.readType.extensionTable, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.ReadRel
 */
export const ReadRel = new ReadRel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadRel_NamedTable$Type extends MessageType<ReadRel_NamedTable> {
    constructor() {
        super("substrait.ReadRel.NamedTable", [
            { no: 1, name: "names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "advanced_extension", kind: "message", T: () => AdvancedExtension }
        ]);
    }
    create(value?: PartialMessage<ReadRel_NamedTable>): ReadRel_NamedTable {
        const message = { names: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadRel_NamedTable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadRel_NamedTable): ReadRel_NamedTable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string names */ 1:
                    message.names.push(reader.string());
                    break;
                case /* substrait.extensions.AdvancedExtension advanced_extension */ 10:
                    message.advancedExtension = AdvancedExtension.internalBinaryRead(reader, reader.uint32(), options, message.advancedExtension);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadRel_NamedTable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string names = 1; */
        for (let i = 0; i < message.names.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.names[i]);
        /* substrait.extensions.AdvancedExtension advanced_extension = 10; */
        if (message.advancedExtension)
            AdvancedExtension.internalBinaryWrite(message.advancedExtension, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.ReadRel.NamedTable
 */
export const ReadRel_NamedTable = new ReadRel_NamedTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadRel_VirtualTable$Type extends MessageType<ReadRel_VirtualTable> {
    constructor() {
        super("substrait.ReadRel.VirtualTable", [
            { no: 1, name: "values", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression_Literal_Struct }
        ]);
    }
    create(value?: PartialMessage<ReadRel_VirtualTable>): ReadRel_VirtualTable {
        const message = { values: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadRel_VirtualTable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadRel_VirtualTable): ReadRel_VirtualTable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.Expression.Literal.Struct values */ 1:
                    message.values.push(Expression_Literal_Struct.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadRel_VirtualTable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.Expression.Literal.Struct values = 1; */
        for (let i = 0; i < message.values.length; i++)
            Expression_Literal_Struct.internalBinaryWrite(message.values[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.ReadRel.VirtualTable
 */
export const ReadRel_VirtualTable = new ReadRel_VirtualTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadRel_ExtensionTable$Type extends MessageType<ReadRel_ExtensionTable> {
    constructor() {
        super("substrait.ReadRel.ExtensionTable", [
            { no: 1, name: "detail", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<ReadRel_ExtensionTable>): ReadRel_ExtensionTable {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadRel_ExtensionTable>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadRel_ExtensionTable): ReadRel_ExtensionTable {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Any detail */ 1:
                    message.detail = Any.internalBinaryRead(reader, reader.uint32(), options, message.detail);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadRel_ExtensionTable, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Any detail = 1; */
        if (message.detail)
            Any.internalBinaryWrite(message.detail, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.ReadRel.ExtensionTable
 */
export const ReadRel_ExtensionTable = new ReadRel_ExtensionTable$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadRel_LocalFiles$Type extends MessageType<ReadRel_LocalFiles> {
    constructor() {
        super("substrait.ReadRel.LocalFiles", [
            { no: 1, name: "items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ReadRel_LocalFiles_FileOrFiles },
            { no: 10, name: "advanced_extension", kind: "message", T: () => AdvancedExtension }
        ]);
    }
    create(value?: PartialMessage<ReadRel_LocalFiles>): ReadRel_LocalFiles {
        const message = { items: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadRel_LocalFiles>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadRel_LocalFiles): ReadRel_LocalFiles {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.ReadRel.LocalFiles.FileOrFiles items */ 1:
                    message.items.push(ReadRel_LocalFiles_FileOrFiles.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* substrait.extensions.AdvancedExtension advanced_extension */ 10:
                    message.advancedExtension = AdvancedExtension.internalBinaryRead(reader, reader.uint32(), options, message.advancedExtension);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadRel_LocalFiles, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.ReadRel.LocalFiles.FileOrFiles items = 1; */
        for (let i = 0; i < message.items.length; i++)
            ReadRel_LocalFiles_FileOrFiles.internalBinaryWrite(message.items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.extensions.AdvancedExtension advanced_extension = 10; */
        if (message.advancedExtension)
            AdvancedExtension.internalBinaryWrite(message.advancedExtension, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.ReadRel.LocalFiles
 */
export const ReadRel_LocalFiles = new ReadRel_LocalFiles$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadRel_LocalFiles_FileOrFiles$Type extends MessageType<ReadRel_LocalFiles_FileOrFiles> {
    constructor() {
        super("substrait.ReadRel.LocalFiles.FileOrFiles", [
            { no: 1, name: "uri_path", kind: "scalar", oneof: "pathType", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "uri_path_glob", kind: "scalar", oneof: "pathType", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "uri_file", kind: "scalar", oneof: "pathType", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "uri_folder", kind: "scalar", oneof: "pathType", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "format", kind: "enum", T: () => ["substrait.ReadRel.LocalFiles.FileOrFiles.FileFormat", ReadRel_LocalFiles_FileOrFiles_FileFormat, "FILE_FORMAT_"] },
            { no: 6, name: "partition_index", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "start", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "length", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ReadRel_LocalFiles_FileOrFiles>): ReadRel_LocalFiles_FileOrFiles {
        const message = { pathType: { oneofKind: undefined }, format: 0, partitionIndex: 0n, start: 0n, length: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadRel_LocalFiles_FileOrFiles>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadRel_LocalFiles_FileOrFiles): ReadRel_LocalFiles_FileOrFiles {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uri_path */ 1:
                    message.pathType = {
                        oneofKind: "uriPath",
                        uriPath: reader.string()
                    };
                    break;
                case /* string uri_path_glob */ 2:
                    message.pathType = {
                        oneofKind: "uriPathGlob",
                        uriPathGlob: reader.string()
                    };
                    break;
                case /* string uri_file */ 3:
                    message.pathType = {
                        oneofKind: "uriFile",
                        uriFile: reader.string()
                    };
                    break;
                case /* string uri_folder */ 4:
                    message.pathType = {
                        oneofKind: "uriFolder",
                        uriFolder: reader.string()
                    };
                    break;
                case /* substrait.ReadRel.LocalFiles.FileOrFiles.FileFormat format */ 5:
                    message.format = reader.int32();
                    break;
                case /* uint64 partition_index */ 6:
                    message.partitionIndex = reader.uint64().toBigInt();
                    break;
                case /* uint64 start */ 7:
                    message.start = reader.uint64().toBigInt();
                    break;
                case /* uint64 length */ 8:
                    message.length = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadRel_LocalFiles_FileOrFiles, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uri_path = 1; */
        if (message.pathType.oneofKind === "uriPath")
            writer.tag(1, WireType.LengthDelimited).string(message.pathType.uriPath);
        /* string uri_path_glob = 2; */
        if (message.pathType.oneofKind === "uriPathGlob")
            writer.tag(2, WireType.LengthDelimited).string(message.pathType.uriPathGlob);
        /* string uri_file = 3; */
        if (message.pathType.oneofKind === "uriFile")
            writer.tag(3, WireType.LengthDelimited).string(message.pathType.uriFile);
        /* string uri_folder = 4; */
        if (message.pathType.oneofKind === "uriFolder")
            writer.tag(4, WireType.LengthDelimited).string(message.pathType.uriFolder);
        /* substrait.ReadRel.LocalFiles.FileOrFiles.FileFormat format = 5; */
        if (message.format !== 0)
            writer.tag(5, WireType.Varint).int32(message.format);
        /* uint64 partition_index = 6; */
        if (message.partitionIndex !== 0n)
            writer.tag(6, WireType.Varint).uint64(message.partitionIndex);
        /* uint64 start = 7; */
        if (message.start !== 0n)
            writer.tag(7, WireType.Varint).uint64(message.start);
        /* uint64 length = 8; */
        if (message.length !== 0n)
            writer.tag(8, WireType.Varint).uint64(message.length);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.ReadRel.LocalFiles.FileOrFiles
 */
export const ReadRel_LocalFiles_FileOrFiles = new ReadRel_LocalFiles_FileOrFiles$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProjectRel$Type extends MessageType<ProjectRel> {
    constructor() {
        super("substrait.ProjectRel", [
            { no: 1, name: "common", kind: "message", T: () => RelCommon },
            { no: 2, name: "input", kind: "message", T: () => Rel },
            { no: 3, name: "expressions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression },
            { no: 10, name: "advanced_extension", kind: "message", T: () => AdvancedExtension }
        ]);
    }
    create(value?: PartialMessage<ProjectRel>): ProjectRel {
        const message = { expressions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProjectRel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProjectRel): ProjectRel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.RelCommon common */ 1:
                    message.common = RelCommon.internalBinaryRead(reader, reader.uint32(), options, message.common);
                    break;
                case /* substrait.Rel input */ 2:
                    message.input = Rel.internalBinaryRead(reader, reader.uint32(), options, message.input);
                    break;
                case /* repeated substrait.Expression expressions */ 3:
                    message.expressions.push(Expression.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* substrait.extensions.AdvancedExtension advanced_extension */ 10:
                    message.advancedExtension = AdvancedExtension.internalBinaryRead(reader, reader.uint32(), options, message.advancedExtension);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProjectRel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.RelCommon common = 1; */
        if (message.common)
            RelCommon.internalBinaryWrite(message.common, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Rel input = 2; */
        if (message.input)
            Rel.internalBinaryWrite(message.input, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated substrait.Expression expressions = 3; */
        for (let i = 0; i < message.expressions.length; i++)
            Expression.internalBinaryWrite(message.expressions[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.extensions.AdvancedExtension advanced_extension = 10; */
        if (message.advancedExtension)
            AdvancedExtension.internalBinaryWrite(message.advancedExtension, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.ProjectRel
 */
export const ProjectRel = new ProjectRel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JoinRel$Type extends MessageType<JoinRel> {
    constructor() {
        super("substrait.JoinRel", [
            { no: 1, name: "common", kind: "message", T: () => RelCommon },
            { no: 2, name: "left", kind: "message", T: () => Rel },
            { no: 3, name: "right", kind: "message", T: () => Rel },
            { no: 4, name: "expression", kind: "message", T: () => Expression },
            { no: 5, name: "post_join_filter", kind: "message", T: () => Expression },
            { no: 6, name: "type", kind: "enum", T: () => ["substrait.JoinRel.JoinType", JoinRel_JoinType, "JOIN_TYPE_"] },
            { no: 10, name: "advanced_extension", kind: "message", T: () => AdvancedExtension }
        ]);
    }
    create(value?: PartialMessage<JoinRel>): JoinRel {
        const message = { type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JoinRel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JoinRel): JoinRel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.RelCommon common */ 1:
                    message.common = RelCommon.internalBinaryRead(reader, reader.uint32(), options, message.common);
                    break;
                case /* substrait.Rel left */ 2:
                    message.left = Rel.internalBinaryRead(reader, reader.uint32(), options, message.left);
                    break;
                case /* substrait.Rel right */ 3:
                    message.right = Rel.internalBinaryRead(reader, reader.uint32(), options, message.right);
                    break;
                case /* substrait.Expression expression */ 4:
                    message.expression = Expression.internalBinaryRead(reader, reader.uint32(), options, message.expression);
                    break;
                case /* substrait.Expression post_join_filter */ 5:
                    message.postJoinFilter = Expression.internalBinaryRead(reader, reader.uint32(), options, message.postJoinFilter);
                    break;
                case /* substrait.JoinRel.JoinType type */ 6:
                    message.type = reader.int32();
                    break;
                case /* substrait.extensions.AdvancedExtension advanced_extension */ 10:
                    message.advancedExtension = AdvancedExtension.internalBinaryRead(reader, reader.uint32(), options, message.advancedExtension);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JoinRel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.RelCommon common = 1; */
        if (message.common)
            RelCommon.internalBinaryWrite(message.common, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Rel left = 2; */
        if (message.left)
            Rel.internalBinaryWrite(message.left, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Rel right = 3; */
        if (message.right)
            Rel.internalBinaryWrite(message.right, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression expression = 4; */
        if (message.expression)
            Expression.internalBinaryWrite(message.expression, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression post_join_filter = 5; */
        if (message.postJoinFilter)
            Expression.internalBinaryWrite(message.postJoinFilter, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* substrait.JoinRel.JoinType type = 6; */
        if (message.type !== 0)
            writer.tag(6, WireType.Varint).int32(message.type);
        /* substrait.extensions.AdvancedExtension advanced_extension = 10; */
        if (message.advancedExtension)
            AdvancedExtension.internalBinaryWrite(message.advancedExtension, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.JoinRel
 */
export const JoinRel = new JoinRel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CrossRel$Type extends MessageType<CrossRel> {
    constructor() {
        super("substrait.CrossRel", [
            { no: 1, name: "common", kind: "message", T: () => RelCommon },
            { no: 2, name: "left", kind: "message", T: () => Rel },
            { no: 3, name: "right", kind: "message", T: () => Rel },
            { no: 10, name: "advanced_extension", kind: "message", T: () => AdvancedExtension }
        ]);
    }
    create(value?: PartialMessage<CrossRel>): CrossRel {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CrossRel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CrossRel): CrossRel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.RelCommon common */ 1:
                    message.common = RelCommon.internalBinaryRead(reader, reader.uint32(), options, message.common);
                    break;
                case /* substrait.Rel left */ 2:
                    message.left = Rel.internalBinaryRead(reader, reader.uint32(), options, message.left);
                    break;
                case /* substrait.Rel right */ 3:
                    message.right = Rel.internalBinaryRead(reader, reader.uint32(), options, message.right);
                    break;
                case /* substrait.extensions.AdvancedExtension advanced_extension */ 10:
                    message.advancedExtension = AdvancedExtension.internalBinaryRead(reader, reader.uint32(), options, message.advancedExtension);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CrossRel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.RelCommon common = 1; */
        if (message.common)
            RelCommon.internalBinaryWrite(message.common, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Rel left = 2; */
        if (message.left)
            Rel.internalBinaryWrite(message.left, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Rel right = 3; */
        if (message.right)
            Rel.internalBinaryWrite(message.right, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.extensions.AdvancedExtension advanced_extension = 10; */
        if (message.advancedExtension)
            AdvancedExtension.internalBinaryWrite(message.advancedExtension, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.CrossRel
 */
export const CrossRel = new CrossRel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FetchRel$Type extends MessageType<FetchRel> {
    constructor() {
        super("substrait.FetchRel", [
            { no: 1, name: "common", kind: "message", T: () => RelCommon },
            { no: 2, name: "input", kind: "message", T: () => Rel },
            { no: 3, name: "offset", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "count", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "advanced_extension", kind: "message", T: () => AdvancedExtension }
        ]);
    }
    create(value?: PartialMessage<FetchRel>): FetchRel {
        const message = { offset: 0n, count: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FetchRel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FetchRel): FetchRel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.RelCommon common */ 1:
                    message.common = RelCommon.internalBinaryRead(reader, reader.uint32(), options, message.common);
                    break;
                case /* substrait.Rel input */ 2:
                    message.input = Rel.internalBinaryRead(reader, reader.uint32(), options, message.input);
                    break;
                case /* int64 offset */ 3:
                    message.offset = reader.int64().toBigInt();
                    break;
                case /* int64 count */ 4:
                    message.count = reader.int64().toBigInt();
                    break;
                case /* substrait.extensions.AdvancedExtension advanced_extension */ 10:
                    message.advancedExtension = AdvancedExtension.internalBinaryRead(reader, reader.uint32(), options, message.advancedExtension);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FetchRel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.RelCommon common = 1; */
        if (message.common)
            RelCommon.internalBinaryWrite(message.common, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Rel input = 2; */
        if (message.input)
            Rel.internalBinaryWrite(message.input, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* int64 offset = 3; */
        if (message.offset !== 0n)
            writer.tag(3, WireType.Varint).int64(message.offset);
        /* int64 count = 4; */
        if (message.count !== 0n)
            writer.tag(4, WireType.Varint).int64(message.count);
        /* substrait.extensions.AdvancedExtension advanced_extension = 10; */
        if (message.advancedExtension)
            AdvancedExtension.internalBinaryWrite(message.advancedExtension, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.FetchRel
 */
export const FetchRel = new FetchRel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggregateRel$Type extends MessageType<AggregateRel> {
    constructor() {
        super("substrait.AggregateRel", [
            { no: 1, name: "common", kind: "message", T: () => RelCommon },
            { no: 2, name: "input", kind: "message", T: () => Rel },
            { no: 3, name: "groupings", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AggregateRel_Grouping },
            { no: 4, name: "measures", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => AggregateRel_Measure },
            { no: 10, name: "advanced_extension", kind: "message", T: () => AdvancedExtension }
        ]);
    }
    create(value?: PartialMessage<AggregateRel>): AggregateRel {
        const message = { groupings: [], measures: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AggregateRel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregateRel): AggregateRel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.RelCommon common */ 1:
                    message.common = RelCommon.internalBinaryRead(reader, reader.uint32(), options, message.common);
                    break;
                case /* substrait.Rel input */ 2:
                    message.input = Rel.internalBinaryRead(reader, reader.uint32(), options, message.input);
                    break;
                case /* repeated substrait.AggregateRel.Grouping groupings */ 3:
                    message.groupings.push(AggregateRel_Grouping.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated substrait.AggregateRel.Measure measures */ 4:
                    message.measures.push(AggregateRel_Measure.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* substrait.extensions.AdvancedExtension advanced_extension */ 10:
                    message.advancedExtension = AdvancedExtension.internalBinaryRead(reader, reader.uint32(), options, message.advancedExtension);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AggregateRel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.RelCommon common = 1; */
        if (message.common)
            RelCommon.internalBinaryWrite(message.common, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Rel input = 2; */
        if (message.input)
            Rel.internalBinaryWrite(message.input, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated substrait.AggregateRel.Grouping groupings = 3; */
        for (let i = 0; i < message.groupings.length; i++)
            AggregateRel_Grouping.internalBinaryWrite(message.groupings[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated substrait.AggregateRel.Measure measures = 4; */
        for (let i = 0; i < message.measures.length; i++)
            AggregateRel_Measure.internalBinaryWrite(message.measures[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* substrait.extensions.AdvancedExtension advanced_extension = 10; */
        if (message.advancedExtension)
            AdvancedExtension.internalBinaryWrite(message.advancedExtension, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.AggregateRel
 */
export const AggregateRel = new AggregateRel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggregateRel_Grouping$Type extends MessageType<AggregateRel_Grouping> {
    constructor() {
        super("substrait.AggregateRel.Grouping", [
            { no: 1, name: "grouping_expressions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression }
        ]);
    }
    create(value?: PartialMessage<AggregateRel_Grouping>): AggregateRel_Grouping {
        const message = { groupingExpressions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AggregateRel_Grouping>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregateRel_Grouping): AggregateRel_Grouping {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.Expression grouping_expressions */ 1:
                    message.groupingExpressions.push(Expression.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AggregateRel_Grouping, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.Expression grouping_expressions = 1; */
        for (let i = 0; i < message.groupingExpressions.length; i++)
            Expression.internalBinaryWrite(message.groupingExpressions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.AggregateRel.Grouping
 */
export const AggregateRel_Grouping = new AggregateRel_Grouping$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggregateRel_Measure$Type extends MessageType<AggregateRel_Measure> {
    constructor() {
        super("substrait.AggregateRel.Measure", [
            { no: 1, name: "measure", kind: "message", T: () => AggregateFunction },
            { no: 2, name: "filter", kind: "message", T: () => Expression }
        ]);
    }
    create(value?: PartialMessage<AggregateRel_Measure>): AggregateRel_Measure {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AggregateRel_Measure>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregateRel_Measure): AggregateRel_Measure {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.AggregateFunction measure */ 1:
                    message.measure = AggregateFunction.internalBinaryRead(reader, reader.uint32(), options, message.measure);
                    break;
                case /* substrait.Expression filter */ 2:
                    message.filter = Expression.internalBinaryRead(reader, reader.uint32(), options, message.filter);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AggregateRel_Measure, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.AggregateFunction measure = 1; */
        if (message.measure)
            AggregateFunction.internalBinaryWrite(message.measure, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression filter = 2; */
        if (message.filter)
            Expression.internalBinaryWrite(message.filter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.AggregateRel.Measure
 */
export const AggregateRel_Measure = new AggregateRel_Measure$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SortRel$Type extends MessageType<SortRel> {
    constructor() {
        super("substrait.SortRel", [
            { no: 1, name: "common", kind: "message", T: () => RelCommon },
            { no: 2, name: "input", kind: "message", T: () => Rel },
            { no: 3, name: "sorts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SortField },
            { no: 10, name: "advanced_extension", kind: "message", T: () => AdvancedExtension }
        ]);
    }
    create(value?: PartialMessage<SortRel>): SortRel {
        const message = { sorts: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SortRel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SortRel): SortRel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.RelCommon common */ 1:
                    message.common = RelCommon.internalBinaryRead(reader, reader.uint32(), options, message.common);
                    break;
                case /* substrait.Rel input */ 2:
                    message.input = Rel.internalBinaryRead(reader, reader.uint32(), options, message.input);
                    break;
                case /* repeated substrait.SortField sorts */ 3:
                    message.sorts.push(SortField.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* substrait.extensions.AdvancedExtension advanced_extension */ 10:
                    message.advancedExtension = AdvancedExtension.internalBinaryRead(reader, reader.uint32(), options, message.advancedExtension);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SortRel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.RelCommon common = 1; */
        if (message.common)
            RelCommon.internalBinaryWrite(message.common, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Rel input = 2; */
        if (message.input)
            Rel.internalBinaryWrite(message.input, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated substrait.SortField sorts = 3; */
        for (let i = 0; i < message.sorts.length; i++)
            SortField.internalBinaryWrite(message.sorts[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.extensions.AdvancedExtension advanced_extension = 10; */
        if (message.advancedExtension)
            AdvancedExtension.internalBinaryWrite(message.advancedExtension, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.SortRel
 */
export const SortRel = new SortRel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FilterRel$Type extends MessageType<FilterRel> {
    constructor() {
        super("substrait.FilterRel", [
            { no: 1, name: "common", kind: "message", T: () => RelCommon },
            { no: 2, name: "input", kind: "message", T: () => Rel },
            { no: 3, name: "condition", kind: "message", T: () => Expression },
            { no: 10, name: "advanced_extension", kind: "message", T: () => AdvancedExtension }
        ]);
    }
    create(value?: PartialMessage<FilterRel>): FilterRel {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FilterRel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FilterRel): FilterRel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.RelCommon common */ 1:
                    message.common = RelCommon.internalBinaryRead(reader, reader.uint32(), options, message.common);
                    break;
                case /* substrait.Rel input */ 2:
                    message.input = Rel.internalBinaryRead(reader, reader.uint32(), options, message.input);
                    break;
                case /* substrait.Expression condition */ 3:
                    message.condition = Expression.internalBinaryRead(reader, reader.uint32(), options, message.condition);
                    break;
                case /* substrait.extensions.AdvancedExtension advanced_extension */ 10:
                    message.advancedExtension = AdvancedExtension.internalBinaryRead(reader, reader.uint32(), options, message.advancedExtension);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FilterRel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.RelCommon common = 1; */
        if (message.common)
            RelCommon.internalBinaryWrite(message.common, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Rel input = 2; */
        if (message.input)
            Rel.internalBinaryWrite(message.input, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression condition = 3; */
        if (message.condition)
            Expression.internalBinaryWrite(message.condition, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.extensions.AdvancedExtension advanced_extension = 10; */
        if (message.advancedExtension)
            AdvancedExtension.internalBinaryWrite(message.advancedExtension, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.FilterRel
 */
export const FilterRel = new FilterRel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRel$Type extends MessageType<SetRel> {
    constructor() {
        super("substrait.SetRel", [
            { no: 1, name: "common", kind: "message", T: () => RelCommon },
            { no: 2, name: "inputs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Rel },
            { no: 3, name: "op", kind: "enum", T: () => ["substrait.SetRel.SetOp", SetRel_SetOp, "SET_OP_"] },
            { no: 10, name: "advanced_extension", kind: "message", T: () => AdvancedExtension }
        ]);
    }
    create(value?: PartialMessage<SetRel>): SetRel {
        const message = { inputs: [], op: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetRel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRel): SetRel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.RelCommon common */ 1:
                    message.common = RelCommon.internalBinaryRead(reader, reader.uint32(), options, message.common);
                    break;
                case /* repeated substrait.Rel inputs */ 2:
                    message.inputs.push(Rel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* substrait.SetRel.SetOp op */ 3:
                    message.op = reader.int32();
                    break;
                case /* substrait.extensions.AdvancedExtension advanced_extension */ 10:
                    message.advancedExtension = AdvancedExtension.internalBinaryRead(reader, reader.uint32(), options, message.advancedExtension);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.RelCommon common = 1; */
        if (message.common)
            RelCommon.internalBinaryWrite(message.common, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated substrait.Rel inputs = 2; */
        for (let i = 0; i < message.inputs.length; i++)
            Rel.internalBinaryWrite(message.inputs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.SetRel.SetOp op = 3; */
        if (message.op !== 0)
            writer.tag(3, WireType.Varint).int32(message.op);
        /* substrait.extensions.AdvancedExtension advanced_extension = 10; */
        if (message.advancedExtension)
            AdvancedExtension.internalBinaryWrite(message.advancedExtension, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.SetRel
 */
export const SetRel = new SetRel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtensionSingleRel$Type extends MessageType<ExtensionSingleRel> {
    constructor() {
        super("substrait.ExtensionSingleRel", [
            { no: 1, name: "common", kind: "message", T: () => RelCommon },
            { no: 2, name: "input", kind: "message", T: () => Rel },
            { no: 3, name: "detail", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<ExtensionSingleRel>): ExtensionSingleRel {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExtensionSingleRel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtensionSingleRel): ExtensionSingleRel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.RelCommon common */ 1:
                    message.common = RelCommon.internalBinaryRead(reader, reader.uint32(), options, message.common);
                    break;
                case /* substrait.Rel input */ 2:
                    message.input = Rel.internalBinaryRead(reader, reader.uint32(), options, message.input);
                    break;
                case /* google.protobuf.Any detail */ 3:
                    message.detail = Any.internalBinaryRead(reader, reader.uint32(), options, message.detail);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtensionSingleRel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.RelCommon common = 1; */
        if (message.common)
            RelCommon.internalBinaryWrite(message.common, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Rel input = 2; */
        if (message.input)
            Rel.internalBinaryWrite(message.input, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any detail = 3; */
        if (message.detail)
            Any.internalBinaryWrite(message.detail, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.ExtensionSingleRel
 */
export const ExtensionSingleRel = new ExtensionSingleRel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtensionLeafRel$Type extends MessageType<ExtensionLeafRel> {
    constructor() {
        super("substrait.ExtensionLeafRel", [
            { no: 1, name: "common", kind: "message", T: () => RelCommon },
            { no: 2, name: "detail", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<ExtensionLeafRel>): ExtensionLeafRel {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExtensionLeafRel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtensionLeafRel): ExtensionLeafRel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.RelCommon common */ 1:
                    message.common = RelCommon.internalBinaryRead(reader, reader.uint32(), options, message.common);
                    break;
                case /* google.protobuf.Any detail */ 2:
                    message.detail = Any.internalBinaryRead(reader, reader.uint32(), options, message.detail);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtensionLeafRel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.RelCommon common = 1; */
        if (message.common)
            RelCommon.internalBinaryWrite(message.common, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any detail = 2; */
        if (message.detail)
            Any.internalBinaryWrite(message.detail, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.ExtensionLeafRel
 */
export const ExtensionLeafRel = new ExtensionLeafRel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExtensionMultiRel$Type extends MessageType<ExtensionMultiRel> {
    constructor() {
        super("substrait.ExtensionMultiRel", [
            { no: 1, name: "common", kind: "message", T: () => RelCommon },
            { no: 2, name: "inputs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Rel },
            { no: 3, name: "detail", kind: "message", T: () => Any }
        ]);
    }
    create(value?: PartialMessage<ExtensionMultiRel>): ExtensionMultiRel {
        const message = { inputs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExtensionMultiRel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExtensionMultiRel): ExtensionMultiRel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.RelCommon common */ 1:
                    message.common = RelCommon.internalBinaryRead(reader, reader.uint32(), options, message.common);
                    break;
                case /* repeated substrait.Rel inputs */ 2:
                    message.inputs.push(Rel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Any detail */ 3:
                    message.detail = Any.internalBinaryRead(reader, reader.uint32(), options, message.detail);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExtensionMultiRel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.RelCommon common = 1; */
        if (message.common)
            RelCommon.internalBinaryWrite(message.common, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated substrait.Rel inputs = 2; */
        for (let i = 0; i < message.inputs.length; i++)
            Rel.internalBinaryWrite(message.inputs[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Any detail = 3; */
        if (message.detail)
            Any.internalBinaryWrite(message.detail, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.ExtensionMultiRel
 */
export const ExtensionMultiRel = new ExtensionMultiRel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelRoot$Type extends MessageType<RelRoot> {
    constructor() {
        super("substrait.RelRoot", [
            { no: 1, name: "input", kind: "message", T: () => Rel },
            { no: 2, name: "names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RelRoot>): RelRoot {
        const message = { names: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RelRoot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelRoot): RelRoot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Rel input */ 1:
                    message.input = Rel.internalBinaryRead(reader, reader.uint32(), options, message.input);
                    break;
                case /* repeated string names */ 2:
                    message.names.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelRoot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Rel input = 1; */
        if (message.input)
            Rel.internalBinaryWrite(message.input, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated string names = 2; */
        for (let i = 0; i < message.names.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.names[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.RelRoot
 */
export const RelRoot = new RelRoot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Rel$Type extends MessageType<Rel> {
    constructor() {
        super("substrait.Rel", [
            { no: 1, name: "read", kind: "message", oneof: "relType", T: () => ReadRel },
            { no: 2, name: "filter", kind: "message", oneof: "relType", T: () => FilterRel },
            { no: 3, name: "fetch", kind: "message", oneof: "relType", T: () => FetchRel },
            { no: 4, name: "aggregate", kind: "message", oneof: "relType", T: () => AggregateRel },
            { no: 5, name: "sort", kind: "message", oneof: "relType", T: () => SortRel },
            { no: 6, name: "join", kind: "message", oneof: "relType", T: () => JoinRel },
            { no: 7, name: "project", kind: "message", oneof: "relType", T: () => ProjectRel },
            { no: 8, name: "set", kind: "message", oneof: "relType", T: () => SetRel },
            { no: 9, name: "extension_single", kind: "message", oneof: "relType", T: () => ExtensionSingleRel },
            { no: 10, name: "extension_multi", kind: "message", oneof: "relType", T: () => ExtensionMultiRel },
            { no: 11, name: "extension_leaf", kind: "message", oneof: "relType", T: () => ExtensionLeafRel },
            { no: 12, name: "cross", kind: "message", oneof: "relType", T: () => CrossRel }
        ]);
    }
    create(value?: PartialMessage<Rel>): Rel {
        const message = { relType: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Rel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Rel): Rel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.ReadRel read */ 1:
                    message.relType = {
                        oneofKind: "read",
                        read: ReadRel.internalBinaryRead(reader, reader.uint32(), options, (message.relType as any).read)
                    };
                    break;
                case /* substrait.FilterRel filter */ 2:
                    message.relType = {
                        oneofKind: "filter",
                        filter: FilterRel.internalBinaryRead(reader, reader.uint32(), options, (message.relType as any).filter)
                    };
                    break;
                case /* substrait.FetchRel fetch */ 3:
                    message.relType = {
                        oneofKind: "fetch",
                        fetch: FetchRel.internalBinaryRead(reader, reader.uint32(), options, (message.relType as any).fetch)
                    };
                    break;
                case /* substrait.AggregateRel aggregate */ 4:
                    message.relType = {
                        oneofKind: "aggregate",
                        aggregate: AggregateRel.internalBinaryRead(reader, reader.uint32(), options, (message.relType as any).aggregate)
                    };
                    break;
                case /* substrait.SortRel sort */ 5:
                    message.relType = {
                        oneofKind: "sort",
                        sort: SortRel.internalBinaryRead(reader, reader.uint32(), options, (message.relType as any).sort)
                    };
                    break;
                case /* substrait.JoinRel join */ 6:
                    message.relType = {
                        oneofKind: "join",
                        join: JoinRel.internalBinaryRead(reader, reader.uint32(), options, (message.relType as any).join)
                    };
                    break;
                case /* substrait.ProjectRel project */ 7:
                    message.relType = {
                        oneofKind: "project",
                        project: ProjectRel.internalBinaryRead(reader, reader.uint32(), options, (message.relType as any).project)
                    };
                    break;
                case /* substrait.SetRel set */ 8:
                    message.relType = {
                        oneofKind: "set",
                        set: SetRel.internalBinaryRead(reader, reader.uint32(), options, (message.relType as any).set)
                    };
                    break;
                case /* substrait.ExtensionSingleRel extension_single */ 9:
                    message.relType = {
                        oneofKind: "extensionSingle",
                        extensionSingle: ExtensionSingleRel.internalBinaryRead(reader, reader.uint32(), options, (message.relType as any).extensionSingle)
                    };
                    break;
                case /* substrait.ExtensionMultiRel extension_multi */ 10:
                    message.relType = {
                        oneofKind: "extensionMulti",
                        extensionMulti: ExtensionMultiRel.internalBinaryRead(reader, reader.uint32(), options, (message.relType as any).extensionMulti)
                    };
                    break;
                case /* substrait.ExtensionLeafRel extension_leaf */ 11:
                    message.relType = {
                        oneofKind: "extensionLeaf",
                        extensionLeaf: ExtensionLeafRel.internalBinaryRead(reader, reader.uint32(), options, (message.relType as any).extensionLeaf)
                    };
                    break;
                case /* substrait.CrossRel cross */ 12:
                    message.relType = {
                        oneofKind: "cross",
                        cross: CrossRel.internalBinaryRead(reader, reader.uint32(), options, (message.relType as any).cross)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Rel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.ReadRel read = 1; */
        if (message.relType.oneofKind === "read")
            ReadRel.internalBinaryWrite(message.relType.read, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.FilterRel filter = 2; */
        if (message.relType.oneofKind === "filter")
            FilterRel.internalBinaryWrite(message.relType.filter, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.FetchRel fetch = 3; */
        if (message.relType.oneofKind === "fetch")
            FetchRel.internalBinaryWrite(message.relType.fetch, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.AggregateRel aggregate = 4; */
        if (message.relType.oneofKind === "aggregate")
            AggregateRel.internalBinaryWrite(message.relType.aggregate, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* substrait.SortRel sort = 5; */
        if (message.relType.oneofKind === "sort")
            SortRel.internalBinaryWrite(message.relType.sort, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* substrait.JoinRel join = 6; */
        if (message.relType.oneofKind === "join")
            JoinRel.internalBinaryWrite(message.relType.join, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* substrait.ProjectRel project = 7; */
        if (message.relType.oneofKind === "project")
            ProjectRel.internalBinaryWrite(message.relType.project, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* substrait.SetRel set = 8; */
        if (message.relType.oneofKind === "set")
            SetRel.internalBinaryWrite(message.relType.set, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* substrait.ExtensionSingleRel extension_single = 9; */
        if (message.relType.oneofKind === "extensionSingle")
            ExtensionSingleRel.internalBinaryWrite(message.relType.extensionSingle, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* substrait.ExtensionMultiRel extension_multi = 10; */
        if (message.relType.oneofKind === "extensionMulti")
            ExtensionMultiRel.internalBinaryWrite(message.relType.extensionMulti, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* substrait.ExtensionLeafRel extension_leaf = 11; */
        if (message.relType.oneofKind === "extensionLeaf")
            ExtensionLeafRel.internalBinaryWrite(message.relType.extensionLeaf, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* substrait.CrossRel cross = 12; */
        if (message.relType.oneofKind === "cross")
            CrossRel.internalBinaryWrite(message.relType.cross, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Rel
 */
export const Rel = new Rel$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression$Type extends MessageType<Expression> {
    constructor() {
        super("substrait.Expression", [
            { no: 1, name: "literal", kind: "message", oneof: "rexType", T: () => Expression_Literal },
            { no: 2, name: "selection", kind: "message", oneof: "rexType", T: () => Expression_FieldReference },
            { no: 3, name: "scalar_function", kind: "message", oneof: "rexType", T: () => Expression_ScalarFunction },
            { no: 5, name: "window_function", kind: "message", oneof: "rexType", T: () => Expression_WindowFunction },
            { no: 6, name: "if_then", kind: "message", oneof: "rexType", T: () => Expression_IfThen },
            { no: 7, name: "switch_expression", kind: "message", oneof: "rexType", T: () => Expression_SwitchExpression },
            { no: 8, name: "singular_or_list", kind: "message", oneof: "rexType", T: () => Expression_SingularOrList },
            { no: 9, name: "multi_or_list", kind: "message", oneof: "rexType", T: () => Expression_MultiOrList },
            { no: 10, name: "enum", kind: "message", oneof: "rexType", T: () => Expression_Enum },
            { no: 11, name: "cast", kind: "message", oneof: "rexType", T: () => Expression_Cast },
            { no: 12, name: "subquery", kind: "message", oneof: "rexType", T: () => Expression_Subquery }
        ]);
    }
    create(value?: PartialMessage<Expression>): Expression {
        const message = { rexType: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression): Expression {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression.Literal literal */ 1:
                    message.rexType = {
                        oneofKind: "literal",
                        literal: Expression_Literal.internalBinaryRead(reader, reader.uint32(), options, (message.rexType as any).literal)
                    };
                    break;
                case /* substrait.Expression.FieldReference selection */ 2:
                    message.rexType = {
                        oneofKind: "selection",
                        selection: Expression_FieldReference.internalBinaryRead(reader, reader.uint32(), options, (message.rexType as any).selection)
                    };
                    break;
                case /* substrait.Expression.ScalarFunction scalar_function */ 3:
                    message.rexType = {
                        oneofKind: "scalarFunction",
                        scalarFunction: Expression_ScalarFunction.internalBinaryRead(reader, reader.uint32(), options, (message.rexType as any).scalarFunction)
                    };
                    break;
                case /* substrait.Expression.WindowFunction window_function */ 5:
                    message.rexType = {
                        oneofKind: "windowFunction",
                        windowFunction: Expression_WindowFunction.internalBinaryRead(reader, reader.uint32(), options, (message.rexType as any).windowFunction)
                    };
                    break;
                case /* substrait.Expression.IfThen if_then */ 6:
                    message.rexType = {
                        oneofKind: "ifThen",
                        ifThen: Expression_IfThen.internalBinaryRead(reader, reader.uint32(), options, (message.rexType as any).ifThen)
                    };
                    break;
                case /* substrait.Expression.SwitchExpression switch_expression */ 7:
                    message.rexType = {
                        oneofKind: "switchExpression",
                        switchExpression: Expression_SwitchExpression.internalBinaryRead(reader, reader.uint32(), options, (message.rexType as any).switchExpression)
                    };
                    break;
                case /* substrait.Expression.SingularOrList singular_or_list */ 8:
                    message.rexType = {
                        oneofKind: "singularOrList",
                        singularOrList: Expression_SingularOrList.internalBinaryRead(reader, reader.uint32(), options, (message.rexType as any).singularOrList)
                    };
                    break;
                case /* substrait.Expression.MultiOrList multi_or_list */ 9:
                    message.rexType = {
                        oneofKind: "multiOrList",
                        multiOrList: Expression_MultiOrList.internalBinaryRead(reader, reader.uint32(), options, (message.rexType as any).multiOrList)
                    };
                    break;
                case /* substrait.Expression.Enum enum */ 10:
                    message.rexType = {
                        oneofKind: "enum",
                        enum: Expression_Enum.internalBinaryRead(reader, reader.uint32(), options, (message.rexType as any).enum)
                    };
                    break;
                case /* substrait.Expression.Cast cast */ 11:
                    message.rexType = {
                        oneofKind: "cast",
                        cast: Expression_Cast.internalBinaryRead(reader, reader.uint32(), options, (message.rexType as any).cast)
                    };
                    break;
                case /* substrait.Expression.Subquery subquery */ 12:
                    message.rexType = {
                        oneofKind: "subquery",
                        subquery: Expression_Subquery.internalBinaryRead(reader, reader.uint32(), options, (message.rexType as any).subquery)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression.Literal literal = 1; */
        if (message.rexType.oneofKind === "literal")
            Expression_Literal.internalBinaryWrite(message.rexType.literal, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.FieldReference selection = 2; */
        if (message.rexType.oneofKind === "selection")
            Expression_FieldReference.internalBinaryWrite(message.rexType.selection, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.ScalarFunction scalar_function = 3; */
        if (message.rexType.oneofKind === "scalarFunction")
            Expression_ScalarFunction.internalBinaryWrite(message.rexType.scalarFunction, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.WindowFunction window_function = 5; */
        if (message.rexType.oneofKind === "windowFunction")
            Expression_WindowFunction.internalBinaryWrite(message.rexType.windowFunction, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.IfThen if_then = 6; */
        if (message.rexType.oneofKind === "ifThen")
            Expression_IfThen.internalBinaryWrite(message.rexType.ifThen, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.SwitchExpression switch_expression = 7; */
        if (message.rexType.oneofKind === "switchExpression")
            Expression_SwitchExpression.internalBinaryWrite(message.rexType.switchExpression, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.SingularOrList singular_or_list = 8; */
        if (message.rexType.oneofKind === "singularOrList")
            Expression_SingularOrList.internalBinaryWrite(message.rexType.singularOrList, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.MultiOrList multi_or_list = 9; */
        if (message.rexType.oneofKind === "multiOrList")
            Expression_MultiOrList.internalBinaryWrite(message.rexType.multiOrList, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.Enum enum = 10; */
        if (message.rexType.oneofKind === "enum")
            Expression_Enum.internalBinaryWrite(message.rexType.enum, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.Cast cast = 11; */
        if (message.rexType.oneofKind === "cast")
            Expression_Cast.internalBinaryWrite(message.rexType.cast, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.Subquery subquery = 12; */
        if (message.rexType.oneofKind === "subquery")
            Expression_Subquery.internalBinaryWrite(message.rexType.subquery, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression
 */
export const Expression = new Expression$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Enum$Type extends MessageType<Expression_Enum> {
    constructor() {
        super("substrait.Expression.Enum", [
            { no: 1, name: "specified", kind: "scalar", oneof: "enumKind", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "unspecified", kind: "message", oneof: "enumKind", T: () => Expression_Enum_Empty }
        ]);
    }
    create(value?: PartialMessage<Expression_Enum>): Expression_Enum {
        const message = { enumKind: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Enum>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Enum): Expression_Enum {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string specified */ 1:
                    message.enumKind = {
                        oneofKind: "specified",
                        specified: reader.string()
                    };
                    break;
                case /* substrait.Expression.Enum.Empty unspecified */ 2:
                    message.enumKind = {
                        oneofKind: "unspecified",
                        unspecified: Expression_Enum_Empty.internalBinaryRead(reader, reader.uint32(), options, (message.enumKind as any).unspecified)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_Enum, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string specified = 1; */
        if (message.enumKind.oneofKind === "specified")
            writer.tag(1, WireType.LengthDelimited).string(message.enumKind.specified);
        /* substrait.Expression.Enum.Empty unspecified = 2; */
        if (message.enumKind.oneofKind === "unspecified")
            Expression_Enum_Empty.internalBinaryWrite(message.enumKind.unspecified, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Enum
 */
export const Expression_Enum = new Expression_Enum$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Enum_Empty$Type extends MessageType<Expression_Enum_Empty> {
    constructor() {
        super("substrait.Expression.Enum.Empty", []);
    }
    create(value?: PartialMessage<Expression_Enum_Empty>): Expression_Enum_Empty {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Enum_Empty>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Enum_Empty): Expression_Enum_Empty {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Expression_Enum_Empty, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Enum.Empty
 */
export const Expression_Enum_Empty = new Expression_Enum_Empty$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Literal$Type extends MessageType<Expression_Literal> {
    constructor() {
        super("substrait.Expression.Literal", [
            { no: 1, name: "boolean", kind: "scalar", oneof: "literalType", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "i8", kind: "scalar", oneof: "literalType", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "i16", kind: "scalar", oneof: "literalType", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "i32", kind: "scalar", oneof: "literalType", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "i64", kind: "scalar", oneof: "literalType", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "fp32", kind: "scalar", oneof: "literalType", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "fp64", kind: "scalar", oneof: "literalType", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 12, name: "string", kind: "scalar", oneof: "literalType", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "binary", kind: "scalar", oneof: "literalType", T: 12 /*ScalarType.BYTES*/ },
            { no: 14, name: "timestamp", kind: "scalar", oneof: "literalType", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 16, name: "date", kind: "scalar", oneof: "literalType", T: 5 /*ScalarType.INT32*/ },
            { no: 17, name: "time", kind: "scalar", oneof: "literalType", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 19, name: "interval_year_to_month", kind: "message", oneof: "literalType", T: () => Expression_Literal_IntervalYearToMonth },
            { no: 20, name: "interval_day_to_second", kind: "message", oneof: "literalType", T: () => Expression_Literal_IntervalDayToSecond },
            { no: 21, name: "fixed_char", kind: "scalar", oneof: "literalType", T: 9 /*ScalarType.STRING*/ },
            { no: 22, name: "var_char", kind: "message", oneof: "literalType", T: () => Expression_Literal_VarChar },
            { no: 23, name: "fixed_binary", kind: "scalar", oneof: "literalType", T: 12 /*ScalarType.BYTES*/ },
            { no: 24, name: "decimal", kind: "message", oneof: "literalType", T: () => Expression_Literal_Decimal },
            { no: 25, name: "struct", kind: "message", oneof: "literalType", T: () => Expression_Literal_Struct },
            { no: 26, name: "map", kind: "message", oneof: "literalType", T: () => Expression_Literal_Map },
            { no: 27, name: "timestamp_tz", kind: "scalar", oneof: "literalType", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 28, name: "uuid", kind: "scalar", oneof: "literalType", T: 12 /*ScalarType.BYTES*/ },
            { no: 29, name: "null", kind: "message", oneof: "literalType", T: () => Type },
            { no: 30, name: "list", kind: "message", oneof: "literalType", T: () => Expression_Literal_List },
            { no: 31, name: "empty_list", kind: "message", oneof: "literalType", T: () => Type_List },
            { no: 32, name: "empty_map", kind: "message", oneof: "literalType", T: () => Type_Map },
            { no: 50, name: "nullable", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Expression_Literal>): Expression_Literal {
        const message = { literalType: { oneofKind: undefined }, nullable: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Literal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Literal): Expression_Literal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool boolean */ 1:
                    message.literalType = {
                        oneofKind: "boolean",
                        boolean: reader.bool()
                    };
                    break;
                case /* int32 i8 */ 2:
                    message.literalType = {
                        oneofKind: "i8",
                        i8: reader.int32()
                    };
                    break;
                case /* int32 i16 */ 3:
                    message.literalType = {
                        oneofKind: "i16",
                        i16: reader.int32()
                    };
                    break;
                case /* int32 i32 */ 5:
                    message.literalType = {
                        oneofKind: "i32",
                        i32: reader.int32()
                    };
                    break;
                case /* int64 i64 */ 7:
                    message.literalType = {
                        oneofKind: "i64",
                        i64: reader.int64().toBigInt()
                    };
                    break;
                case /* float fp32 */ 10:
                    message.literalType = {
                        oneofKind: "fp32",
                        fp32: reader.float()
                    };
                    break;
                case /* double fp64 */ 11:
                    message.literalType = {
                        oneofKind: "fp64",
                        fp64: reader.double()
                    };
                    break;
                case /* string string */ 12:
                    message.literalType = {
                        oneofKind: "string",
                        string: reader.string()
                    };
                    break;
                case /* bytes binary */ 13:
                    message.literalType = {
                        oneofKind: "binary",
                        binary: reader.bytes()
                    };
                    break;
                case /* int64 timestamp */ 14:
                    message.literalType = {
                        oneofKind: "timestamp",
                        timestamp: reader.int64().toBigInt()
                    };
                    break;
                case /* int32 date */ 16:
                    message.literalType = {
                        oneofKind: "date",
                        date: reader.int32()
                    };
                    break;
                case /* int64 time */ 17:
                    message.literalType = {
                        oneofKind: "time",
                        time: reader.int64().toBigInt()
                    };
                    break;
                case /* substrait.Expression.Literal.IntervalYearToMonth interval_year_to_month */ 19:
                    message.literalType = {
                        oneofKind: "intervalYearToMonth",
                        intervalYearToMonth: Expression_Literal_IntervalYearToMonth.internalBinaryRead(reader, reader.uint32(), options, (message.literalType as any).intervalYearToMonth)
                    };
                    break;
                case /* substrait.Expression.Literal.IntervalDayToSecond interval_day_to_second */ 20:
                    message.literalType = {
                        oneofKind: "intervalDayToSecond",
                        intervalDayToSecond: Expression_Literal_IntervalDayToSecond.internalBinaryRead(reader, reader.uint32(), options, (message.literalType as any).intervalDayToSecond)
                    };
                    break;
                case /* string fixed_char */ 21:
                    message.literalType = {
                        oneofKind: "fixedChar",
                        fixedChar: reader.string()
                    };
                    break;
                case /* substrait.Expression.Literal.VarChar var_char */ 22:
                    message.literalType = {
                        oneofKind: "varChar",
                        varChar: Expression_Literal_VarChar.internalBinaryRead(reader, reader.uint32(), options, (message.literalType as any).varChar)
                    };
                    break;
                case /* bytes fixed_binary */ 23:
                    message.literalType = {
                        oneofKind: "fixedBinary",
                        fixedBinary: reader.bytes()
                    };
                    break;
                case /* substrait.Expression.Literal.Decimal decimal */ 24:
                    message.literalType = {
                        oneofKind: "decimal",
                        decimal: Expression_Literal_Decimal.internalBinaryRead(reader, reader.uint32(), options, (message.literalType as any).decimal)
                    };
                    break;
                case /* substrait.Expression.Literal.Struct struct */ 25:
                    message.literalType = {
                        oneofKind: "struct",
                        struct: Expression_Literal_Struct.internalBinaryRead(reader, reader.uint32(), options, (message.literalType as any).struct)
                    };
                    break;
                case /* substrait.Expression.Literal.Map map */ 26:
                    message.literalType = {
                        oneofKind: "map",
                        map: Expression_Literal_Map.internalBinaryRead(reader, reader.uint32(), options, (message.literalType as any).map)
                    };
                    break;
                case /* int64 timestamp_tz */ 27:
                    message.literalType = {
                        oneofKind: "timestampTz",
                        timestampTz: reader.int64().toBigInt()
                    };
                    break;
                case /* bytes uuid */ 28:
                    message.literalType = {
                        oneofKind: "uuid",
                        uuid: reader.bytes()
                    };
                    break;
                case /* substrait.Type null */ 29:
                    message.literalType = {
                        oneofKind: "null",
                        null: Type.internalBinaryRead(reader, reader.uint32(), options, (message.literalType as any).null)
                    };
                    break;
                case /* substrait.Expression.Literal.List list */ 30:
                    message.literalType = {
                        oneofKind: "list",
                        list: Expression_Literal_List.internalBinaryRead(reader, reader.uint32(), options, (message.literalType as any).list)
                    };
                    break;
                case /* substrait.Type.List empty_list */ 31:
                    message.literalType = {
                        oneofKind: "emptyList",
                        emptyList: Type_List.internalBinaryRead(reader, reader.uint32(), options, (message.literalType as any).emptyList)
                    };
                    break;
                case /* substrait.Type.Map empty_map */ 32:
                    message.literalType = {
                        oneofKind: "emptyMap",
                        emptyMap: Type_Map.internalBinaryRead(reader, reader.uint32(), options, (message.literalType as any).emptyMap)
                    };
                    break;
                case /* bool nullable */ 50:
                    message.nullable = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_Literal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool boolean = 1; */
        if (message.literalType.oneofKind === "boolean")
            writer.tag(1, WireType.Varint).bool(message.literalType.boolean);
        /* int32 i8 = 2; */
        if (message.literalType.oneofKind === "i8")
            writer.tag(2, WireType.Varint).int32(message.literalType.i8);
        /* int32 i16 = 3; */
        if (message.literalType.oneofKind === "i16")
            writer.tag(3, WireType.Varint).int32(message.literalType.i16);
        /* int32 i32 = 5; */
        if (message.literalType.oneofKind === "i32")
            writer.tag(5, WireType.Varint).int32(message.literalType.i32);
        /* int64 i64 = 7; */
        if (message.literalType.oneofKind === "i64")
            writer.tag(7, WireType.Varint).int64(message.literalType.i64);
        /* float fp32 = 10; */
        if (message.literalType.oneofKind === "fp32")
            writer.tag(10, WireType.Bit32).float(message.literalType.fp32);
        /* double fp64 = 11; */
        if (message.literalType.oneofKind === "fp64")
            writer.tag(11, WireType.Bit64).double(message.literalType.fp64);
        /* string string = 12; */
        if (message.literalType.oneofKind === "string")
            writer.tag(12, WireType.LengthDelimited).string(message.literalType.string);
        /* bytes binary = 13; */
        if (message.literalType.oneofKind === "binary")
            writer.tag(13, WireType.LengthDelimited).bytes(message.literalType.binary);
        /* int64 timestamp = 14; */
        if (message.literalType.oneofKind === "timestamp")
            writer.tag(14, WireType.Varint).int64(message.literalType.timestamp);
        /* int32 date = 16; */
        if (message.literalType.oneofKind === "date")
            writer.tag(16, WireType.Varint).int32(message.literalType.date);
        /* int64 time = 17; */
        if (message.literalType.oneofKind === "time")
            writer.tag(17, WireType.Varint).int64(message.literalType.time);
        /* substrait.Expression.Literal.IntervalYearToMonth interval_year_to_month = 19; */
        if (message.literalType.oneofKind === "intervalYearToMonth")
            Expression_Literal_IntervalYearToMonth.internalBinaryWrite(message.literalType.intervalYearToMonth, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.Literal.IntervalDayToSecond interval_day_to_second = 20; */
        if (message.literalType.oneofKind === "intervalDayToSecond")
            Expression_Literal_IntervalDayToSecond.internalBinaryWrite(message.literalType.intervalDayToSecond, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* string fixed_char = 21; */
        if (message.literalType.oneofKind === "fixedChar")
            writer.tag(21, WireType.LengthDelimited).string(message.literalType.fixedChar);
        /* substrait.Expression.Literal.VarChar var_char = 22; */
        if (message.literalType.oneofKind === "varChar")
            Expression_Literal_VarChar.internalBinaryWrite(message.literalType.varChar, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* bytes fixed_binary = 23; */
        if (message.literalType.oneofKind === "fixedBinary")
            writer.tag(23, WireType.LengthDelimited).bytes(message.literalType.fixedBinary);
        /* substrait.Expression.Literal.Decimal decimal = 24; */
        if (message.literalType.oneofKind === "decimal")
            Expression_Literal_Decimal.internalBinaryWrite(message.literalType.decimal, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.Literal.Struct struct = 25; */
        if (message.literalType.oneofKind === "struct")
            Expression_Literal_Struct.internalBinaryWrite(message.literalType.struct, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.Literal.Map map = 26; */
        if (message.literalType.oneofKind === "map")
            Expression_Literal_Map.internalBinaryWrite(message.literalType.map, writer.tag(26, WireType.LengthDelimited).fork(), options).join();
        /* int64 timestamp_tz = 27; */
        if (message.literalType.oneofKind === "timestampTz")
            writer.tag(27, WireType.Varint).int64(message.literalType.timestampTz);
        /* bytes uuid = 28; */
        if (message.literalType.oneofKind === "uuid")
            writer.tag(28, WireType.LengthDelimited).bytes(message.literalType.uuid);
        /* substrait.Type null = 29; */
        if (message.literalType.oneofKind === "null")
            Type.internalBinaryWrite(message.literalType.null, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.Literal.List list = 30; */
        if (message.literalType.oneofKind === "list")
            Expression_Literal_List.internalBinaryWrite(message.literalType.list, writer.tag(30, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.List empty_list = 31; */
        if (message.literalType.oneofKind === "emptyList")
            Type_List.internalBinaryWrite(message.literalType.emptyList, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.Map empty_map = 32; */
        if (message.literalType.oneofKind === "emptyMap")
            Type_Map.internalBinaryWrite(message.literalType.emptyMap, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* bool nullable = 50; */
        if (message.nullable !== false)
            writer.tag(50, WireType.Varint).bool(message.nullable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Literal
 */
export const Expression_Literal = new Expression_Literal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Literal_VarChar$Type extends MessageType<Expression_Literal_VarChar> {
    constructor() {
        super("substrait.Expression.Literal.VarChar", [
            { no: 1, name: "value", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "length", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Expression_Literal_VarChar>): Expression_Literal_VarChar {
        const message = { value: "", length: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Literal_VarChar>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Literal_VarChar): Expression_Literal_VarChar {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string value */ 1:
                    message.value = reader.string();
                    break;
                case /* uint32 length */ 2:
                    message.length = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_Literal_VarChar, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string value = 1; */
        if (message.value !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        /* uint32 length = 2; */
        if (message.length !== 0)
            writer.tag(2, WireType.Varint).uint32(message.length);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Literal.VarChar
 */
export const Expression_Literal_VarChar = new Expression_Literal_VarChar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Literal_Decimal$Type extends MessageType<Expression_Literal_Decimal> {
    constructor() {
        super("substrait.Expression.Literal.Decimal", [
            { no: 1, name: "value", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "precision", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "scale", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Expression_Literal_Decimal>): Expression_Literal_Decimal {
        const message = { value: new Uint8Array(0), precision: 0, scale: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Literal_Decimal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Literal_Decimal): Expression_Literal_Decimal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes value */ 1:
                    message.value = reader.bytes();
                    break;
                case /* int32 precision */ 2:
                    message.precision = reader.int32();
                    break;
                case /* int32 scale */ 3:
                    message.scale = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_Literal_Decimal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes value = 1; */
        if (message.value.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.value);
        /* int32 precision = 2; */
        if (message.precision !== 0)
            writer.tag(2, WireType.Varint).int32(message.precision);
        /* int32 scale = 3; */
        if (message.scale !== 0)
            writer.tag(3, WireType.Varint).int32(message.scale);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Literal.Decimal
 */
export const Expression_Literal_Decimal = new Expression_Literal_Decimal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Literal_Map$Type extends MessageType<Expression_Literal_Map> {
    constructor() {
        super("substrait.Expression.Literal.Map", [
            { no: 1, name: "key_values", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression_Literal_Map_KeyValue }
        ]);
    }
    create(value?: PartialMessage<Expression_Literal_Map>): Expression_Literal_Map {
        const message = { keyValues: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Literal_Map>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Literal_Map): Expression_Literal_Map {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.Expression.Literal.Map.KeyValue key_values */ 1:
                    message.keyValues.push(Expression_Literal_Map_KeyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_Literal_Map, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.Expression.Literal.Map.KeyValue key_values = 1; */
        for (let i = 0; i < message.keyValues.length; i++)
            Expression_Literal_Map_KeyValue.internalBinaryWrite(message.keyValues[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Literal.Map
 */
export const Expression_Literal_Map = new Expression_Literal_Map$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Literal_Map_KeyValue$Type extends MessageType<Expression_Literal_Map_KeyValue> {
    constructor() {
        super("substrait.Expression.Literal.Map.KeyValue", [
            { no: 1, name: "key", kind: "message", T: () => Expression_Literal },
            { no: 2, name: "value", kind: "message", T: () => Expression_Literal }
        ]);
    }
    create(value?: PartialMessage<Expression_Literal_Map_KeyValue>): Expression_Literal_Map_KeyValue {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Literal_Map_KeyValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Literal_Map_KeyValue): Expression_Literal_Map_KeyValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression.Literal key */ 1:
                    message.key = Expression_Literal.internalBinaryRead(reader, reader.uint32(), options, message.key);
                    break;
                case /* substrait.Expression.Literal value */ 2:
                    message.value = Expression_Literal.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_Literal_Map_KeyValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression.Literal key = 1; */
        if (message.key)
            Expression_Literal.internalBinaryWrite(message.key, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.Literal value = 2; */
        if (message.value)
            Expression_Literal.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Literal.Map.KeyValue
 */
export const Expression_Literal_Map_KeyValue = new Expression_Literal_Map_KeyValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Literal_IntervalYearToMonth$Type extends MessageType<Expression_Literal_IntervalYearToMonth> {
    constructor() {
        super("substrait.Expression.Literal.IntervalYearToMonth", [
            { no: 1, name: "years", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "months", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Expression_Literal_IntervalYearToMonth>): Expression_Literal_IntervalYearToMonth {
        const message = { years: 0, months: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Literal_IntervalYearToMonth>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Literal_IntervalYearToMonth): Expression_Literal_IntervalYearToMonth {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 years */ 1:
                    message.years = reader.int32();
                    break;
                case /* int32 months */ 2:
                    message.months = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_Literal_IntervalYearToMonth, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 years = 1; */
        if (message.years !== 0)
            writer.tag(1, WireType.Varint).int32(message.years);
        /* int32 months = 2; */
        if (message.months !== 0)
            writer.tag(2, WireType.Varint).int32(message.months);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Literal.IntervalYearToMonth
 */
export const Expression_Literal_IntervalYearToMonth = new Expression_Literal_IntervalYearToMonth$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Literal_IntervalDayToSecond$Type extends MessageType<Expression_Literal_IntervalDayToSecond> {
    constructor() {
        super("substrait.Expression.Literal.IntervalDayToSecond", [
            { no: 1, name: "days", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "seconds", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Expression_Literal_IntervalDayToSecond>): Expression_Literal_IntervalDayToSecond {
        const message = { days: 0, seconds: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Literal_IntervalDayToSecond>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Literal_IntervalDayToSecond): Expression_Literal_IntervalDayToSecond {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 days */ 1:
                    message.days = reader.int32();
                    break;
                case /* int32 seconds */ 2:
                    message.seconds = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_Literal_IntervalDayToSecond, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 days = 1; */
        if (message.days !== 0)
            writer.tag(1, WireType.Varint).int32(message.days);
        /* int32 seconds = 2; */
        if (message.seconds !== 0)
            writer.tag(2, WireType.Varint).int32(message.seconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Literal.IntervalDayToSecond
 */
export const Expression_Literal_IntervalDayToSecond = new Expression_Literal_IntervalDayToSecond$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Literal_Struct$Type extends MessageType<Expression_Literal_Struct> {
    constructor() {
        super("substrait.Expression.Literal.Struct", [
            { no: 1, name: "fields", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression_Literal }
        ]);
    }
    create(value?: PartialMessage<Expression_Literal_Struct>): Expression_Literal_Struct {
        const message = { fields: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Literal_Struct>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Literal_Struct): Expression_Literal_Struct {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.Expression.Literal fields */ 1:
                    message.fields.push(Expression_Literal.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_Literal_Struct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.Expression.Literal fields = 1; */
        for (let i = 0; i < message.fields.length; i++)
            Expression_Literal.internalBinaryWrite(message.fields[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Literal.Struct
 */
export const Expression_Literal_Struct = new Expression_Literal_Struct$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Literal_List$Type extends MessageType<Expression_Literal_List> {
    constructor() {
        super("substrait.Expression.Literal.List", [
            { no: 1, name: "values", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression_Literal }
        ]);
    }
    create(value?: PartialMessage<Expression_Literal_List>): Expression_Literal_List {
        const message = { values: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Literal_List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Literal_List): Expression_Literal_List {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.Expression.Literal values */ 1:
                    message.values.push(Expression_Literal.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_Literal_List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.Expression.Literal values = 1; */
        for (let i = 0; i < message.values.length; i++)
            Expression_Literal.internalBinaryWrite(message.values[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Literal.List
 */
export const Expression_Literal_List = new Expression_Literal_List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_ScalarFunction$Type extends MessageType<Expression_ScalarFunction> {
    constructor() {
        super("substrait.Expression.ScalarFunction", [
            { no: 1, name: "function_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "args", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression },
            { no: 3, name: "output_type", kind: "message", T: () => Type }
        ]);
    }
    create(value?: PartialMessage<Expression_ScalarFunction>): Expression_ScalarFunction {
        const message = { functionReference: 0, args: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_ScalarFunction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_ScalarFunction): Expression_ScalarFunction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 function_reference */ 1:
                    message.functionReference = reader.uint32();
                    break;
                case /* repeated substrait.Expression args */ 2:
                    message.args.push(Expression.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* substrait.Type output_type */ 3:
                    message.outputType = Type.internalBinaryRead(reader, reader.uint32(), options, message.outputType);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_ScalarFunction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 function_reference = 1; */
        if (message.functionReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.functionReference);
        /* repeated substrait.Expression args = 2; */
        for (let i = 0; i < message.args.length; i++)
            Expression.internalBinaryWrite(message.args[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type output_type = 3; */
        if (message.outputType)
            Type.internalBinaryWrite(message.outputType, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.ScalarFunction
 */
export const Expression_ScalarFunction = new Expression_ScalarFunction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_WindowFunction$Type extends MessageType<Expression_WindowFunction> {
    constructor() {
        super("substrait.Expression.WindowFunction", [
            { no: 1, name: "function_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "partitions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression },
            { no: 3, name: "sorts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SortField },
            { no: 4, name: "upper_bound", kind: "message", T: () => Expression_WindowFunction_Bound },
            { no: 5, name: "lower_bound", kind: "message", T: () => Expression_WindowFunction_Bound },
            { no: 6, name: "phase", kind: "enum", T: () => ["substrait.AggregationPhase", AggregationPhase, "AGGREGATION_PHASE_"] },
            { no: 7, name: "output_type", kind: "message", T: () => Type },
            { no: 8, name: "args", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression }
        ]);
    }
    create(value?: PartialMessage<Expression_WindowFunction>): Expression_WindowFunction {
        const message = { functionReference: 0, partitions: [], sorts: [], phase: 0, args: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_WindowFunction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_WindowFunction): Expression_WindowFunction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 function_reference */ 1:
                    message.functionReference = reader.uint32();
                    break;
                case /* repeated substrait.Expression partitions */ 2:
                    message.partitions.push(Expression.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated substrait.SortField sorts */ 3:
                    message.sorts.push(SortField.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* substrait.Expression.WindowFunction.Bound upper_bound */ 4:
                    message.upperBound = Expression_WindowFunction_Bound.internalBinaryRead(reader, reader.uint32(), options, message.upperBound);
                    break;
                case /* substrait.Expression.WindowFunction.Bound lower_bound */ 5:
                    message.lowerBound = Expression_WindowFunction_Bound.internalBinaryRead(reader, reader.uint32(), options, message.lowerBound);
                    break;
                case /* substrait.AggregationPhase phase */ 6:
                    message.phase = reader.int32();
                    break;
                case /* substrait.Type output_type */ 7:
                    message.outputType = Type.internalBinaryRead(reader, reader.uint32(), options, message.outputType);
                    break;
                case /* repeated substrait.Expression args */ 8:
                    message.args.push(Expression.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_WindowFunction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 function_reference = 1; */
        if (message.functionReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.functionReference);
        /* repeated substrait.Expression partitions = 2; */
        for (let i = 0; i < message.partitions.length; i++)
            Expression.internalBinaryWrite(message.partitions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated substrait.SortField sorts = 3; */
        for (let i = 0; i < message.sorts.length; i++)
            SortField.internalBinaryWrite(message.sorts[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.WindowFunction.Bound upper_bound = 4; */
        if (message.upperBound)
            Expression_WindowFunction_Bound.internalBinaryWrite(message.upperBound, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.WindowFunction.Bound lower_bound = 5; */
        if (message.lowerBound)
            Expression_WindowFunction_Bound.internalBinaryWrite(message.lowerBound, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* substrait.AggregationPhase phase = 6; */
        if (message.phase !== 0)
            writer.tag(6, WireType.Varint).int32(message.phase);
        /* substrait.Type output_type = 7; */
        if (message.outputType)
            Type.internalBinaryWrite(message.outputType, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated substrait.Expression args = 8; */
        for (let i = 0; i < message.args.length; i++)
            Expression.internalBinaryWrite(message.args[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.WindowFunction
 */
export const Expression_WindowFunction = new Expression_WindowFunction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_WindowFunction_Bound$Type extends MessageType<Expression_WindowFunction_Bound> {
    constructor() {
        super("substrait.Expression.WindowFunction.Bound", [
            { no: 1, name: "preceding", kind: "message", oneof: "kind", T: () => Expression_WindowFunction_Bound_Preceding },
            { no: 2, name: "following", kind: "message", oneof: "kind", T: () => Expression_WindowFunction_Bound_Following },
            { no: 3, name: "current_row", kind: "message", oneof: "kind", T: () => Expression_WindowFunction_Bound_CurrentRow },
            { no: 4, name: "unbounded", kind: "message", oneof: "kind", T: () => Expression_WindowFunction_Bound_Unbounded }
        ]);
    }
    create(value?: PartialMessage<Expression_WindowFunction_Bound>): Expression_WindowFunction_Bound {
        const message = { kind: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_WindowFunction_Bound>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_WindowFunction_Bound): Expression_WindowFunction_Bound {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression.WindowFunction.Bound.Preceding preceding */ 1:
                    message.kind = {
                        oneofKind: "preceding",
                        preceding: Expression_WindowFunction_Bound_Preceding.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).preceding)
                    };
                    break;
                case /* substrait.Expression.WindowFunction.Bound.Following following */ 2:
                    message.kind = {
                        oneofKind: "following",
                        following: Expression_WindowFunction_Bound_Following.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).following)
                    };
                    break;
                case /* substrait.Expression.WindowFunction.Bound.CurrentRow current_row */ 3:
                    message.kind = {
                        oneofKind: "currentRow",
                        currentRow: Expression_WindowFunction_Bound_CurrentRow.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).currentRow)
                    };
                    break;
                case /* substrait.Expression.WindowFunction.Bound.Unbounded unbounded */ 4:
                    message.kind = {
                        oneofKind: "unbounded",
                        unbounded: Expression_WindowFunction_Bound_Unbounded.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).unbounded)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_WindowFunction_Bound, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression.WindowFunction.Bound.Preceding preceding = 1; */
        if (message.kind.oneofKind === "preceding")
            Expression_WindowFunction_Bound_Preceding.internalBinaryWrite(message.kind.preceding, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.WindowFunction.Bound.Following following = 2; */
        if (message.kind.oneofKind === "following")
            Expression_WindowFunction_Bound_Following.internalBinaryWrite(message.kind.following, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.WindowFunction.Bound.CurrentRow current_row = 3; */
        if (message.kind.oneofKind === "currentRow")
            Expression_WindowFunction_Bound_CurrentRow.internalBinaryWrite(message.kind.currentRow, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.WindowFunction.Bound.Unbounded unbounded = 4; */
        if (message.kind.oneofKind === "unbounded")
            Expression_WindowFunction_Bound_Unbounded.internalBinaryWrite(message.kind.unbounded, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.WindowFunction.Bound
 */
export const Expression_WindowFunction_Bound = new Expression_WindowFunction_Bound$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_WindowFunction_Bound_Preceding$Type extends MessageType<Expression_WindowFunction_Bound_Preceding> {
    constructor() {
        super("substrait.Expression.WindowFunction.Bound.Preceding", [
            { no: 1, name: "offset", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Expression_WindowFunction_Bound_Preceding>): Expression_WindowFunction_Bound_Preceding {
        const message = { offset: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_WindowFunction_Bound_Preceding>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_WindowFunction_Bound_Preceding): Expression_WindowFunction_Bound_Preceding {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 offset */ 1:
                    message.offset = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_WindowFunction_Bound_Preceding, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 offset = 1; */
        if (message.offset !== 0n)
            writer.tag(1, WireType.Varint).int64(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.WindowFunction.Bound.Preceding
 */
export const Expression_WindowFunction_Bound_Preceding = new Expression_WindowFunction_Bound_Preceding$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_WindowFunction_Bound_Following$Type extends MessageType<Expression_WindowFunction_Bound_Following> {
    constructor() {
        super("substrait.Expression.WindowFunction.Bound.Following", [
            { no: 1, name: "offset", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Expression_WindowFunction_Bound_Following>): Expression_WindowFunction_Bound_Following {
        const message = { offset: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_WindowFunction_Bound_Following>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_WindowFunction_Bound_Following): Expression_WindowFunction_Bound_Following {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 offset */ 1:
                    message.offset = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_WindowFunction_Bound_Following, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 offset = 1; */
        if (message.offset !== 0n)
            writer.tag(1, WireType.Varint).int64(message.offset);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.WindowFunction.Bound.Following
 */
export const Expression_WindowFunction_Bound_Following = new Expression_WindowFunction_Bound_Following$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_WindowFunction_Bound_CurrentRow$Type extends MessageType<Expression_WindowFunction_Bound_CurrentRow> {
    constructor() {
        super("substrait.Expression.WindowFunction.Bound.CurrentRow", []);
    }
    create(value?: PartialMessage<Expression_WindowFunction_Bound_CurrentRow>): Expression_WindowFunction_Bound_CurrentRow {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_WindowFunction_Bound_CurrentRow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_WindowFunction_Bound_CurrentRow): Expression_WindowFunction_Bound_CurrentRow {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Expression_WindowFunction_Bound_CurrentRow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.WindowFunction.Bound.CurrentRow
 */
export const Expression_WindowFunction_Bound_CurrentRow = new Expression_WindowFunction_Bound_CurrentRow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_WindowFunction_Bound_Unbounded$Type extends MessageType<Expression_WindowFunction_Bound_Unbounded> {
    constructor() {
        super("substrait.Expression.WindowFunction.Bound.Unbounded", []);
    }
    create(value?: PartialMessage<Expression_WindowFunction_Bound_Unbounded>): Expression_WindowFunction_Bound_Unbounded {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_WindowFunction_Bound_Unbounded>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_WindowFunction_Bound_Unbounded): Expression_WindowFunction_Bound_Unbounded {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Expression_WindowFunction_Bound_Unbounded, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.WindowFunction.Bound.Unbounded
 */
export const Expression_WindowFunction_Bound_Unbounded = new Expression_WindowFunction_Bound_Unbounded$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_IfThen$Type extends MessageType<Expression_IfThen> {
    constructor() {
        super("substrait.Expression.IfThen", [
            { no: 1, name: "ifs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression_IfThen_IfClause },
            { no: 2, name: "else", kind: "message", T: () => Expression }
        ]);
    }
    create(value?: PartialMessage<Expression_IfThen>): Expression_IfThen {
        const message = { ifs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_IfThen>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_IfThen): Expression_IfThen {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.Expression.IfThen.IfClause ifs */ 1:
                    message.ifs.push(Expression_IfThen_IfClause.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* substrait.Expression else */ 2:
                    message.else = Expression.internalBinaryRead(reader, reader.uint32(), options, message.else);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_IfThen, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.Expression.IfThen.IfClause ifs = 1; */
        for (let i = 0; i < message.ifs.length; i++)
            Expression_IfThen_IfClause.internalBinaryWrite(message.ifs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression else = 2; */
        if (message.else)
            Expression.internalBinaryWrite(message.else, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.IfThen
 */
export const Expression_IfThen = new Expression_IfThen$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_IfThen_IfClause$Type extends MessageType<Expression_IfThen_IfClause> {
    constructor() {
        super("substrait.Expression.IfThen.IfClause", [
            { no: 1, name: "if", kind: "message", T: () => Expression },
            { no: 2, name: "then", kind: "message", T: () => Expression }
        ]);
    }
    create(value?: PartialMessage<Expression_IfThen_IfClause>): Expression_IfThen_IfClause {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_IfThen_IfClause>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_IfThen_IfClause): Expression_IfThen_IfClause {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression if */ 1:
                    message.if = Expression.internalBinaryRead(reader, reader.uint32(), options, message.if);
                    break;
                case /* substrait.Expression then */ 2:
                    message.then = Expression.internalBinaryRead(reader, reader.uint32(), options, message.then);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_IfThen_IfClause, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression if = 1; */
        if (message.if)
            Expression.internalBinaryWrite(message.if, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression then = 2; */
        if (message.then)
            Expression.internalBinaryWrite(message.then, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.IfThen.IfClause
 */
export const Expression_IfThen_IfClause = new Expression_IfThen_IfClause$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Cast$Type extends MessageType<Expression_Cast> {
    constructor() {
        super("substrait.Expression.Cast", [
            { no: 1, name: "type", kind: "message", T: () => Type },
            { no: 2, name: "input", kind: "message", T: () => Expression }
        ]);
    }
    create(value?: PartialMessage<Expression_Cast>): Expression_Cast {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Cast>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Cast): Expression_Cast {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Type type */ 1:
                    message.type = Type.internalBinaryRead(reader, reader.uint32(), options, message.type);
                    break;
                case /* substrait.Expression input */ 2:
                    message.input = Expression.internalBinaryRead(reader, reader.uint32(), options, message.input);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_Cast, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Type type = 1; */
        if (message.type)
            Type.internalBinaryWrite(message.type, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression input = 2; */
        if (message.input)
            Expression.internalBinaryWrite(message.input, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Cast
 */
export const Expression_Cast = new Expression_Cast$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_SwitchExpression$Type extends MessageType<Expression_SwitchExpression> {
    constructor() {
        super("substrait.Expression.SwitchExpression", [
            { no: 1, name: "ifs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression_SwitchExpression_IfValue },
            { no: 2, name: "else", kind: "message", T: () => Expression }
        ]);
    }
    create(value?: PartialMessage<Expression_SwitchExpression>): Expression_SwitchExpression {
        const message = { ifs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_SwitchExpression>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_SwitchExpression): Expression_SwitchExpression {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.Expression.SwitchExpression.IfValue ifs */ 1:
                    message.ifs.push(Expression_SwitchExpression_IfValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* substrait.Expression else */ 2:
                    message.else = Expression.internalBinaryRead(reader, reader.uint32(), options, message.else);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_SwitchExpression, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.Expression.SwitchExpression.IfValue ifs = 1; */
        for (let i = 0; i < message.ifs.length; i++)
            Expression_SwitchExpression_IfValue.internalBinaryWrite(message.ifs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression else = 2; */
        if (message.else)
            Expression.internalBinaryWrite(message.else, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.SwitchExpression
 */
export const Expression_SwitchExpression = new Expression_SwitchExpression$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_SwitchExpression_IfValue$Type extends MessageType<Expression_SwitchExpression_IfValue> {
    constructor() {
        super("substrait.Expression.SwitchExpression.IfValue", [
            { no: 1, name: "if", kind: "message", T: () => Expression_Literal },
            { no: 2, name: "then", kind: "message", T: () => Expression }
        ]);
    }
    create(value?: PartialMessage<Expression_SwitchExpression_IfValue>): Expression_SwitchExpression_IfValue {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_SwitchExpression_IfValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_SwitchExpression_IfValue): Expression_SwitchExpression_IfValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression.Literal if */ 1:
                    message.if = Expression_Literal.internalBinaryRead(reader, reader.uint32(), options, message.if);
                    break;
                case /* substrait.Expression then */ 2:
                    message.then = Expression.internalBinaryRead(reader, reader.uint32(), options, message.then);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_SwitchExpression_IfValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression.Literal if = 1; */
        if (message.if)
            Expression_Literal.internalBinaryWrite(message.if, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression then = 2; */
        if (message.then)
            Expression.internalBinaryWrite(message.then, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.SwitchExpression.IfValue
 */
export const Expression_SwitchExpression_IfValue = new Expression_SwitchExpression_IfValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_SingularOrList$Type extends MessageType<Expression_SingularOrList> {
    constructor() {
        super("substrait.Expression.SingularOrList", [
            { no: 1, name: "value", kind: "message", T: () => Expression },
            { no: 2, name: "options", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression }
        ]);
    }
    create(value?: PartialMessage<Expression_SingularOrList>): Expression_SingularOrList {
        const message = { options: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_SingularOrList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_SingularOrList): Expression_SingularOrList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression value */ 1:
                    message.value = Expression.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* repeated substrait.Expression options */ 2:
                    message.options.push(Expression.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_SingularOrList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression value = 1; */
        if (message.value)
            Expression.internalBinaryWrite(message.value, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated substrait.Expression options = 2; */
        for (let i = 0; i < message.options.length; i++)
            Expression.internalBinaryWrite(message.options[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.SingularOrList
 */
export const Expression_SingularOrList = new Expression_SingularOrList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_MultiOrList$Type extends MessageType<Expression_MultiOrList> {
    constructor() {
        super("substrait.Expression.MultiOrList", [
            { no: 1, name: "value", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression },
            { no: 2, name: "options", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression_MultiOrList_Record }
        ]);
    }
    create(value?: PartialMessage<Expression_MultiOrList>): Expression_MultiOrList {
        const message = { value: [], options: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_MultiOrList>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_MultiOrList): Expression_MultiOrList {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.Expression value */ 1:
                    message.value.push(Expression.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated substrait.Expression.MultiOrList.Record options */ 2:
                    message.options.push(Expression_MultiOrList_Record.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_MultiOrList, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.Expression value = 1; */
        for (let i = 0; i < message.value.length; i++)
            Expression.internalBinaryWrite(message.value[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated substrait.Expression.MultiOrList.Record options = 2; */
        for (let i = 0; i < message.options.length; i++)
            Expression_MultiOrList_Record.internalBinaryWrite(message.options[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.MultiOrList
 */
export const Expression_MultiOrList = new Expression_MultiOrList$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_MultiOrList_Record$Type extends MessageType<Expression_MultiOrList_Record> {
    constructor() {
        super("substrait.Expression.MultiOrList.Record", [
            { no: 1, name: "fields", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression }
        ]);
    }
    create(value?: PartialMessage<Expression_MultiOrList_Record>): Expression_MultiOrList_Record {
        const message = { fields: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_MultiOrList_Record>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_MultiOrList_Record): Expression_MultiOrList_Record {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.Expression fields */ 1:
                    message.fields.push(Expression.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_MultiOrList_Record, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.Expression fields = 1; */
        for (let i = 0; i < message.fields.length; i++)
            Expression.internalBinaryWrite(message.fields[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.MultiOrList.Record
 */
export const Expression_MultiOrList_Record = new Expression_MultiOrList_Record$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_EmbeddedFunction$Type extends MessageType<Expression_EmbeddedFunction> {
    constructor() {
        super("substrait.Expression.EmbeddedFunction", [
            { no: 1, name: "arguments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression },
            { no: 2, name: "output_type", kind: "message", T: () => Type },
            { no: 3, name: "python_pickle_function", kind: "message", oneof: "kind", T: () => Expression_EmbeddedFunction_PythonPickleFunction },
            { no: 4, name: "web_assembly_function", kind: "message", oneof: "kind", T: () => Expression_EmbeddedFunction_WebAssemblyFunction }
        ]);
    }
    create(value?: PartialMessage<Expression_EmbeddedFunction>): Expression_EmbeddedFunction {
        const message = { arguments: [], kind: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_EmbeddedFunction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_EmbeddedFunction): Expression_EmbeddedFunction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.Expression arguments */ 1:
                    message.arguments.push(Expression.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* substrait.Type output_type */ 2:
                    message.outputType = Type.internalBinaryRead(reader, reader.uint32(), options, message.outputType);
                    break;
                case /* substrait.Expression.EmbeddedFunction.PythonPickleFunction python_pickle_function */ 3:
                    message.kind = {
                        oneofKind: "pythonPickleFunction",
                        pythonPickleFunction: Expression_EmbeddedFunction_PythonPickleFunction.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).pythonPickleFunction)
                    };
                    break;
                case /* substrait.Expression.EmbeddedFunction.WebAssemblyFunction web_assembly_function */ 4:
                    message.kind = {
                        oneofKind: "webAssemblyFunction",
                        webAssemblyFunction: Expression_EmbeddedFunction_WebAssemblyFunction.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).webAssemblyFunction)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_EmbeddedFunction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.Expression arguments = 1; */
        for (let i = 0; i < message.arguments.length; i++)
            Expression.internalBinaryWrite(message.arguments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type output_type = 2; */
        if (message.outputType)
            Type.internalBinaryWrite(message.outputType, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.EmbeddedFunction.PythonPickleFunction python_pickle_function = 3; */
        if (message.kind.oneofKind === "pythonPickleFunction")
            Expression_EmbeddedFunction_PythonPickleFunction.internalBinaryWrite(message.kind.pythonPickleFunction, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.EmbeddedFunction.WebAssemblyFunction web_assembly_function = 4; */
        if (message.kind.oneofKind === "webAssemblyFunction")
            Expression_EmbeddedFunction_WebAssemblyFunction.internalBinaryWrite(message.kind.webAssemblyFunction, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.EmbeddedFunction
 */
export const Expression_EmbeddedFunction = new Expression_EmbeddedFunction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_EmbeddedFunction_PythonPickleFunction$Type extends MessageType<Expression_EmbeddedFunction_PythonPickleFunction> {
    constructor() {
        super("substrait.Expression.EmbeddedFunction.PythonPickleFunction", [
            { no: 1, name: "function", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "prerequisite", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Expression_EmbeddedFunction_PythonPickleFunction>): Expression_EmbeddedFunction_PythonPickleFunction {
        const message = { function: new Uint8Array(0), prerequisite: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_EmbeddedFunction_PythonPickleFunction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_EmbeddedFunction_PythonPickleFunction): Expression_EmbeddedFunction_PythonPickleFunction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes function */ 1:
                    message.function = reader.bytes();
                    break;
                case /* repeated string prerequisite */ 2:
                    message.prerequisite.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_EmbeddedFunction_PythonPickleFunction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes function = 1; */
        if (message.function.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.function);
        /* repeated string prerequisite = 2; */
        for (let i = 0; i < message.prerequisite.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.prerequisite[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.EmbeddedFunction.PythonPickleFunction
 */
export const Expression_EmbeddedFunction_PythonPickleFunction = new Expression_EmbeddedFunction_PythonPickleFunction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_EmbeddedFunction_WebAssemblyFunction$Type extends MessageType<Expression_EmbeddedFunction_WebAssemblyFunction> {
    constructor() {
        super("substrait.Expression.EmbeddedFunction.WebAssemblyFunction", [
            { no: 1, name: "script", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 2, name: "prerequisite", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Expression_EmbeddedFunction_WebAssemblyFunction>): Expression_EmbeddedFunction_WebAssemblyFunction {
        const message = { script: new Uint8Array(0), prerequisite: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_EmbeddedFunction_WebAssemblyFunction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_EmbeddedFunction_WebAssemblyFunction): Expression_EmbeddedFunction_WebAssemblyFunction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bytes script */ 1:
                    message.script = reader.bytes();
                    break;
                case /* repeated string prerequisite */ 2:
                    message.prerequisite.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_EmbeddedFunction_WebAssemblyFunction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bytes script = 1; */
        if (message.script.length)
            writer.tag(1, WireType.LengthDelimited).bytes(message.script);
        /* repeated string prerequisite = 2; */
        for (let i = 0; i < message.prerequisite.length; i++)
            writer.tag(2, WireType.LengthDelimited).string(message.prerequisite[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.EmbeddedFunction.WebAssemblyFunction
 */
export const Expression_EmbeddedFunction_WebAssemblyFunction = new Expression_EmbeddedFunction_WebAssemblyFunction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_ReferenceSegment$Type extends MessageType<Expression_ReferenceSegment> {
    constructor() {
        super("substrait.Expression.ReferenceSegment", [
            { no: 1, name: "map_key", kind: "message", oneof: "referenceType", T: () => Expression_ReferenceSegment_MapKey },
            { no: 2, name: "struct_field", kind: "message", oneof: "referenceType", T: () => Expression_ReferenceSegment_StructField },
            { no: 3, name: "list_element", kind: "message", oneof: "referenceType", T: () => Expression_ReferenceSegment_ListElement }
        ]);
    }
    create(value?: PartialMessage<Expression_ReferenceSegment>): Expression_ReferenceSegment {
        const message = { referenceType: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_ReferenceSegment>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_ReferenceSegment): Expression_ReferenceSegment {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression.ReferenceSegment.MapKey map_key */ 1:
                    message.referenceType = {
                        oneofKind: "mapKey",
                        mapKey: Expression_ReferenceSegment_MapKey.internalBinaryRead(reader, reader.uint32(), options, (message.referenceType as any).mapKey)
                    };
                    break;
                case /* substrait.Expression.ReferenceSegment.StructField struct_field */ 2:
                    message.referenceType = {
                        oneofKind: "structField",
                        structField: Expression_ReferenceSegment_StructField.internalBinaryRead(reader, reader.uint32(), options, (message.referenceType as any).structField)
                    };
                    break;
                case /* substrait.Expression.ReferenceSegment.ListElement list_element */ 3:
                    message.referenceType = {
                        oneofKind: "listElement",
                        listElement: Expression_ReferenceSegment_ListElement.internalBinaryRead(reader, reader.uint32(), options, (message.referenceType as any).listElement)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_ReferenceSegment, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression.ReferenceSegment.MapKey map_key = 1; */
        if (message.referenceType.oneofKind === "mapKey")
            Expression_ReferenceSegment_MapKey.internalBinaryWrite(message.referenceType.mapKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.ReferenceSegment.StructField struct_field = 2; */
        if (message.referenceType.oneofKind === "structField")
            Expression_ReferenceSegment_StructField.internalBinaryWrite(message.referenceType.structField, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.ReferenceSegment.ListElement list_element = 3; */
        if (message.referenceType.oneofKind === "listElement")
            Expression_ReferenceSegment_ListElement.internalBinaryWrite(message.referenceType.listElement, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.ReferenceSegment
 */
export const Expression_ReferenceSegment = new Expression_ReferenceSegment$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_ReferenceSegment_MapKey$Type extends MessageType<Expression_ReferenceSegment_MapKey> {
    constructor() {
        super("substrait.Expression.ReferenceSegment.MapKey", [
            { no: 1, name: "map_key", kind: "message", T: () => Expression_Literal },
            { no: 2, name: "child", kind: "message", T: () => Expression_ReferenceSegment }
        ]);
    }
    create(value?: PartialMessage<Expression_ReferenceSegment_MapKey>): Expression_ReferenceSegment_MapKey {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_ReferenceSegment_MapKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_ReferenceSegment_MapKey): Expression_ReferenceSegment_MapKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression.Literal map_key */ 1:
                    message.mapKey = Expression_Literal.internalBinaryRead(reader, reader.uint32(), options, message.mapKey);
                    break;
                case /* substrait.Expression.ReferenceSegment child */ 2:
                    message.child = Expression_ReferenceSegment.internalBinaryRead(reader, reader.uint32(), options, message.child);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_ReferenceSegment_MapKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression.Literal map_key = 1; */
        if (message.mapKey)
            Expression_Literal.internalBinaryWrite(message.mapKey, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.ReferenceSegment child = 2; */
        if (message.child)
            Expression_ReferenceSegment.internalBinaryWrite(message.child, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.ReferenceSegment.MapKey
 */
export const Expression_ReferenceSegment_MapKey = new Expression_ReferenceSegment_MapKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_ReferenceSegment_StructField$Type extends MessageType<Expression_ReferenceSegment_StructField> {
    constructor() {
        super("substrait.Expression.ReferenceSegment.StructField", [
            { no: 1, name: "field", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "child", kind: "message", T: () => Expression_ReferenceSegment }
        ]);
    }
    create(value?: PartialMessage<Expression_ReferenceSegment_StructField>): Expression_ReferenceSegment_StructField {
        const message = { field: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_ReferenceSegment_StructField>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_ReferenceSegment_StructField): Expression_ReferenceSegment_StructField {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 field */ 1:
                    message.field = reader.int32();
                    break;
                case /* substrait.Expression.ReferenceSegment child */ 2:
                    message.child = Expression_ReferenceSegment.internalBinaryRead(reader, reader.uint32(), options, message.child);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_ReferenceSegment_StructField, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 field = 1; */
        if (message.field !== 0)
            writer.tag(1, WireType.Varint).int32(message.field);
        /* substrait.Expression.ReferenceSegment child = 2; */
        if (message.child)
            Expression_ReferenceSegment.internalBinaryWrite(message.child, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.ReferenceSegment.StructField
 */
export const Expression_ReferenceSegment_StructField = new Expression_ReferenceSegment_StructField$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_ReferenceSegment_ListElement$Type extends MessageType<Expression_ReferenceSegment_ListElement> {
    constructor() {
        super("substrait.Expression.ReferenceSegment.ListElement", [
            { no: 1, name: "offset", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "child", kind: "message", T: () => Expression_ReferenceSegment }
        ]);
    }
    create(value?: PartialMessage<Expression_ReferenceSegment_ListElement>): Expression_ReferenceSegment_ListElement {
        const message = { offset: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_ReferenceSegment_ListElement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_ReferenceSegment_ListElement): Expression_ReferenceSegment_ListElement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 offset */ 1:
                    message.offset = reader.int32();
                    break;
                case /* substrait.Expression.ReferenceSegment child */ 2:
                    message.child = Expression_ReferenceSegment.internalBinaryRead(reader, reader.uint32(), options, message.child);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_ReferenceSegment_ListElement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 offset = 1; */
        if (message.offset !== 0)
            writer.tag(1, WireType.Varint).int32(message.offset);
        /* substrait.Expression.ReferenceSegment child = 2; */
        if (message.child)
            Expression_ReferenceSegment.internalBinaryWrite(message.child, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.ReferenceSegment.ListElement
 */
export const Expression_ReferenceSegment_ListElement = new Expression_ReferenceSegment_ListElement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_MaskExpression$Type extends MessageType<Expression_MaskExpression> {
    constructor() {
        super("substrait.Expression.MaskExpression", [
            { no: 1, name: "select", kind: "message", T: () => Expression_MaskExpression_StructSelect },
            { no: 2, name: "maintain_singular_struct", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Expression_MaskExpression>): Expression_MaskExpression {
        const message = { maintainSingularStruct: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_MaskExpression>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_MaskExpression): Expression_MaskExpression {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression.MaskExpression.StructSelect select */ 1:
                    message.select = Expression_MaskExpression_StructSelect.internalBinaryRead(reader, reader.uint32(), options, message.select);
                    break;
                case /* bool maintain_singular_struct */ 2:
                    message.maintainSingularStruct = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_MaskExpression, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression.MaskExpression.StructSelect select = 1; */
        if (message.select)
            Expression_MaskExpression_StructSelect.internalBinaryWrite(message.select, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool maintain_singular_struct = 2; */
        if (message.maintainSingularStruct !== false)
            writer.tag(2, WireType.Varint).bool(message.maintainSingularStruct);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.MaskExpression
 */
export const Expression_MaskExpression = new Expression_MaskExpression$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_MaskExpression_Select$Type extends MessageType<Expression_MaskExpression_Select> {
    constructor() {
        super("substrait.Expression.MaskExpression.Select", [
            { no: 1, name: "struct", kind: "message", oneof: "type", T: () => Expression_MaskExpression_StructSelect },
            { no: 2, name: "list", kind: "message", oneof: "type", T: () => Expression_MaskExpression_ListSelect },
            { no: 3, name: "map", kind: "message", oneof: "type", T: () => Expression_MaskExpression_MapSelect }
        ]);
    }
    create(value?: PartialMessage<Expression_MaskExpression_Select>): Expression_MaskExpression_Select {
        const message = { type: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_MaskExpression_Select>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_MaskExpression_Select): Expression_MaskExpression_Select {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression.MaskExpression.StructSelect struct */ 1:
                    message.type = {
                        oneofKind: "struct",
                        struct: Expression_MaskExpression_StructSelect.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).struct)
                    };
                    break;
                case /* substrait.Expression.MaskExpression.ListSelect list */ 2:
                    message.type = {
                        oneofKind: "list",
                        list: Expression_MaskExpression_ListSelect.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).list)
                    };
                    break;
                case /* substrait.Expression.MaskExpression.MapSelect map */ 3:
                    message.type = {
                        oneofKind: "map",
                        map: Expression_MaskExpression_MapSelect.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).map)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_MaskExpression_Select, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression.MaskExpression.StructSelect struct = 1; */
        if (message.type.oneofKind === "struct")
            Expression_MaskExpression_StructSelect.internalBinaryWrite(message.type.struct, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.MaskExpression.ListSelect list = 2; */
        if (message.type.oneofKind === "list")
            Expression_MaskExpression_ListSelect.internalBinaryWrite(message.type.list, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.MaskExpression.MapSelect map = 3; */
        if (message.type.oneofKind === "map")
            Expression_MaskExpression_MapSelect.internalBinaryWrite(message.type.map, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.MaskExpression.Select
 */
export const Expression_MaskExpression_Select = new Expression_MaskExpression_Select$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_MaskExpression_StructSelect$Type extends MessageType<Expression_MaskExpression_StructSelect> {
    constructor() {
        super("substrait.Expression.MaskExpression.StructSelect", [
            { no: 1, name: "struct_items", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression_MaskExpression_StructItem }
        ]);
    }
    create(value?: PartialMessage<Expression_MaskExpression_StructSelect>): Expression_MaskExpression_StructSelect {
        const message = { structItems: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_MaskExpression_StructSelect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_MaskExpression_StructSelect): Expression_MaskExpression_StructSelect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.Expression.MaskExpression.StructItem struct_items */ 1:
                    message.structItems.push(Expression_MaskExpression_StructItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_MaskExpression_StructSelect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.Expression.MaskExpression.StructItem struct_items = 1; */
        for (let i = 0; i < message.structItems.length; i++)
            Expression_MaskExpression_StructItem.internalBinaryWrite(message.structItems[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.MaskExpression.StructSelect
 */
export const Expression_MaskExpression_StructSelect = new Expression_MaskExpression_StructSelect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_MaskExpression_StructItem$Type extends MessageType<Expression_MaskExpression_StructItem> {
    constructor() {
        super("substrait.Expression.MaskExpression.StructItem", [
            { no: 1, name: "field", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "child", kind: "message", T: () => Expression_MaskExpression_Select }
        ]);
    }
    create(value?: PartialMessage<Expression_MaskExpression_StructItem>): Expression_MaskExpression_StructItem {
        const message = { field: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_MaskExpression_StructItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_MaskExpression_StructItem): Expression_MaskExpression_StructItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 field */ 1:
                    message.field = reader.int32();
                    break;
                case /* substrait.Expression.MaskExpression.Select child */ 2:
                    message.child = Expression_MaskExpression_Select.internalBinaryRead(reader, reader.uint32(), options, message.child);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_MaskExpression_StructItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 field = 1; */
        if (message.field !== 0)
            writer.tag(1, WireType.Varint).int32(message.field);
        /* substrait.Expression.MaskExpression.Select child = 2; */
        if (message.child)
            Expression_MaskExpression_Select.internalBinaryWrite(message.child, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.MaskExpression.StructItem
 */
export const Expression_MaskExpression_StructItem = new Expression_MaskExpression_StructItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_MaskExpression_ListSelect$Type extends MessageType<Expression_MaskExpression_ListSelect> {
    constructor() {
        super("substrait.Expression.MaskExpression.ListSelect", [
            { no: 1, name: "selection", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression_MaskExpression_ListSelect_ListSelectItem },
            { no: 2, name: "child", kind: "message", T: () => Expression_MaskExpression_Select }
        ]);
    }
    create(value?: PartialMessage<Expression_MaskExpression_ListSelect>): Expression_MaskExpression_ListSelect {
        const message = { selection: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_MaskExpression_ListSelect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_MaskExpression_ListSelect): Expression_MaskExpression_ListSelect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.Expression.MaskExpression.ListSelect.ListSelectItem selection */ 1:
                    message.selection.push(Expression_MaskExpression_ListSelect_ListSelectItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* substrait.Expression.MaskExpression.Select child */ 2:
                    message.child = Expression_MaskExpression_Select.internalBinaryRead(reader, reader.uint32(), options, message.child);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_MaskExpression_ListSelect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.Expression.MaskExpression.ListSelect.ListSelectItem selection = 1; */
        for (let i = 0; i < message.selection.length; i++)
            Expression_MaskExpression_ListSelect_ListSelectItem.internalBinaryWrite(message.selection[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.MaskExpression.Select child = 2; */
        if (message.child)
            Expression_MaskExpression_Select.internalBinaryWrite(message.child, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.MaskExpression.ListSelect
 */
export const Expression_MaskExpression_ListSelect = new Expression_MaskExpression_ListSelect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_MaskExpression_ListSelect_ListSelectItem$Type extends MessageType<Expression_MaskExpression_ListSelect_ListSelectItem> {
    constructor() {
        super("substrait.Expression.MaskExpression.ListSelect.ListSelectItem", [
            { no: 1, name: "item", kind: "message", oneof: "type", T: () => Expression_MaskExpression_ListSelect_ListSelectItem_ListElement },
            { no: 2, name: "slice", kind: "message", oneof: "type", T: () => Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice }
        ]);
    }
    create(value?: PartialMessage<Expression_MaskExpression_ListSelect_ListSelectItem>): Expression_MaskExpression_ListSelect_ListSelectItem {
        const message = { type: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_MaskExpression_ListSelect_ListSelectItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_MaskExpression_ListSelect_ListSelectItem): Expression_MaskExpression_ListSelect_ListSelectItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement item */ 1:
                    message.type = {
                        oneofKind: "item",
                        item: Expression_MaskExpression_ListSelect_ListSelectItem_ListElement.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).item)
                    };
                    break;
                case /* substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice slice */ 2:
                    message.type = {
                        oneofKind: "slice",
                        slice: Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice.internalBinaryRead(reader, reader.uint32(), options, (message.type as any).slice)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_MaskExpression_ListSelect_ListSelectItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement item = 1; */
        if (message.type.oneofKind === "item")
            Expression_MaskExpression_ListSelect_ListSelectItem_ListElement.internalBinaryWrite(message.type.item, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice slice = 2; */
        if (message.type.oneofKind === "slice")
            Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice.internalBinaryWrite(message.type.slice, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.MaskExpression.ListSelect.ListSelectItem
 */
export const Expression_MaskExpression_ListSelect_ListSelectItem = new Expression_MaskExpression_ListSelect_ListSelectItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_MaskExpression_ListSelect_ListSelectItem_ListElement$Type extends MessageType<Expression_MaskExpression_ListSelect_ListSelectItem_ListElement> {
    constructor() {
        super("substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement", [
            { no: 1, name: "field", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Expression_MaskExpression_ListSelect_ListSelectItem_ListElement>): Expression_MaskExpression_ListSelect_ListSelectItem_ListElement {
        const message = { field: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_MaskExpression_ListSelect_ListSelectItem_ListElement>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_MaskExpression_ListSelect_ListSelectItem_ListElement): Expression_MaskExpression_ListSelect_ListSelectItem_ListElement {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 field */ 1:
                    message.field = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_MaskExpression_ListSelect_ListSelectItem_ListElement, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 field = 1; */
        if (message.field !== 0)
            writer.tag(1, WireType.Varint).int32(message.field);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListElement
 */
export const Expression_MaskExpression_ListSelect_ListSelectItem_ListElement = new Expression_MaskExpression_ListSelect_ListSelectItem_ListElement$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice$Type extends MessageType<Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice> {
    constructor() {
        super("substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice", [
            { no: 1, name: "start", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "end", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice>): Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice {
        const message = { start: 0, end: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice): Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 start */ 1:
                    message.start = reader.int32();
                    break;
                case /* int32 end */ 2:
                    message.end = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 start = 1; */
        if (message.start !== 0)
            writer.tag(1, WireType.Varint).int32(message.start);
        /* int32 end = 2; */
        if (message.end !== 0)
            writer.tag(2, WireType.Varint).int32(message.end);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.MaskExpression.ListSelect.ListSelectItem.ListSlice
 */
export const Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice = new Expression_MaskExpression_ListSelect_ListSelectItem_ListSlice$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_MaskExpression_MapSelect$Type extends MessageType<Expression_MaskExpression_MapSelect> {
    constructor() {
        super("substrait.Expression.MaskExpression.MapSelect", [
            { no: 1, name: "key", kind: "message", oneof: "select", T: () => Expression_MaskExpression_MapSelect_MapKey },
            { no: 2, name: "expression", kind: "message", oneof: "select", T: () => Expression_MaskExpression_MapSelect_MapKeyExpression },
            { no: 3, name: "child", kind: "message", T: () => Expression_MaskExpression_Select }
        ]);
    }
    create(value?: PartialMessage<Expression_MaskExpression_MapSelect>): Expression_MaskExpression_MapSelect {
        const message = { select: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_MaskExpression_MapSelect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_MaskExpression_MapSelect): Expression_MaskExpression_MapSelect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression.MaskExpression.MapSelect.MapKey key */ 1:
                    message.select = {
                        oneofKind: "key",
                        key: Expression_MaskExpression_MapSelect_MapKey.internalBinaryRead(reader, reader.uint32(), options, (message.select as any).key)
                    };
                    break;
                case /* substrait.Expression.MaskExpression.MapSelect.MapKeyExpression expression */ 2:
                    message.select = {
                        oneofKind: "expression",
                        expression: Expression_MaskExpression_MapSelect_MapKeyExpression.internalBinaryRead(reader, reader.uint32(), options, (message.select as any).expression)
                    };
                    break;
                case /* substrait.Expression.MaskExpression.Select child */ 3:
                    message.child = Expression_MaskExpression_Select.internalBinaryRead(reader, reader.uint32(), options, message.child);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_MaskExpression_MapSelect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression.MaskExpression.MapSelect.MapKey key = 1; */
        if (message.select.oneofKind === "key")
            Expression_MaskExpression_MapSelect_MapKey.internalBinaryWrite(message.select.key, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.MaskExpression.MapSelect.MapKeyExpression expression = 2; */
        if (message.select.oneofKind === "expression")
            Expression_MaskExpression_MapSelect_MapKeyExpression.internalBinaryWrite(message.select.expression, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.MaskExpression.Select child = 3; */
        if (message.child)
            Expression_MaskExpression_Select.internalBinaryWrite(message.child, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.MaskExpression.MapSelect
 */
export const Expression_MaskExpression_MapSelect = new Expression_MaskExpression_MapSelect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_MaskExpression_MapSelect_MapKey$Type extends MessageType<Expression_MaskExpression_MapSelect_MapKey> {
    constructor() {
        super("substrait.Expression.MaskExpression.MapSelect.MapKey", [
            { no: 1, name: "map_key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Expression_MaskExpression_MapSelect_MapKey>): Expression_MaskExpression_MapSelect_MapKey {
        const message = { mapKey: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_MaskExpression_MapSelect_MapKey>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_MaskExpression_MapSelect_MapKey): Expression_MaskExpression_MapSelect_MapKey {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string map_key */ 1:
                    message.mapKey = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_MaskExpression_MapSelect_MapKey, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string map_key = 1; */
        if (message.mapKey !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mapKey);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.MaskExpression.MapSelect.MapKey
 */
export const Expression_MaskExpression_MapSelect_MapKey = new Expression_MaskExpression_MapSelect_MapKey$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_MaskExpression_MapSelect_MapKeyExpression$Type extends MessageType<Expression_MaskExpression_MapSelect_MapKeyExpression> {
    constructor() {
        super("substrait.Expression.MaskExpression.MapSelect.MapKeyExpression", [
            { no: 1, name: "map_key_expression", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Expression_MaskExpression_MapSelect_MapKeyExpression>): Expression_MaskExpression_MapSelect_MapKeyExpression {
        const message = { mapKeyExpression: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_MaskExpression_MapSelect_MapKeyExpression>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_MaskExpression_MapSelect_MapKeyExpression): Expression_MaskExpression_MapSelect_MapKeyExpression {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string map_key_expression */ 1:
                    message.mapKeyExpression = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_MaskExpression_MapSelect_MapKeyExpression, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string map_key_expression = 1; */
        if (message.mapKeyExpression !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mapKeyExpression);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.MaskExpression.MapSelect.MapKeyExpression
 */
export const Expression_MaskExpression_MapSelect_MapKeyExpression = new Expression_MaskExpression_MapSelect_MapKeyExpression$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_FieldReference$Type extends MessageType<Expression_FieldReference> {
    constructor() {
        super("substrait.Expression.FieldReference", [
            { no: 1, name: "direct_reference", kind: "message", oneof: "referenceType", T: () => Expression_ReferenceSegment },
            { no: 2, name: "masked_reference", kind: "message", oneof: "referenceType", T: () => Expression_MaskExpression },
            { no: 3, name: "expression", kind: "message", oneof: "rootType", T: () => Expression },
            { no: 4, name: "root_reference", kind: "message", oneof: "rootType", T: () => Expression_FieldReference_RootReference },
            { no: 5, name: "outer_reference", kind: "message", oneof: "rootType", T: () => Expression_FieldReference_OuterReference }
        ]);
    }
    create(value?: PartialMessage<Expression_FieldReference>): Expression_FieldReference {
        const message = { referenceType: { oneofKind: undefined }, rootType: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_FieldReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_FieldReference): Expression_FieldReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression.ReferenceSegment direct_reference */ 1:
                    message.referenceType = {
                        oneofKind: "directReference",
                        directReference: Expression_ReferenceSegment.internalBinaryRead(reader, reader.uint32(), options, (message.referenceType as any).directReference)
                    };
                    break;
                case /* substrait.Expression.MaskExpression masked_reference */ 2:
                    message.referenceType = {
                        oneofKind: "maskedReference",
                        maskedReference: Expression_MaskExpression.internalBinaryRead(reader, reader.uint32(), options, (message.referenceType as any).maskedReference)
                    };
                    break;
                case /* substrait.Expression expression */ 3:
                    message.rootType = {
                        oneofKind: "expression",
                        expression: Expression.internalBinaryRead(reader, reader.uint32(), options, (message.rootType as any).expression)
                    };
                    break;
                case /* substrait.Expression.FieldReference.RootReference root_reference */ 4:
                    message.rootType = {
                        oneofKind: "rootReference",
                        rootReference: Expression_FieldReference_RootReference.internalBinaryRead(reader, reader.uint32(), options, (message.rootType as any).rootReference)
                    };
                    break;
                case /* substrait.Expression.FieldReference.OuterReference outer_reference */ 5:
                    message.rootType = {
                        oneofKind: "outerReference",
                        outerReference: Expression_FieldReference_OuterReference.internalBinaryRead(reader, reader.uint32(), options, (message.rootType as any).outerReference)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_FieldReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression.ReferenceSegment direct_reference = 1; */
        if (message.referenceType.oneofKind === "directReference")
            Expression_ReferenceSegment.internalBinaryWrite(message.referenceType.directReference, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.MaskExpression masked_reference = 2; */
        if (message.referenceType.oneofKind === "maskedReference")
            Expression_MaskExpression.internalBinaryWrite(message.referenceType.maskedReference, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression expression = 3; */
        if (message.rootType.oneofKind === "expression")
            Expression.internalBinaryWrite(message.rootType.expression, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.FieldReference.RootReference root_reference = 4; */
        if (message.rootType.oneofKind === "rootReference")
            Expression_FieldReference_RootReference.internalBinaryWrite(message.rootType.rootReference, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.FieldReference.OuterReference outer_reference = 5; */
        if (message.rootType.oneofKind === "outerReference")
            Expression_FieldReference_OuterReference.internalBinaryWrite(message.rootType.outerReference, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.FieldReference
 */
export const Expression_FieldReference = new Expression_FieldReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_FieldReference_RootReference$Type extends MessageType<Expression_FieldReference_RootReference> {
    constructor() {
        super("substrait.Expression.FieldReference.RootReference", []);
    }
    create(value?: PartialMessage<Expression_FieldReference_RootReference>): Expression_FieldReference_RootReference {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_FieldReference_RootReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_FieldReference_RootReference): Expression_FieldReference_RootReference {
        return target ?? this.create();
    }
    internalBinaryWrite(message: Expression_FieldReference_RootReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.FieldReference.RootReference
 */
export const Expression_FieldReference_RootReference = new Expression_FieldReference_RootReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_FieldReference_OuterReference$Type extends MessageType<Expression_FieldReference_OuterReference> {
    constructor() {
        super("substrait.Expression.FieldReference.OuterReference", [
            { no: 1, name: "steps_out", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Expression_FieldReference_OuterReference>): Expression_FieldReference_OuterReference {
        const message = { stepsOut: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_FieldReference_OuterReference>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_FieldReference_OuterReference): Expression_FieldReference_OuterReference {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 steps_out */ 1:
                    message.stepsOut = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_FieldReference_OuterReference, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 steps_out = 1; */
        if (message.stepsOut !== 0)
            writer.tag(1, WireType.Varint).uint32(message.stepsOut);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.FieldReference.OuterReference
 */
export const Expression_FieldReference_OuterReference = new Expression_FieldReference_OuterReference$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Subquery$Type extends MessageType<Expression_Subquery> {
    constructor() {
        super("substrait.Expression.Subquery", [
            { no: 1, name: "scalar", kind: "message", oneof: "subqueryType", T: () => Expression_Subquery_Scalar },
            { no: 2, name: "in_predicate", kind: "message", oneof: "subqueryType", T: () => Expression_Subquery_InPredicate },
            { no: 3, name: "set_predicate", kind: "message", oneof: "subqueryType", T: () => Expression_Subquery_SetPredicate },
            { no: 4, name: "set_comparison", kind: "message", oneof: "subqueryType", T: () => Expression_Subquery_SetComparison }
        ]);
    }
    create(value?: PartialMessage<Expression_Subquery>): Expression_Subquery {
        const message = { subqueryType: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Subquery>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Subquery): Expression_Subquery {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression.Subquery.Scalar scalar */ 1:
                    message.subqueryType = {
                        oneofKind: "scalar",
                        scalar: Expression_Subquery_Scalar.internalBinaryRead(reader, reader.uint32(), options, (message.subqueryType as any).scalar)
                    };
                    break;
                case /* substrait.Expression.Subquery.InPredicate in_predicate */ 2:
                    message.subqueryType = {
                        oneofKind: "inPredicate",
                        inPredicate: Expression_Subquery_InPredicate.internalBinaryRead(reader, reader.uint32(), options, (message.subqueryType as any).inPredicate)
                    };
                    break;
                case /* substrait.Expression.Subquery.SetPredicate set_predicate */ 3:
                    message.subqueryType = {
                        oneofKind: "setPredicate",
                        setPredicate: Expression_Subquery_SetPredicate.internalBinaryRead(reader, reader.uint32(), options, (message.subqueryType as any).setPredicate)
                    };
                    break;
                case /* substrait.Expression.Subquery.SetComparison set_comparison */ 4:
                    message.subqueryType = {
                        oneofKind: "setComparison",
                        setComparison: Expression_Subquery_SetComparison.internalBinaryRead(reader, reader.uint32(), options, (message.subqueryType as any).setComparison)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_Subquery, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression.Subquery.Scalar scalar = 1; */
        if (message.subqueryType.oneofKind === "scalar")
            Expression_Subquery_Scalar.internalBinaryWrite(message.subqueryType.scalar, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.Subquery.InPredicate in_predicate = 2; */
        if (message.subqueryType.oneofKind === "inPredicate")
            Expression_Subquery_InPredicate.internalBinaryWrite(message.subqueryType.inPredicate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.Subquery.SetPredicate set_predicate = 3; */
        if (message.subqueryType.oneofKind === "setPredicate")
            Expression_Subquery_SetPredicate.internalBinaryWrite(message.subqueryType.setPredicate, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Expression.Subquery.SetComparison set_comparison = 4; */
        if (message.subqueryType.oneofKind === "setComparison")
            Expression_Subquery_SetComparison.internalBinaryWrite(message.subqueryType.setComparison, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Subquery
 */
export const Expression_Subquery = new Expression_Subquery$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Subquery_Scalar$Type extends MessageType<Expression_Subquery_Scalar> {
    constructor() {
        super("substrait.Expression.Subquery.Scalar", [
            { no: 1, name: "input", kind: "message", T: () => Rel }
        ]);
    }
    create(value?: PartialMessage<Expression_Subquery_Scalar>): Expression_Subquery_Scalar {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Subquery_Scalar>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Subquery_Scalar): Expression_Subquery_Scalar {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Rel input */ 1:
                    message.input = Rel.internalBinaryRead(reader, reader.uint32(), options, message.input);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_Subquery_Scalar, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Rel input = 1; */
        if (message.input)
            Rel.internalBinaryWrite(message.input, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Subquery.Scalar
 */
export const Expression_Subquery_Scalar = new Expression_Subquery_Scalar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Subquery_InPredicate$Type extends MessageType<Expression_Subquery_InPredicate> {
    constructor() {
        super("substrait.Expression.Subquery.InPredicate", [
            { no: 1, name: "needles", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression },
            { no: 2, name: "haystack", kind: "message", T: () => Rel }
        ]);
    }
    create(value?: PartialMessage<Expression_Subquery_InPredicate>): Expression_Subquery_InPredicate {
        const message = { needles: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Subquery_InPredicate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Subquery_InPredicate): Expression_Subquery_InPredicate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.Expression needles */ 1:
                    message.needles.push(Expression.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* substrait.Rel haystack */ 2:
                    message.haystack = Rel.internalBinaryRead(reader, reader.uint32(), options, message.haystack);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_Subquery_InPredicate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.Expression needles = 1; */
        for (let i = 0; i < message.needles.length; i++)
            Expression.internalBinaryWrite(message.needles[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Rel haystack = 2; */
        if (message.haystack)
            Rel.internalBinaryWrite(message.haystack, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Subquery.InPredicate
 */
export const Expression_Subquery_InPredicate = new Expression_Subquery_InPredicate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Subquery_SetPredicate$Type extends MessageType<Expression_Subquery_SetPredicate> {
    constructor() {
        super("substrait.Expression.Subquery.SetPredicate", [
            { no: 1, name: "predicate_op", kind: "enum", T: () => ["substrait.Expression.Subquery.SetPredicate.PredicateOp", Expression_Subquery_SetPredicate_PredicateOp, "PREDICATE_OP_"] },
            { no: 2, name: "tuples", kind: "message", T: () => Rel }
        ]);
    }
    create(value?: PartialMessage<Expression_Subquery_SetPredicate>): Expression_Subquery_SetPredicate {
        const message = { predicateOp: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Subquery_SetPredicate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Subquery_SetPredicate): Expression_Subquery_SetPredicate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression.Subquery.SetPredicate.PredicateOp predicate_op */ 1:
                    message.predicateOp = reader.int32();
                    break;
                case /* substrait.Rel tuples */ 2:
                    message.tuples = Rel.internalBinaryRead(reader, reader.uint32(), options, message.tuples);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_Subquery_SetPredicate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression.Subquery.SetPredicate.PredicateOp predicate_op = 1; */
        if (message.predicateOp !== 0)
            writer.tag(1, WireType.Varint).int32(message.predicateOp);
        /* substrait.Rel tuples = 2; */
        if (message.tuples)
            Rel.internalBinaryWrite(message.tuples, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Subquery.SetPredicate
 */
export const Expression_Subquery_SetPredicate = new Expression_Subquery_SetPredicate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Expression_Subquery_SetComparison$Type extends MessageType<Expression_Subquery_SetComparison> {
    constructor() {
        super("substrait.Expression.Subquery.SetComparison", [
            { no: 1, name: "reduction_op", kind: "enum", T: () => ["substrait.Expression.Subquery.SetComparison.ReductionOp", Expression_Subquery_SetComparison_ReductionOp, "REDUCTION_OP_"] },
            { no: 2, name: "comparison_op", kind: "enum", T: () => ["substrait.Expression.Subquery.SetComparison.ComparisonOp", Expression_Subquery_SetComparison_ComparisonOp, "COMPARISON_OP_"] },
            { no: 3, name: "left", kind: "message", T: () => Expression },
            { no: 4, name: "right", kind: "message", T: () => Rel }
        ]);
    }
    create(value?: PartialMessage<Expression_Subquery_SetComparison>): Expression_Subquery_SetComparison {
        const message = { reductionOp: 0, comparisonOp: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Expression_Subquery_SetComparison>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Expression_Subquery_SetComparison): Expression_Subquery_SetComparison {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression.Subquery.SetComparison.ReductionOp reduction_op */ 1:
                    message.reductionOp = reader.int32();
                    break;
                case /* substrait.Expression.Subquery.SetComparison.ComparisonOp comparison_op */ 2:
                    message.comparisonOp = reader.int32();
                    break;
                case /* substrait.Expression left */ 3:
                    message.left = Expression.internalBinaryRead(reader, reader.uint32(), options, message.left);
                    break;
                case /* substrait.Rel right */ 4:
                    message.right = Rel.internalBinaryRead(reader, reader.uint32(), options, message.right);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Expression_Subquery_SetComparison, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression.Subquery.SetComparison.ReductionOp reduction_op = 1; */
        if (message.reductionOp !== 0)
            writer.tag(1, WireType.Varint).int32(message.reductionOp);
        /* substrait.Expression.Subquery.SetComparison.ComparisonOp comparison_op = 2; */
        if (message.comparisonOp !== 0)
            writer.tag(2, WireType.Varint).int32(message.comparisonOp);
        /* substrait.Expression left = 3; */
        if (message.left)
            Expression.internalBinaryWrite(message.left, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Rel right = 4; */
        if (message.right)
            Rel.internalBinaryWrite(message.right, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Expression.Subquery.SetComparison
 */
export const Expression_Subquery_SetComparison = new Expression_Subquery_SetComparison$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SortField$Type extends MessageType<SortField> {
    constructor() {
        super("substrait.SortField", [
            { no: 1, name: "expr", kind: "message", T: () => Expression },
            { no: 2, name: "direction", kind: "enum", oneof: "sortKind", T: () => ["substrait.SortField.SortDirection", SortField_SortDirection, "SORT_DIRECTION_"] },
            { no: 3, name: "comparison_function_reference", kind: "scalar", oneof: "sortKind", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<SortField>): SortField {
        const message = { sortKind: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SortField>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SortField): SortField {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Expression expr */ 1:
                    message.expr = Expression.internalBinaryRead(reader, reader.uint32(), options, message.expr);
                    break;
                case /* substrait.SortField.SortDirection direction */ 2:
                    message.sortKind = {
                        oneofKind: "direction",
                        direction: reader.int32()
                    };
                    break;
                case /* uint32 comparison_function_reference */ 3:
                    message.sortKind = {
                        oneofKind: "comparisonFunctionReference",
                        comparisonFunctionReference: reader.uint32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SortField, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Expression expr = 1; */
        if (message.expr)
            Expression.internalBinaryWrite(message.expr, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.SortField.SortDirection direction = 2; */
        if (message.sortKind.oneofKind === "direction")
            writer.tag(2, WireType.Varint).int32(message.sortKind.direction);
        /* uint32 comparison_function_reference = 3; */
        if (message.sortKind.oneofKind === "comparisonFunctionReference")
            writer.tag(3, WireType.Varint).uint32(message.sortKind.comparisonFunctionReference);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.SortField
 */
export const SortField = new SortField$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AggregateFunction$Type extends MessageType<AggregateFunction> {
    constructor() {
        super("substrait.AggregateFunction", [
            { no: 1, name: "function_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "args", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Expression },
            { no: 3, name: "sorts", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SortField },
            { no: 4, name: "phase", kind: "enum", T: () => ["substrait.AggregationPhase", AggregationPhase, "AGGREGATION_PHASE_"] },
            { no: 5, name: "output_type", kind: "message", T: () => Type }
        ]);
    }
    create(value?: PartialMessage<AggregateFunction>): AggregateFunction {
        const message = { functionReference: 0, args: [], sorts: [], phase: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AggregateFunction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AggregateFunction): AggregateFunction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 function_reference */ 1:
                    message.functionReference = reader.uint32();
                    break;
                case /* repeated substrait.Expression args */ 2:
                    message.args.push(Expression.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated substrait.SortField sorts */ 3:
                    message.sorts.push(SortField.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* substrait.AggregationPhase phase */ 4:
                    message.phase = reader.int32();
                    break;
                case /* substrait.Type output_type */ 5:
                    message.outputType = Type.internalBinaryRead(reader, reader.uint32(), options, message.outputType);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AggregateFunction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 function_reference = 1; */
        if (message.functionReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.functionReference);
        /* repeated substrait.Expression args = 2; */
        for (let i = 0; i < message.args.length; i++)
            Expression.internalBinaryWrite(message.args[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated substrait.SortField sorts = 3; */
        for (let i = 0; i < message.sorts.length; i++)
            SortField.internalBinaryWrite(message.sorts[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.AggregationPhase phase = 4; */
        if (message.phase !== 0)
            writer.tag(4, WireType.Varint).int32(message.phase);
        /* substrait.Type output_type = 5; */
        if (message.outputType)
            Type.internalBinaryWrite(message.outputType, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.AggregateFunction
 */
export const AggregateFunction = new AggregateFunction$Type();
