// @generated by protobuf-ts 2.2.4
// @generated from protobuf file "substrait/type.proto" (package "substrait", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message substrait.Type
 */
export interface Type {
    /**
     * @generated from protobuf oneof: kind
     */
    kind: {
        oneofKind: "bool";
        /**
         * @generated from protobuf field: substrait.Type.Boolean bool = 1;
         */
        bool: Type_Boolean;
    } | {
        oneofKind: "i8";
        /**
         * @generated from protobuf field: substrait.Type.I8 i8 = 2;
         */
        i8: Type_I8;
    } | {
        oneofKind: "i16";
        /**
         * @generated from protobuf field: substrait.Type.I16 i16 = 3;
         */
        i16: Type_I16;
    } | {
        oneofKind: "i32";
        /**
         * @generated from protobuf field: substrait.Type.I32 i32 = 5;
         */
        i32: Type_I32;
    } | {
        oneofKind: "i64";
        /**
         * @generated from protobuf field: substrait.Type.I64 i64 = 7;
         */
        i64: Type_I64;
    } | {
        oneofKind: "fp32";
        /**
         * @generated from protobuf field: substrait.Type.FP32 fp32 = 10;
         */
        fp32: Type_FP32;
    } | {
        oneofKind: "fp64";
        /**
         * @generated from protobuf field: substrait.Type.FP64 fp64 = 11;
         */
        fp64: Type_FP64;
    } | {
        oneofKind: "string";
        /**
         * @generated from protobuf field: substrait.Type.String string = 12;
         */
        string: Type_String;
    } | {
        oneofKind: "binary";
        /**
         * @generated from protobuf field: substrait.Type.Binary binary = 13;
         */
        binary: Type_Binary;
    } | {
        oneofKind: "timestamp";
        /**
         * @generated from protobuf field: substrait.Type.Timestamp timestamp = 14;
         */
        timestamp: Type_Timestamp;
    } | {
        oneofKind: "date";
        /**
         * @generated from protobuf field: substrait.Type.Date date = 16;
         */
        date: Type_Date;
    } | {
        oneofKind: "time";
        /**
         * @generated from protobuf field: substrait.Type.Time time = 17;
         */
        time: Type_Time;
    } | {
        oneofKind: "intervalYear";
        /**
         * @generated from protobuf field: substrait.Type.IntervalYear interval_year = 19;
         */
        intervalYear: Type_IntervalYear;
    } | {
        oneofKind: "intervalDay";
        /**
         * @generated from protobuf field: substrait.Type.IntervalDay interval_day = 20;
         */
        intervalDay: Type_IntervalDay;
    } | {
        oneofKind: "timestampTz";
        /**
         * @generated from protobuf field: substrait.Type.TimestampTZ timestamp_tz = 29;
         */
        timestampTz: Type_TimestampTZ;
    } | {
        oneofKind: "uuid";
        /**
         * @generated from protobuf field: substrait.Type.UUID uuid = 32;
         */
        uuid: Type_UUID;
    } | {
        oneofKind: "fixedChar";
        /**
         * @generated from protobuf field: substrait.Type.FixedChar fixed_char = 21;
         */
        fixedChar: Type_FixedChar;
    } | {
        oneofKind: "varchar";
        /**
         * @generated from protobuf field: substrait.Type.VarChar varchar = 22;
         */
        varchar: Type_VarChar;
    } | {
        oneofKind: "fixedBinary";
        /**
         * @generated from protobuf field: substrait.Type.FixedBinary fixed_binary = 23;
         */
        fixedBinary: Type_FixedBinary;
    } | {
        oneofKind: "decimal";
        /**
         * @generated from protobuf field: substrait.Type.Decimal decimal = 24;
         */
        decimal: Type_Decimal;
    } | {
        oneofKind: "struct";
        /**
         * @generated from protobuf field: substrait.Type.Struct struct = 25;
         */
        struct: Type_Struct;
    } | {
        oneofKind: "list";
        /**
         * @generated from protobuf field: substrait.Type.List list = 27;
         */
        list: Type_List;
    } | {
        oneofKind: "map";
        /**
         * @generated from protobuf field: substrait.Type.Map map = 28;
         */
        map: Type_Map;
    } | {
        oneofKind: "userDefinedTypeReference";
        /**
         * @generated from protobuf field: uint32 user_defined_type_reference = 31;
         */
        userDefinedTypeReference: number;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message substrait.Type.Boolean
 */
export interface Type_Boolean {
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 1;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 2;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.I8
 */
export interface Type_I8 {
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 1;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 2;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.I16
 */
export interface Type_I16 {
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 1;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 2;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.I32
 */
export interface Type_I32 {
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 1;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 2;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.I64
 */
export interface Type_I64 {
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 1;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 2;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.FP32
 */
export interface Type_FP32 {
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 1;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 2;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.FP64
 */
export interface Type_FP64 {
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 1;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 2;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.String
 */
export interface Type_String {
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 1;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 2;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.Binary
 */
export interface Type_Binary {
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 1;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 2;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.Timestamp
 */
export interface Type_Timestamp {
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 1;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 2;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.Date
 */
export interface Type_Date {
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 1;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 2;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.Time
 */
export interface Type_Time {
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 1;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 2;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.TimestampTZ
 */
export interface Type_TimestampTZ {
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 1;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 2;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.IntervalYear
 */
export interface Type_IntervalYear {
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 1;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 2;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.IntervalDay
 */
export interface Type_IntervalDay {
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 1;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 2;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.UUID
 */
export interface Type_UUID {
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 1;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 2;
     */
    nullability: Type_Nullability;
}
/**
 * Start compound types.
 *
 * @generated from protobuf message substrait.Type.FixedChar
 */
export interface Type_FixedChar {
    /**
     * @generated from protobuf field: int32 length = 1;
     */
    length: number;
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 2;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 3;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.VarChar
 */
export interface Type_VarChar {
    /**
     * @generated from protobuf field: int32 length = 1;
     */
    length: number;
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 2;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 3;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.FixedBinary
 */
export interface Type_FixedBinary {
    /**
     * @generated from protobuf field: int32 length = 1;
     */
    length: number;
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 2;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 3;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.Decimal
 */
export interface Type_Decimal {
    /**
     * @generated from protobuf field: int32 scale = 1;
     */
    scale: number;
    /**
     * @generated from protobuf field: int32 precision = 2;
     */
    precision: number;
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 3;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 4;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.Struct
 */
export interface Type_Struct {
    /**
     * @generated from protobuf field: repeated substrait.Type types = 1;
     */
    types: Type[];
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 2;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 3;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.List
 */
export interface Type_List {
    /**
     * @generated from protobuf field: substrait.Type type = 1;
     */
    type?: Type;
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 2;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 3;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf message substrait.Type.Map
 */
export interface Type_Map {
    /**
     * @generated from protobuf field: substrait.Type key = 1;
     */
    key?: Type;
    /**
     * @generated from protobuf field: substrait.Type value = 2;
     */
    value?: Type;
    /**
     * @generated from protobuf field: uint32 type_variation_reference = 3;
     */
    typeVariationReference: number;
    /**
     * @generated from protobuf field: substrait.Type.Nullability nullability = 4;
     */
    nullability: Type_Nullability;
}
/**
 * @generated from protobuf enum substrait.Type.Nullability
 */
export enum Type_Nullability {
    /**
     * @generated from protobuf enum value: NULLABILITY_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: NULLABILITY_NULLABLE = 1;
     */
    NULLABLE = 1,
    /**
     * @generated from protobuf enum value: NULLABILITY_REQUIRED = 2;
     */
    REQUIRED = 2
}
/**
 * A message for modeling name/type pairs.
 *
 * Useful for representing relation schemas.
 *
 * Notes:
 *
 * * The names field is in depth-first order.
 *
 * For example a schema such as:
 *
 * a: int64
 * b: struct<c: float32, d: string>
 *
 * would have a `names` field that looks like:
 *
 * ["a", "b", "c", "d"]
 *
 * * Only struct fields are contained in this field's elements,
 * * Map keys should be traversed first, then values when producing/consuming
 *
 * @generated from protobuf message substrait.NamedStruct
 */
export interface NamedStruct {
    /**
     * list of names in dfs order
     *
     * @generated from protobuf field: repeated string names = 1;
     */
    names: string[];
    /**
     * @generated from protobuf field: substrait.Type.Struct struct = 2;
     */
    struct?: Type_Struct;
}
// @generated message type with reflection information, may provide speed optimized methods
class Type$Type extends MessageType<Type> {
    constructor() {
        super("substrait.Type", [
            { no: 1, name: "bool", kind: "message", oneof: "kind", T: () => Type_Boolean },
            { no: 2, name: "i8", kind: "message", oneof: "kind", T: () => Type_I8 },
            { no: 3, name: "i16", kind: "message", oneof: "kind", T: () => Type_I16 },
            { no: 5, name: "i32", kind: "message", oneof: "kind", T: () => Type_I32 },
            { no: 7, name: "i64", kind: "message", oneof: "kind", T: () => Type_I64 },
            { no: 10, name: "fp32", kind: "message", oneof: "kind", T: () => Type_FP32 },
            { no: 11, name: "fp64", kind: "message", oneof: "kind", T: () => Type_FP64 },
            { no: 12, name: "string", kind: "message", oneof: "kind", T: () => Type_String },
            { no: 13, name: "binary", kind: "message", oneof: "kind", T: () => Type_Binary },
            { no: 14, name: "timestamp", kind: "message", oneof: "kind", T: () => Type_Timestamp },
            { no: 16, name: "date", kind: "message", oneof: "kind", T: () => Type_Date },
            { no: 17, name: "time", kind: "message", oneof: "kind", T: () => Type_Time },
            { no: 19, name: "interval_year", kind: "message", oneof: "kind", T: () => Type_IntervalYear },
            { no: 20, name: "interval_day", kind: "message", oneof: "kind", T: () => Type_IntervalDay },
            { no: 29, name: "timestamp_tz", kind: "message", oneof: "kind", T: () => Type_TimestampTZ },
            { no: 32, name: "uuid", kind: "message", oneof: "kind", T: () => Type_UUID },
            { no: 21, name: "fixed_char", kind: "message", oneof: "kind", T: () => Type_FixedChar },
            { no: 22, name: "varchar", kind: "message", oneof: "kind", T: () => Type_VarChar },
            { no: 23, name: "fixed_binary", kind: "message", oneof: "kind", T: () => Type_FixedBinary },
            { no: 24, name: "decimal", kind: "message", oneof: "kind", T: () => Type_Decimal },
            { no: 25, name: "struct", kind: "message", oneof: "kind", T: () => Type_Struct },
            { no: 27, name: "list", kind: "message", oneof: "kind", T: () => Type_List },
            { no: 28, name: "map", kind: "message", oneof: "kind", T: () => Type_Map },
            { no: 31, name: "user_defined_type_reference", kind: "scalar", oneof: "kind", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Type>): Type {
        const message = { kind: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type): Type {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Type.Boolean bool */ 1:
                    message.kind = {
                        oneofKind: "bool",
                        bool: Type_Boolean.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).bool)
                    };
                    break;
                case /* substrait.Type.I8 i8 */ 2:
                    message.kind = {
                        oneofKind: "i8",
                        i8: Type_I8.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).i8)
                    };
                    break;
                case /* substrait.Type.I16 i16 */ 3:
                    message.kind = {
                        oneofKind: "i16",
                        i16: Type_I16.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).i16)
                    };
                    break;
                case /* substrait.Type.I32 i32 */ 5:
                    message.kind = {
                        oneofKind: "i32",
                        i32: Type_I32.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).i32)
                    };
                    break;
                case /* substrait.Type.I64 i64 */ 7:
                    message.kind = {
                        oneofKind: "i64",
                        i64: Type_I64.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).i64)
                    };
                    break;
                case /* substrait.Type.FP32 fp32 */ 10:
                    message.kind = {
                        oneofKind: "fp32",
                        fp32: Type_FP32.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).fp32)
                    };
                    break;
                case /* substrait.Type.FP64 fp64 */ 11:
                    message.kind = {
                        oneofKind: "fp64",
                        fp64: Type_FP64.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).fp64)
                    };
                    break;
                case /* substrait.Type.String string */ 12:
                    message.kind = {
                        oneofKind: "string",
                        string: Type_String.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).string)
                    };
                    break;
                case /* substrait.Type.Binary binary */ 13:
                    message.kind = {
                        oneofKind: "binary",
                        binary: Type_Binary.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).binary)
                    };
                    break;
                case /* substrait.Type.Timestamp timestamp */ 14:
                    message.kind = {
                        oneofKind: "timestamp",
                        timestamp: Type_Timestamp.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).timestamp)
                    };
                    break;
                case /* substrait.Type.Date date */ 16:
                    message.kind = {
                        oneofKind: "date",
                        date: Type_Date.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).date)
                    };
                    break;
                case /* substrait.Type.Time time */ 17:
                    message.kind = {
                        oneofKind: "time",
                        time: Type_Time.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).time)
                    };
                    break;
                case /* substrait.Type.IntervalYear interval_year */ 19:
                    message.kind = {
                        oneofKind: "intervalYear",
                        intervalYear: Type_IntervalYear.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).intervalYear)
                    };
                    break;
                case /* substrait.Type.IntervalDay interval_day */ 20:
                    message.kind = {
                        oneofKind: "intervalDay",
                        intervalDay: Type_IntervalDay.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).intervalDay)
                    };
                    break;
                case /* substrait.Type.TimestampTZ timestamp_tz */ 29:
                    message.kind = {
                        oneofKind: "timestampTz",
                        timestampTz: Type_TimestampTZ.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).timestampTz)
                    };
                    break;
                case /* substrait.Type.UUID uuid */ 32:
                    message.kind = {
                        oneofKind: "uuid",
                        uuid: Type_UUID.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).uuid)
                    };
                    break;
                case /* substrait.Type.FixedChar fixed_char */ 21:
                    message.kind = {
                        oneofKind: "fixedChar",
                        fixedChar: Type_FixedChar.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).fixedChar)
                    };
                    break;
                case /* substrait.Type.VarChar varchar */ 22:
                    message.kind = {
                        oneofKind: "varchar",
                        varchar: Type_VarChar.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).varchar)
                    };
                    break;
                case /* substrait.Type.FixedBinary fixed_binary */ 23:
                    message.kind = {
                        oneofKind: "fixedBinary",
                        fixedBinary: Type_FixedBinary.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).fixedBinary)
                    };
                    break;
                case /* substrait.Type.Decimal decimal */ 24:
                    message.kind = {
                        oneofKind: "decimal",
                        decimal: Type_Decimal.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).decimal)
                    };
                    break;
                case /* substrait.Type.Struct struct */ 25:
                    message.kind = {
                        oneofKind: "struct",
                        struct: Type_Struct.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).struct)
                    };
                    break;
                case /* substrait.Type.List list */ 27:
                    message.kind = {
                        oneofKind: "list",
                        list: Type_List.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).list)
                    };
                    break;
                case /* substrait.Type.Map map */ 28:
                    message.kind = {
                        oneofKind: "map",
                        map: Type_Map.internalBinaryRead(reader, reader.uint32(), options, (message.kind as any).map)
                    };
                    break;
                case /* uint32 user_defined_type_reference */ 31:
                    message.kind = {
                        oneofKind: "userDefinedTypeReference",
                        userDefinedTypeReference: reader.uint32()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Type.Boolean bool = 1; */
        if (message.kind.oneofKind === "bool")
            Type_Boolean.internalBinaryWrite(message.kind.bool, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.I8 i8 = 2; */
        if (message.kind.oneofKind === "i8")
            Type_I8.internalBinaryWrite(message.kind.i8, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.I16 i16 = 3; */
        if (message.kind.oneofKind === "i16")
            Type_I16.internalBinaryWrite(message.kind.i16, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.I32 i32 = 5; */
        if (message.kind.oneofKind === "i32")
            Type_I32.internalBinaryWrite(message.kind.i32, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.I64 i64 = 7; */
        if (message.kind.oneofKind === "i64")
            Type_I64.internalBinaryWrite(message.kind.i64, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.FP32 fp32 = 10; */
        if (message.kind.oneofKind === "fp32")
            Type_FP32.internalBinaryWrite(message.kind.fp32, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.FP64 fp64 = 11; */
        if (message.kind.oneofKind === "fp64")
            Type_FP64.internalBinaryWrite(message.kind.fp64, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.String string = 12; */
        if (message.kind.oneofKind === "string")
            Type_String.internalBinaryWrite(message.kind.string, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.Binary binary = 13; */
        if (message.kind.oneofKind === "binary")
            Type_Binary.internalBinaryWrite(message.kind.binary, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.Timestamp timestamp = 14; */
        if (message.kind.oneofKind === "timestamp")
            Type_Timestamp.internalBinaryWrite(message.kind.timestamp, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.Date date = 16; */
        if (message.kind.oneofKind === "date")
            Type_Date.internalBinaryWrite(message.kind.date, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.Time time = 17; */
        if (message.kind.oneofKind === "time")
            Type_Time.internalBinaryWrite(message.kind.time, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.IntervalYear interval_year = 19; */
        if (message.kind.oneofKind === "intervalYear")
            Type_IntervalYear.internalBinaryWrite(message.kind.intervalYear, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.IntervalDay interval_day = 20; */
        if (message.kind.oneofKind === "intervalDay")
            Type_IntervalDay.internalBinaryWrite(message.kind.intervalDay, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.TimestampTZ timestamp_tz = 29; */
        if (message.kind.oneofKind === "timestampTz")
            Type_TimestampTZ.internalBinaryWrite(message.kind.timestampTz, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.UUID uuid = 32; */
        if (message.kind.oneofKind === "uuid")
            Type_UUID.internalBinaryWrite(message.kind.uuid, writer.tag(32, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.FixedChar fixed_char = 21; */
        if (message.kind.oneofKind === "fixedChar")
            Type_FixedChar.internalBinaryWrite(message.kind.fixedChar, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.VarChar varchar = 22; */
        if (message.kind.oneofKind === "varchar")
            Type_VarChar.internalBinaryWrite(message.kind.varchar, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.FixedBinary fixed_binary = 23; */
        if (message.kind.oneofKind === "fixedBinary")
            Type_FixedBinary.internalBinaryWrite(message.kind.fixedBinary, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.Decimal decimal = 24; */
        if (message.kind.oneofKind === "decimal")
            Type_Decimal.internalBinaryWrite(message.kind.decimal, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.Struct struct = 25; */
        if (message.kind.oneofKind === "struct")
            Type_Struct.internalBinaryWrite(message.kind.struct, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.List list = 27; */
        if (message.kind.oneofKind === "list")
            Type_List.internalBinaryWrite(message.kind.list, writer.tag(27, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type.Map map = 28; */
        if (message.kind.oneofKind === "map")
            Type_Map.internalBinaryWrite(message.kind.map, writer.tag(28, WireType.LengthDelimited).fork(), options).join();
        /* uint32 user_defined_type_reference = 31; */
        if (message.kind.oneofKind === "userDefinedTypeReference")
            writer.tag(31, WireType.Varint).uint32(message.kind.userDefinedTypeReference);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type
 */
export const Type = new Type$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_Boolean$Type extends MessageType<Type_Boolean> {
    constructor() {
        super("substrait.Type.Boolean", [
            { no: 1, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_Boolean>): Type_Boolean {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_Boolean>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_Boolean): Type_Boolean {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_variation_reference */ 1:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 2:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_Boolean, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_variation_reference = 1; */
        if (message.typeVariationReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 2; */
        if (message.nullability !== 0)
            writer.tag(2, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.Boolean
 */
export const Type_Boolean = new Type_Boolean$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_I8$Type extends MessageType<Type_I8> {
    constructor() {
        super("substrait.Type.I8", [
            { no: 1, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_I8>): Type_I8 {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_I8>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_I8): Type_I8 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_variation_reference */ 1:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 2:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_I8, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_variation_reference = 1; */
        if (message.typeVariationReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 2; */
        if (message.nullability !== 0)
            writer.tag(2, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.I8
 */
export const Type_I8 = new Type_I8$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_I16$Type extends MessageType<Type_I16> {
    constructor() {
        super("substrait.Type.I16", [
            { no: 1, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_I16>): Type_I16 {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_I16>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_I16): Type_I16 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_variation_reference */ 1:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 2:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_I16, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_variation_reference = 1; */
        if (message.typeVariationReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 2; */
        if (message.nullability !== 0)
            writer.tag(2, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.I16
 */
export const Type_I16 = new Type_I16$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_I32$Type extends MessageType<Type_I32> {
    constructor() {
        super("substrait.Type.I32", [
            { no: 1, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_I32>): Type_I32 {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_I32>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_I32): Type_I32 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_variation_reference */ 1:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 2:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_I32, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_variation_reference = 1; */
        if (message.typeVariationReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 2; */
        if (message.nullability !== 0)
            writer.tag(2, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.I32
 */
export const Type_I32 = new Type_I32$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_I64$Type extends MessageType<Type_I64> {
    constructor() {
        super("substrait.Type.I64", [
            { no: 1, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_I64>): Type_I64 {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_I64>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_I64): Type_I64 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_variation_reference */ 1:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 2:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_I64, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_variation_reference = 1; */
        if (message.typeVariationReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 2; */
        if (message.nullability !== 0)
            writer.tag(2, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.I64
 */
export const Type_I64 = new Type_I64$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_FP32$Type extends MessageType<Type_FP32> {
    constructor() {
        super("substrait.Type.FP32", [
            { no: 1, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_FP32>): Type_FP32 {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_FP32>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_FP32): Type_FP32 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_variation_reference */ 1:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 2:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_FP32, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_variation_reference = 1; */
        if (message.typeVariationReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 2; */
        if (message.nullability !== 0)
            writer.tag(2, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.FP32
 */
export const Type_FP32 = new Type_FP32$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_FP64$Type extends MessageType<Type_FP64> {
    constructor() {
        super("substrait.Type.FP64", [
            { no: 1, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_FP64>): Type_FP64 {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_FP64>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_FP64): Type_FP64 {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_variation_reference */ 1:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 2:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_FP64, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_variation_reference = 1; */
        if (message.typeVariationReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 2; */
        if (message.nullability !== 0)
            writer.tag(2, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.FP64
 */
export const Type_FP64 = new Type_FP64$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_String$Type extends MessageType<Type_String> {
    constructor() {
        super("substrait.Type.String", [
            { no: 1, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_String>): Type_String {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_String>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_String): Type_String {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_variation_reference */ 1:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 2:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_String, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_variation_reference = 1; */
        if (message.typeVariationReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 2; */
        if (message.nullability !== 0)
            writer.tag(2, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.String
 */
export const Type_String = new Type_String$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_Binary$Type extends MessageType<Type_Binary> {
    constructor() {
        super("substrait.Type.Binary", [
            { no: 1, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_Binary>): Type_Binary {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_Binary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_Binary): Type_Binary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_variation_reference */ 1:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 2:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_Binary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_variation_reference = 1; */
        if (message.typeVariationReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 2; */
        if (message.nullability !== 0)
            writer.tag(2, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.Binary
 */
export const Type_Binary = new Type_Binary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_Timestamp$Type extends MessageType<Type_Timestamp> {
    constructor() {
        super("substrait.Type.Timestamp", [
            { no: 1, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_Timestamp>): Type_Timestamp {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_Timestamp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_Timestamp): Type_Timestamp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_variation_reference */ 1:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 2:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_Timestamp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_variation_reference = 1; */
        if (message.typeVariationReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 2; */
        if (message.nullability !== 0)
            writer.tag(2, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.Timestamp
 */
export const Type_Timestamp = new Type_Timestamp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_Date$Type extends MessageType<Type_Date> {
    constructor() {
        super("substrait.Type.Date", [
            { no: 1, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_Date>): Type_Date {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_Date>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_Date): Type_Date {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_variation_reference */ 1:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 2:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_Date, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_variation_reference = 1; */
        if (message.typeVariationReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 2; */
        if (message.nullability !== 0)
            writer.tag(2, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.Date
 */
export const Type_Date = new Type_Date$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_Time$Type extends MessageType<Type_Time> {
    constructor() {
        super("substrait.Type.Time", [
            { no: 1, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_Time>): Type_Time {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_Time>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_Time): Type_Time {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_variation_reference */ 1:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 2:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_Time, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_variation_reference = 1; */
        if (message.typeVariationReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 2; */
        if (message.nullability !== 0)
            writer.tag(2, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.Time
 */
export const Type_Time = new Type_Time$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_TimestampTZ$Type extends MessageType<Type_TimestampTZ> {
    constructor() {
        super("substrait.Type.TimestampTZ", [
            { no: 1, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_TimestampTZ>): Type_TimestampTZ {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_TimestampTZ>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_TimestampTZ): Type_TimestampTZ {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_variation_reference */ 1:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 2:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_TimestampTZ, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_variation_reference = 1; */
        if (message.typeVariationReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 2; */
        if (message.nullability !== 0)
            writer.tag(2, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.TimestampTZ
 */
export const Type_TimestampTZ = new Type_TimestampTZ$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_IntervalYear$Type extends MessageType<Type_IntervalYear> {
    constructor() {
        super("substrait.Type.IntervalYear", [
            { no: 1, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_IntervalYear>): Type_IntervalYear {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_IntervalYear>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_IntervalYear): Type_IntervalYear {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_variation_reference */ 1:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 2:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_IntervalYear, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_variation_reference = 1; */
        if (message.typeVariationReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 2; */
        if (message.nullability !== 0)
            writer.tag(2, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.IntervalYear
 */
export const Type_IntervalYear = new Type_IntervalYear$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_IntervalDay$Type extends MessageType<Type_IntervalDay> {
    constructor() {
        super("substrait.Type.IntervalDay", [
            { no: 1, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_IntervalDay>): Type_IntervalDay {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_IntervalDay>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_IntervalDay): Type_IntervalDay {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_variation_reference */ 1:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 2:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_IntervalDay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_variation_reference = 1; */
        if (message.typeVariationReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 2; */
        if (message.nullability !== 0)
            writer.tag(2, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.IntervalDay
 */
export const Type_IntervalDay = new Type_IntervalDay$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_UUID$Type extends MessageType<Type_UUID> {
    constructor() {
        super("substrait.Type.UUID", [
            { no: 1, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_UUID>): Type_UUID {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_UUID>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_UUID): Type_UUID {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type_variation_reference */ 1:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 2:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_UUID, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type_variation_reference = 1; */
        if (message.typeVariationReference !== 0)
            writer.tag(1, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 2; */
        if (message.nullability !== 0)
            writer.tag(2, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.UUID
 */
export const Type_UUID = new Type_UUID$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_FixedChar$Type extends MessageType<Type_FixedChar> {
    constructor() {
        super("substrait.Type.FixedChar", [
            { no: 1, name: "length", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_FixedChar>): Type_FixedChar {
        const message = { length: 0, typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_FixedChar>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_FixedChar): Type_FixedChar {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 length */ 1:
                    message.length = reader.int32();
                    break;
                case /* uint32 type_variation_reference */ 2:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 3:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_FixedChar, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 length = 1; */
        if (message.length !== 0)
            writer.tag(1, WireType.Varint).int32(message.length);
        /* uint32 type_variation_reference = 2; */
        if (message.typeVariationReference !== 0)
            writer.tag(2, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 3; */
        if (message.nullability !== 0)
            writer.tag(3, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.FixedChar
 */
export const Type_FixedChar = new Type_FixedChar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_VarChar$Type extends MessageType<Type_VarChar> {
    constructor() {
        super("substrait.Type.VarChar", [
            { no: 1, name: "length", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_VarChar>): Type_VarChar {
        const message = { length: 0, typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_VarChar>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_VarChar): Type_VarChar {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 length */ 1:
                    message.length = reader.int32();
                    break;
                case /* uint32 type_variation_reference */ 2:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 3:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_VarChar, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 length = 1; */
        if (message.length !== 0)
            writer.tag(1, WireType.Varint).int32(message.length);
        /* uint32 type_variation_reference = 2; */
        if (message.typeVariationReference !== 0)
            writer.tag(2, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 3; */
        if (message.nullability !== 0)
            writer.tag(3, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.VarChar
 */
export const Type_VarChar = new Type_VarChar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_FixedBinary$Type extends MessageType<Type_FixedBinary> {
    constructor() {
        super("substrait.Type.FixedBinary", [
            { no: 1, name: "length", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_FixedBinary>): Type_FixedBinary {
        const message = { length: 0, typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_FixedBinary>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_FixedBinary): Type_FixedBinary {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 length */ 1:
                    message.length = reader.int32();
                    break;
                case /* uint32 type_variation_reference */ 2:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 3:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_FixedBinary, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 length = 1; */
        if (message.length !== 0)
            writer.tag(1, WireType.Varint).int32(message.length);
        /* uint32 type_variation_reference = 2; */
        if (message.typeVariationReference !== 0)
            writer.tag(2, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 3; */
        if (message.nullability !== 0)
            writer.tag(3, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.FixedBinary
 */
export const Type_FixedBinary = new Type_FixedBinary$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_Decimal$Type extends MessageType<Type_Decimal> {
    constructor() {
        super("substrait.Type.Decimal", [
            { no: 1, name: "scale", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "precision", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_Decimal>): Type_Decimal {
        const message = { scale: 0, precision: 0, typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_Decimal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_Decimal): Type_Decimal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 scale */ 1:
                    message.scale = reader.int32();
                    break;
                case /* int32 precision */ 2:
                    message.precision = reader.int32();
                    break;
                case /* uint32 type_variation_reference */ 3:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 4:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_Decimal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 scale = 1; */
        if (message.scale !== 0)
            writer.tag(1, WireType.Varint).int32(message.scale);
        /* int32 precision = 2; */
        if (message.precision !== 0)
            writer.tag(2, WireType.Varint).int32(message.precision);
        /* uint32 type_variation_reference = 3; */
        if (message.typeVariationReference !== 0)
            writer.tag(3, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 4; */
        if (message.nullability !== 0)
            writer.tag(4, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.Decimal
 */
export const Type_Decimal = new Type_Decimal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_Struct$Type extends MessageType<Type_Struct> {
    constructor() {
        super("substrait.Type.Struct", [
            { no: 1, name: "types", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Type },
            { no: 2, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_Struct>): Type_Struct {
        const message = { types: [], typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_Struct>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_Struct): Type_Struct {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.Type types */ 1:
                    message.types.push(Type.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint32 type_variation_reference */ 2:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 3:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_Struct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.Type types = 1; */
        for (let i = 0; i < message.types.length; i++)
            Type.internalBinaryWrite(message.types[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 type_variation_reference = 2; */
        if (message.typeVariationReference !== 0)
            writer.tag(2, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 3; */
        if (message.nullability !== 0)
            writer.tag(3, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.Struct
 */
export const Type_Struct = new Type_Struct$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_List$Type extends MessageType<Type_List> {
    constructor() {
        super("substrait.Type.List", [
            { no: 1, name: "type", kind: "message", T: () => Type },
            { no: 2, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_List>): Type_List {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_List>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_List): Type_List {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Type type */ 1:
                    message.type = Type.internalBinaryRead(reader, reader.uint32(), options, message.type);
                    break;
                case /* uint32 type_variation_reference */ 2:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 3:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_List, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Type type = 1; */
        if (message.type)
            Type.internalBinaryWrite(message.type, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* uint32 type_variation_reference = 2; */
        if (message.typeVariationReference !== 0)
            writer.tag(2, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 3; */
        if (message.nullability !== 0)
            writer.tag(3, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.List
 */
export const Type_List = new Type_List$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Type_Map$Type extends MessageType<Type_Map> {
    constructor() {
        super("substrait.Type.Map", [
            { no: 1, name: "key", kind: "message", T: () => Type },
            { no: 2, name: "value", kind: "message", T: () => Type },
            { no: 3, name: "type_variation_reference", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "nullability", kind: "enum", T: () => ["substrait.Type.Nullability", Type_Nullability, "NULLABILITY_"] }
        ]);
    }
    create(value?: PartialMessage<Type_Map>): Type_Map {
        const message = { typeVariationReference: 0, nullability: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Type_Map>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Type_Map): Type_Map {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.Type key */ 1:
                    message.key = Type.internalBinaryRead(reader, reader.uint32(), options, message.key);
                    break;
                case /* substrait.Type value */ 2:
                    message.value = Type.internalBinaryRead(reader, reader.uint32(), options, message.value);
                    break;
                case /* uint32 type_variation_reference */ 3:
                    message.typeVariationReference = reader.uint32();
                    break;
                case /* substrait.Type.Nullability nullability */ 4:
                    message.nullability = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Type_Map, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.Type key = 1; */
        if (message.key)
            Type.internalBinaryWrite(message.key, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* substrait.Type value = 2; */
        if (message.value)
            Type.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* uint32 type_variation_reference = 3; */
        if (message.typeVariationReference !== 0)
            writer.tag(3, WireType.Varint).uint32(message.typeVariationReference);
        /* substrait.Type.Nullability nullability = 4; */
        if (message.nullability !== 0)
            writer.tag(4, WireType.Varint).int32(message.nullability);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.Type.Map
 */
export const Type_Map = new Type_Map$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NamedStruct$Type extends MessageType<NamedStruct> {
    constructor() {
        super("substrait.NamedStruct", [
            { no: 1, name: "names", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "struct", kind: "message", T: () => Type_Struct }
        ]);
    }
    create(value?: PartialMessage<NamedStruct>): NamedStruct {
        const message = { names: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NamedStruct>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NamedStruct): NamedStruct {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string names */ 1:
                    message.names.push(reader.string());
                    break;
                case /* substrait.Type.Struct struct */ 2:
                    message.struct = Type_Struct.internalBinaryRead(reader, reader.uint32(), options, message.struct);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NamedStruct, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string names = 1; */
        for (let i = 0; i < message.names.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.names[i]);
        /* substrait.Type.Struct struct = 2; */
        if (message.struct)
            Type_Struct.internalBinaryWrite(message.struct, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.NamedStruct
 */
export const NamedStruct = new NamedStruct$Type();
