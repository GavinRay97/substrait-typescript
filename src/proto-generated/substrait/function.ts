// @generated by protobuf-ts 2.2.4
// @generated from protobuf file "substrait/function.proto" (package "substrait", syntax proto3)
// tslint:disable
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ParameterizedType } from "./parameterized_types";
import { Type } from "./type";
import { DerivationExpression } from "./type_expressions";
/**
 * List of function signatures available.
 *
 * @generated from protobuf message substrait.FunctionSignature
 */
export interface FunctionSignature {
}
/**
 * @generated from protobuf message substrait.FunctionSignature.FinalArgVariadic
 */
export interface FunctionSignature_FinalArgVariadic {
    /**
     * the minimum number of arguments allowed for the list of final arguments
     * (inclusive).
     *
     * @generated from protobuf field: int64 min_args = 1;
     */
    minArgs: bigint;
    /**
     * the maximum number of arguments allowed for the list of final arguments
     * (exclusive)
     *
     * @generated from protobuf field: int64 max_args = 2;
     */
    maxArgs: bigint;
    /**
     * the type of parameterized type consistency
     *
     * @generated from protobuf field: substrait.FunctionSignature.FinalArgVariadic.ParameterConsistency consistency = 3;
     */
    consistency: FunctionSignature_FinalArgVariadic_ParameterConsistency;
}
/**
 * @generated from protobuf enum substrait.FunctionSignature.FinalArgVariadic.ParameterConsistency
 */
export enum FunctionSignature_FinalArgVariadic_ParameterConsistency {
    /**
     * @generated from protobuf enum value: PARAMETER_CONSISTENCY_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * All argument must be the same concrete type.
     *
     * @generated from protobuf enum value: PARAMETER_CONSISTENCY_CONSISTENT = 1;
     */
    CONSISTENT = 1,
    /**
     * Each argument can be any possible concrete type afforded by the bounds
     * of any parameter defined in the arguments specification.
     *
     * @generated from protobuf enum value: PARAMETER_CONSISTENCY_INCONSISTENT = 2;
     */
    INCONSISTENT = 2
}
/**
 * @generated from protobuf message substrait.FunctionSignature.FinalArgNormal
 */
export interface FunctionSignature_FinalArgNormal {
}
/**
 * @generated from protobuf message substrait.FunctionSignature.Scalar
 */
export interface FunctionSignature_Scalar {
    /**
     * @generated from protobuf field: repeated substrait.FunctionSignature.Argument arguments = 2;
     */
    arguments: FunctionSignature_Argument[];
    /**
     * @generated from protobuf field: repeated string name = 3;
     */
    name: string[];
    /**
     * @generated from protobuf field: substrait.FunctionSignature.Description description = 4;
     */
    description?: FunctionSignature_Description;
    /**
     * @generated from protobuf field: bool deterministic = 7;
     */
    deterministic: boolean;
    /**
     * @generated from protobuf field: bool session_dependent = 8;
     */
    sessionDependent: boolean;
    /**
     * @generated from protobuf field: substrait.DerivationExpression output_type = 9;
     */
    outputType?: DerivationExpression;
    /**
     * @generated from protobuf oneof: final_variable_behavior
     */
    finalVariableBehavior: {
        oneofKind: "variadic";
        /**
         * @generated from protobuf field: substrait.FunctionSignature.FinalArgVariadic variadic = 10;
         */
        variadic: FunctionSignature_FinalArgVariadic;
    } | {
        oneofKind: "normal";
        /**
         * @generated from protobuf field: substrait.FunctionSignature.FinalArgNormal normal = 11;
         */
        normal: FunctionSignature_FinalArgNormal;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: repeated substrait.FunctionSignature.Implementation implementations = 12;
     */
    implementations: FunctionSignature_Implementation[];
}
/**
 * @generated from protobuf message substrait.FunctionSignature.Aggregate
 */
export interface FunctionSignature_Aggregate {
    /**
     * @generated from protobuf field: repeated substrait.FunctionSignature.Argument arguments = 2;
     */
    arguments: FunctionSignature_Argument[];
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: substrait.FunctionSignature.Description description = 4;
     */
    description?: FunctionSignature_Description;
    /**
     * @generated from protobuf field: bool deterministic = 7;
     */
    deterministic: boolean;
    /**
     * @generated from protobuf field: bool session_dependent = 8;
     */
    sessionDependent: boolean;
    /**
     * @generated from protobuf field: substrait.DerivationExpression output_type = 9;
     */
    outputType?: DerivationExpression;
    /**
     * @generated from protobuf oneof: final_variable_behavior
     */
    finalVariableBehavior: {
        oneofKind: "variadic";
        /**
         * @generated from protobuf field: substrait.FunctionSignature.FinalArgVariadic variadic = 10;
         */
        variadic: FunctionSignature_FinalArgVariadic;
    } | {
        oneofKind: "normal";
        /**
         * @generated from protobuf field: substrait.FunctionSignature.FinalArgNormal normal = 11;
         */
        normal: FunctionSignature_FinalArgNormal;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: bool ordered = 14;
     */
    ordered: boolean;
    /**
     * @generated from protobuf field: uint64 max_set = 12;
     */
    maxSet: bigint;
    /**
     * @generated from protobuf field: substrait.Type intermediate_type = 13;
     */
    intermediateType?: Type;
    /**
     * @generated from protobuf field: repeated substrait.FunctionSignature.Implementation implementations = 15;
     */
    implementations: FunctionSignature_Implementation[];
}
/**
 * @generated from protobuf message substrait.FunctionSignature.Window
 */
export interface FunctionSignature_Window {
    /**
     * @generated from protobuf field: repeated substrait.FunctionSignature.Argument arguments = 2;
     */
    arguments: FunctionSignature_Argument[];
    /**
     * @generated from protobuf field: repeated string name = 3;
     */
    name: string[];
    /**
     * @generated from protobuf field: substrait.FunctionSignature.Description description = 4;
     */
    description?: FunctionSignature_Description;
    /**
     * @generated from protobuf field: bool deterministic = 7;
     */
    deterministic: boolean;
    /**
     * @generated from protobuf field: bool session_dependent = 8;
     */
    sessionDependent: boolean;
    /**
     * @generated from protobuf field: substrait.DerivationExpression intermediate_type = 9;
     */
    intermediateType?: DerivationExpression;
    /**
     * @generated from protobuf field: substrait.DerivationExpression output_type = 10;
     */
    outputType?: DerivationExpression;
    /**
     * @generated from protobuf oneof: final_variable_behavior
     */
    finalVariableBehavior: {
        oneofKind: "variadic";
        /**
         * @generated from protobuf field: substrait.FunctionSignature.FinalArgVariadic variadic = 16;
         */
        variadic: FunctionSignature_FinalArgVariadic;
    } | {
        oneofKind: "normal";
        /**
         * @generated from protobuf field: substrait.FunctionSignature.FinalArgNormal normal = 17;
         */
        normal: FunctionSignature_FinalArgNormal;
    } | {
        oneofKind: undefined;
    };
    /**
     * @generated from protobuf field: bool ordered = 11;
     */
    ordered: boolean;
    /**
     * @generated from protobuf field: uint64 max_set = 12;
     */
    maxSet: bigint;
    /**
     * @generated from protobuf field: substrait.FunctionSignature.Window.WindowType window_type = 14;
     */
    windowType: FunctionSignature_Window_WindowType;
    /**
     * @generated from protobuf field: repeated substrait.FunctionSignature.Implementation implementations = 15;
     */
    implementations: FunctionSignature_Implementation[];
}
/**
 * @generated from protobuf enum substrait.FunctionSignature.Window.WindowType
 */
export enum FunctionSignature_Window_WindowType {
    /**
     * @generated from protobuf enum value: WINDOW_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: WINDOW_TYPE_STREAMING = 1;
     */
    STREAMING = 1,
    /**
     * @generated from protobuf enum value: WINDOW_TYPE_PARTITION = 2;
     */
    PARTITION = 2
}
/**
 * @generated from protobuf message substrait.FunctionSignature.Description
 */
export interface FunctionSignature_Description {
    /**
     * @generated from protobuf field: string language = 1;
     */
    language: string;
    /**
     * @generated from protobuf field: string body = 2;
     */
    body: string;
}
/**
 * @generated from protobuf message substrait.FunctionSignature.Implementation
 */
export interface FunctionSignature_Implementation {
    /**
     * @generated from protobuf field: substrait.FunctionSignature.Implementation.Type type = 1;
     */
    type: FunctionSignature_Implementation_Type;
    /**
     * @generated from protobuf field: string uri = 2;
     */
    uri: string;
}
/**
 * @generated from protobuf enum substrait.FunctionSignature.Implementation.Type
 */
export enum FunctionSignature_Implementation_Type {
    /**
     * @generated from protobuf enum value: TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: TYPE_WEB_ASSEMBLY = 1;
     */
    WEB_ASSEMBLY = 1,
    /**
     * @generated from protobuf enum value: TYPE_TRINO_JAR = 2;
     */
    TRINO_JAR = 2
}
/**
 * @generated from protobuf message substrait.FunctionSignature.Argument
 */
export interface FunctionSignature_Argument {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf oneof: argument_kind
     */
    argumentKind: {
        oneofKind: "value";
        /**
         * @generated from protobuf field: substrait.FunctionSignature.Argument.ValueArgument value = 2;
         */
        value: FunctionSignature_Argument_ValueArgument;
    } | {
        oneofKind: "type";
        /**
         * @generated from protobuf field: substrait.FunctionSignature.Argument.TypeArgument type = 3;
         */
        type: FunctionSignature_Argument_TypeArgument;
    } | {
        oneofKind: "enum";
        /**
         * @generated from protobuf field: substrait.FunctionSignature.Argument.EnumArgument enum = 4;
         */
        enum: FunctionSignature_Argument_EnumArgument;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message substrait.FunctionSignature.Argument.ValueArgument
 */
export interface FunctionSignature_Argument_ValueArgument {
    /**
     * @generated from protobuf field: substrait.ParameterizedType type = 1;
     */
    type?: ParameterizedType;
    /**
     * @generated from protobuf field: bool constant = 2;
     */
    constant: boolean;
}
/**
 * @generated from protobuf message substrait.FunctionSignature.Argument.TypeArgument
 */
export interface FunctionSignature_Argument_TypeArgument {
    /**
     * @generated from protobuf field: substrait.ParameterizedType type = 1;
     */
    type?: ParameterizedType;
}
/**
 * @generated from protobuf message substrait.FunctionSignature.Argument.EnumArgument
 */
export interface FunctionSignature_Argument_EnumArgument {
    /**
     * @generated from protobuf field: repeated string options = 1;
     */
    options: string[];
    /**
     * @generated from protobuf field: bool optional = 2;
     */
    optional: boolean;
}
// @generated message type with reflection information, may provide speed optimized methods
class FunctionSignature$Type extends MessageType<FunctionSignature> {
    constructor() {
        super("substrait.FunctionSignature", []);
    }
    create(value?: PartialMessage<FunctionSignature>): FunctionSignature {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FunctionSignature>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FunctionSignature): FunctionSignature {
        return target ?? this.create();
    }
    internalBinaryWrite(message: FunctionSignature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.FunctionSignature
 */
export const FunctionSignature = new FunctionSignature$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctionSignature_FinalArgVariadic$Type extends MessageType<FunctionSignature_FinalArgVariadic> {
    constructor() {
        super("substrait.FunctionSignature.FinalArgVariadic", [
            { no: 1, name: "min_args", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "max_args", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "consistency", kind: "enum", T: () => ["substrait.FunctionSignature.FinalArgVariadic.ParameterConsistency", FunctionSignature_FinalArgVariadic_ParameterConsistency, "PARAMETER_CONSISTENCY_"] }
        ]);
    }
    create(value?: PartialMessage<FunctionSignature_FinalArgVariadic>): FunctionSignature_FinalArgVariadic {
        const message = { minArgs: 0n, maxArgs: 0n, consistency: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FunctionSignature_FinalArgVariadic>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FunctionSignature_FinalArgVariadic): FunctionSignature_FinalArgVariadic {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 min_args */ 1:
                    message.minArgs = reader.int64().toBigInt();
                    break;
                case /* int64 max_args */ 2:
                    message.maxArgs = reader.int64().toBigInt();
                    break;
                case /* substrait.FunctionSignature.FinalArgVariadic.ParameterConsistency consistency */ 3:
                    message.consistency = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FunctionSignature_FinalArgVariadic, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 min_args = 1; */
        if (message.minArgs !== 0n)
            writer.tag(1, WireType.Varint).int64(message.minArgs);
        /* int64 max_args = 2; */
        if (message.maxArgs !== 0n)
            writer.tag(2, WireType.Varint).int64(message.maxArgs);
        /* substrait.FunctionSignature.FinalArgVariadic.ParameterConsistency consistency = 3; */
        if (message.consistency !== 0)
            writer.tag(3, WireType.Varint).int32(message.consistency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.FunctionSignature.FinalArgVariadic
 */
export const FunctionSignature_FinalArgVariadic = new FunctionSignature_FinalArgVariadic$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctionSignature_FinalArgNormal$Type extends MessageType<FunctionSignature_FinalArgNormal> {
    constructor() {
        super("substrait.FunctionSignature.FinalArgNormal", []);
    }
    create(value?: PartialMessage<FunctionSignature_FinalArgNormal>): FunctionSignature_FinalArgNormal {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FunctionSignature_FinalArgNormal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FunctionSignature_FinalArgNormal): FunctionSignature_FinalArgNormal {
        return target ?? this.create();
    }
    internalBinaryWrite(message: FunctionSignature_FinalArgNormal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.FunctionSignature.FinalArgNormal
 */
export const FunctionSignature_FinalArgNormal = new FunctionSignature_FinalArgNormal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctionSignature_Scalar$Type extends MessageType<FunctionSignature_Scalar> {
    constructor() {
        super("substrait.FunctionSignature.Scalar", [
            { no: 2, name: "arguments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FunctionSignature_Argument },
            { no: 3, name: "name", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "description", kind: "message", T: () => FunctionSignature_Description },
            { no: 7, name: "deterministic", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "session_dependent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "output_type", kind: "message", T: () => DerivationExpression },
            { no: 10, name: "variadic", kind: "message", oneof: "finalVariableBehavior", T: () => FunctionSignature_FinalArgVariadic },
            { no: 11, name: "normal", kind: "message", oneof: "finalVariableBehavior", T: () => FunctionSignature_FinalArgNormal },
            { no: 12, name: "implementations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FunctionSignature_Implementation }
        ]);
    }
    create(value?: PartialMessage<FunctionSignature_Scalar>): FunctionSignature_Scalar {
        const message = { arguments: [], name: [], deterministic: false, sessionDependent: false, finalVariableBehavior: { oneofKind: undefined }, implementations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FunctionSignature_Scalar>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FunctionSignature_Scalar): FunctionSignature_Scalar {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.FunctionSignature.Argument arguments */ 2:
                    message.arguments.push(FunctionSignature_Argument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string name */ 3:
                    message.name.push(reader.string());
                    break;
                case /* substrait.FunctionSignature.Description description */ 4:
                    message.description = FunctionSignature_Description.internalBinaryRead(reader, reader.uint32(), options, message.description);
                    break;
                case /* bool deterministic */ 7:
                    message.deterministic = reader.bool();
                    break;
                case /* bool session_dependent */ 8:
                    message.sessionDependent = reader.bool();
                    break;
                case /* substrait.DerivationExpression output_type */ 9:
                    message.outputType = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.outputType);
                    break;
                case /* substrait.FunctionSignature.FinalArgVariadic variadic */ 10:
                    message.finalVariableBehavior = {
                        oneofKind: "variadic",
                        variadic: FunctionSignature_FinalArgVariadic.internalBinaryRead(reader, reader.uint32(), options, (message.finalVariableBehavior as any).variadic)
                    };
                    break;
                case /* substrait.FunctionSignature.FinalArgNormal normal */ 11:
                    message.finalVariableBehavior = {
                        oneofKind: "normal",
                        normal: FunctionSignature_FinalArgNormal.internalBinaryRead(reader, reader.uint32(), options, (message.finalVariableBehavior as any).normal)
                    };
                    break;
                case /* repeated substrait.FunctionSignature.Implementation implementations */ 12:
                    message.implementations.push(FunctionSignature_Implementation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FunctionSignature_Scalar, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.FunctionSignature.Argument arguments = 2; */
        for (let i = 0; i < message.arguments.length; i++)
            FunctionSignature_Argument.internalBinaryWrite(message.arguments[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string name = 3; */
        for (let i = 0; i < message.name.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.name[i]);
        /* substrait.FunctionSignature.Description description = 4; */
        if (message.description)
            FunctionSignature_Description.internalBinaryWrite(message.description, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool deterministic = 7; */
        if (message.deterministic !== false)
            writer.tag(7, WireType.Varint).bool(message.deterministic);
        /* bool session_dependent = 8; */
        if (message.sessionDependent !== false)
            writer.tag(8, WireType.Varint).bool(message.sessionDependent);
        /* substrait.DerivationExpression output_type = 9; */
        if (message.outputType)
            DerivationExpression.internalBinaryWrite(message.outputType, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* substrait.FunctionSignature.FinalArgVariadic variadic = 10; */
        if (message.finalVariableBehavior.oneofKind === "variadic")
            FunctionSignature_FinalArgVariadic.internalBinaryWrite(message.finalVariableBehavior.variadic, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* substrait.FunctionSignature.FinalArgNormal normal = 11; */
        if (message.finalVariableBehavior.oneofKind === "normal")
            FunctionSignature_FinalArgNormal.internalBinaryWrite(message.finalVariableBehavior.normal, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated substrait.FunctionSignature.Implementation implementations = 12; */
        for (let i = 0; i < message.implementations.length; i++)
            FunctionSignature_Implementation.internalBinaryWrite(message.implementations[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.FunctionSignature.Scalar
 */
export const FunctionSignature_Scalar = new FunctionSignature_Scalar$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctionSignature_Aggregate$Type extends MessageType<FunctionSignature_Aggregate> {
    constructor() {
        super("substrait.FunctionSignature.Aggregate", [
            { no: 2, name: "arguments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FunctionSignature_Argument },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "description", kind: "message", T: () => FunctionSignature_Description },
            { no: 7, name: "deterministic", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "session_dependent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "output_type", kind: "message", T: () => DerivationExpression },
            { no: 10, name: "variadic", kind: "message", oneof: "finalVariableBehavior", T: () => FunctionSignature_FinalArgVariadic },
            { no: 11, name: "normal", kind: "message", oneof: "finalVariableBehavior", T: () => FunctionSignature_FinalArgNormal },
            { no: 14, name: "ordered", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "max_set", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 13, name: "intermediate_type", kind: "message", T: () => Type },
            { no: 15, name: "implementations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FunctionSignature_Implementation }
        ]);
    }
    create(value?: PartialMessage<FunctionSignature_Aggregate>): FunctionSignature_Aggregate {
        const message = { arguments: [], name: "", deterministic: false, sessionDependent: false, finalVariableBehavior: { oneofKind: undefined }, ordered: false, maxSet: 0n, implementations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FunctionSignature_Aggregate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FunctionSignature_Aggregate): FunctionSignature_Aggregate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.FunctionSignature.Argument arguments */ 2:
                    message.arguments.push(FunctionSignature_Argument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* substrait.FunctionSignature.Description description */ 4:
                    message.description = FunctionSignature_Description.internalBinaryRead(reader, reader.uint32(), options, message.description);
                    break;
                case /* bool deterministic */ 7:
                    message.deterministic = reader.bool();
                    break;
                case /* bool session_dependent */ 8:
                    message.sessionDependent = reader.bool();
                    break;
                case /* substrait.DerivationExpression output_type */ 9:
                    message.outputType = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.outputType);
                    break;
                case /* substrait.FunctionSignature.FinalArgVariadic variadic */ 10:
                    message.finalVariableBehavior = {
                        oneofKind: "variadic",
                        variadic: FunctionSignature_FinalArgVariadic.internalBinaryRead(reader, reader.uint32(), options, (message.finalVariableBehavior as any).variadic)
                    };
                    break;
                case /* substrait.FunctionSignature.FinalArgNormal normal */ 11:
                    message.finalVariableBehavior = {
                        oneofKind: "normal",
                        normal: FunctionSignature_FinalArgNormal.internalBinaryRead(reader, reader.uint32(), options, (message.finalVariableBehavior as any).normal)
                    };
                    break;
                case /* bool ordered */ 14:
                    message.ordered = reader.bool();
                    break;
                case /* uint64 max_set */ 12:
                    message.maxSet = reader.uint64().toBigInt();
                    break;
                case /* substrait.Type intermediate_type */ 13:
                    message.intermediateType = Type.internalBinaryRead(reader, reader.uint32(), options, message.intermediateType);
                    break;
                case /* repeated substrait.FunctionSignature.Implementation implementations */ 15:
                    message.implementations.push(FunctionSignature_Implementation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FunctionSignature_Aggregate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.FunctionSignature.Argument arguments = 2; */
        for (let i = 0; i < message.arguments.length; i++)
            FunctionSignature_Argument.internalBinaryWrite(message.arguments[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* substrait.FunctionSignature.Description description = 4; */
        if (message.description)
            FunctionSignature_Description.internalBinaryWrite(message.description, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool deterministic = 7; */
        if (message.deterministic !== false)
            writer.tag(7, WireType.Varint).bool(message.deterministic);
        /* bool session_dependent = 8; */
        if (message.sessionDependent !== false)
            writer.tag(8, WireType.Varint).bool(message.sessionDependent);
        /* substrait.DerivationExpression output_type = 9; */
        if (message.outputType)
            DerivationExpression.internalBinaryWrite(message.outputType, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* substrait.FunctionSignature.FinalArgVariadic variadic = 10; */
        if (message.finalVariableBehavior.oneofKind === "variadic")
            FunctionSignature_FinalArgVariadic.internalBinaryWrite(message.finalVariableBehavior.variadic, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* substrait.FunctionSignature.FinalArgNormal normal = 11; */
        if (message.finalVariableBehavior.oneofKind === "normal")
            FunctionSignature_FinalArgNormal.internalBinaryWrite(message.finalVariableBehavior.normal, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* bool ordered = 14; */
        if (message.ordered !== false)
            writer.tag(14, WireType.Varint).bool(message.ordered);
        /* uint64 max_set = 12; */
        if (message.maxSet !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.maxSet);
        /* substrait.Type intermediate_type = 13; */
        if (message.intermediateType)
            Type.internalBinaryWrite(message.intermediateType, writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* repeated substrait.FunctionSignature.Implementation implementations = 15; */
        for (let i = 0; i < message.implementations.length; i++)
            FunctionSignature_Implementation.internalBinaryWrite(message.implementations[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.FunctionSignature.Aggregate
 */
export const FunctionSignature_Aggregate = new FunctionSignature_Aggregate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctionSignature_Window$Type extends MessageType<FunctionSignature_Window> {
    constructor() {
        super("substrait.FunctionSignature.Window", [
            { no: 2, name: "arguments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FunctionSignature_Argument },
            { no: 3, name: "name", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "description", kind: "message", T: () => FunctionSignature_Description },
            { no: 7, name: "deterministic", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "session_dependent", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "intermediate_type", kind: "message", T: () => DerivationExpression },
            { no: 10, name: "output_type", kind: "message", T: () => DerivationExpression },
            { no: 16, name: "variadic", kind: "message", oneof: "finalVariableBehavior", T: () => FunctionSignature_FinalArgVariadic },
            { no: 17, name: "normal", kind: "message", oneof: "finalVariableBehavior", T: () => FunctionSignature_FinalArgNormal },
            { no: 11, name: "ordered", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "max_set", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 14, name: "window_type", kind: "enum", T: () => ["substrait.FunctionSignature.Window.WindowType", FunctionSignature_Window_WindowType, "WINDOW_TYPE_"] },
            { no: 15, name: "implementations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FunctionSignature_Implementation }
        ]);
    }
    create(value?: PartialMessage<FunctionSignature_Window>): FunctionSignature_Window {
        const message = { arguments: [], name: [], deterministic: false, sessionDependent: false, finalVariableBehavior: { oneofKind: undefined }, ordered: false, maxSet: 0n, windowType: 0, implementations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FunctionSignature_Window>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FunctionSignature_Window): FunctionSignature_Window {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated substrait.FunctionSignature.Argument arguments */ 2:
                    message.arguments.push(FunctionSignature_Argument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated string name */ 3:
                    message.name.push(reader.string());
                    break;
                case /* substrait.FunctionSignature.Description description */ 4:
                    message.description = FunctionSignature_Description.internalBinaryRead(reader, reader.uint32(), options, message.description);
                    break;
                case /* bool deterministic */ 7:
                    message.deterministic = reader.bool();
                    break;
                case /* bool session_dependent */ 8:
                    message.sessionDependent = reader.bool();
                    break;
                case /* substrait.DerivationExpression intermediate_type */ 9:
                    message.intermediateType = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.intermediateType);
                    break;
                case /* substrait.DerivationExpression output_type */ 10:
                    message.outputType = DerivationExpression.internalBinaryRead(reader, reader.uint32(), options, message.outputType);
                    break;
                case /* substrait.FunctionSignature.FinalArgVariadic variadic */ 16:
                    message.finalVariableBehavior = {
                        oneofKind: "variadic",
                        variadic: FunctionSignature_FinalArgVariadic.internalBinaryRead(reader, reader.uint32(), options, (message.finalVariableBehavior as any).variadic)
                    };
                    break;
                case /* substrait.FunctionSignature.FinalArgNormal normal */ 17:
                    message.finalVariableBehavior = {
                        oneofKind: "normal",
                        normal: FunctionSignature_FinalArgNormal.internalBinaryRead(reader, reader.uint32(), options, (message.finalVariableBehavior as any).normal)
                    };
                    break;
                case /* bool ordered */ 11:
                    message.ordered = reader.bool();
                    break;
                case /* uint64 max_set */ 12:
                    message.maxSet = reader.uint64().toBigInt();
                    break;
                case /* substrait.FunctionSignature.Window.WindowType window_type */ 14:
                    message.windowType = reader.int32();
                    break;
                case /* repeated substrait.FunctionSignature.Implementation implementations */ 15:
                    message.implementations.push(FunctionSignature_Implementation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FunctionSignature_Window, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated substrait.FunctionSignature.Argument arguments = 2; */
        for (let i = 0; i < message.arguments.length; i++)
            FunctionSignature_Argument.internalBinaryWrite(message.arguments[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated string name = 3; */
        for (let i = 0; i < message.name.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.name[i]);
        /* substrait.FunctionSignature.Description description = 4; */
        if (message.description)
            FunctionSignature_Description.internalBinaryWrite(message.description, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* bool deterministic = 7; */
        if (message.deterministic !== false)
            writer.tag(7, WireType.Varint).bool(message.deterministic);
        /* bool session_dependent = 8; */
        if (message.sessionDependent !== false)
            writer.tag(8, WireType.Varint).bool(message.sessionDependent);
        /* substrait.DerivationExpression intermediate_type = 9; */
        if (message.intermediateType)
            DerivationExpression.internalBinaryWrite(message.intermediateType, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* substrait.DerivationExpression output_type = 10; */
        if (message.outputType)
            DerivationExpression.internalBinaryWrite(message.outputType, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* substrait.FunctionSignature.FinalArgVariadic variadic = 16; */
        if (message.finalVariableBehavior.oneofKind === "variadic")
            FunctionSignature_FinalArgVariadic.internalBinaryWrite(message.finalVariableBehavior.variadic, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* substrait.FunctionSignature.FinalArgNormal normal = 17; */
        if (message.finalVariableBehavior.oneofKind === "normal")
            FunctionSignature_FinalArgNormal.internalBinaryWrite(message.finalVariableBehavior.normal, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* bool ordered = 11; */
        if (message.ordered !== false)
            writer.tag(11, WireType.Varint).bool(message.ordered);
        /* uint64 max_set = 12; */
        if (message.maxSet !== 0n)
            writer.tag(12, WireType.Varint).uint64(message.maxSet);
        /* substrait.FunctionSignature.Window.WindowType window_type = 14; */
        if (message.windowType !== 0)
            writer.tag(14, WireType.Varint).int32(message.windowType);
        /* repeated substrait.FunctionSignature.Implementation implementations = 15; */
        for (let i = 0; i < message.implementations.length; i++)
            FunctionSignature_Implementation.internalBinaryWrite(message.implementations[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.FunctionSignature.Window
 */
export const FunctionSignature_Window = new FunctionSignature_Window$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctionSignature_Description$Type extends MessageType<FunctionSignature_Description> {
    constructor() {
        super("substrait.FunctionSignature.Description", [
            { no: 1, name: "language", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "body", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FunctionSignature_Description>): FunctionSignature_Description {
        const message = { language: "", body: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FunctionSignature_Description>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FunctionSignature_Description): FunctionSignature_Description {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string language */ 1:
                    message.language = reader.string();
                    break;
                case /* string body */ 2:
                    message.body = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FunctionSignature_Description, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string language = 1; */
        if (message.language !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.language);
        /* string body = 2; */
        if (message.body !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.body);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.FunctionSignature.Description
 */
export const FunctionSignature_Description = new FunctionSignature_Description$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctionSignature_Implementation$Type extends MessageType<FunctionSignature_Implementation> {
    constructor() {
        super("substrait.FunctionSignature.Implementation", [
            { no: 1, name: "type", kind: "enum", T: () => ["substrait.FunctionSignature.Implementation.Type", FunctionSignature_Implementation_Type, "TYPE_"] },
            { no: 2, name: "uri", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FunctionSignature_Implementation>): FunctionSignature_Implementation {
        const message = { type: 0, uri: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FunctionSignature_Implementation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FunctionSignature_Implementation): FunctionSignature_Implementation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.FunctionSignature.Implementation.Type type */ 1:
                    message.type = reader.int32();
                    break;
                case /* string uri */ 2:
                    message.uri = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FunctionSignature_Implementation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.FunctionSignature.Implementation.Type type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* string uri = 2; */
        if (message.uri !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.uri);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.FunctionSignature.Implementation
 */
export const FunctionSignature_Implementation = new FunctionSignature_Implementation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctionSignature_Argument$Type extends MessageType<FunctionSignature_Argument> {
    constructor() {
        super("substrait.FunctionSignature.Argument", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "message", oneof: "argumentKind", T: () => FunctionSignature_Argument_ValueArgument },
            { no: 3, name: "type", kind: "message", oneof: "argumentKind", T: () => FunctionSignature_Argument_TypeArgument },
            { no: 4, name: "enum", kind: "message", oneof: "argumentKind", T: () => FunctionSignature_Argument_EnumArgument }
        ]);
    }
    create(value?: PartialMessage<FunctionSignature_Argument>): FunctionSignature_Argument {
        const message = { name: "", argumentKind: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FunctionSignature_Argument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FunctionSignature_Argument): FunctionSignature_Argument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* substrait.FunctionSignature.Argument.ValueArgument value */ 2:
                    message.argumentKind = {
                        oneofKind: "value",
                        value: FunctionSignature_Argument_ValueArgument.internalBinaryRead(reader, reader.uint32(), options, (message.argumentKind as any).value)
                    };
                    break;
                case /* substrait.FunctionSignature.Argument.TypeArgument type */ 3:
                    message.argumentKind = {
                        oneofKind: "type",
                        type: FunctionSignature_Argument_TypeArgument.internalBinaryRead(reader, reader.uint32(), options, (message.argumentKind as any).type)
                    };
                    break;
                case /* substrait.FunctionSignature.Argument.EnumArgument enum */ 4:
                    message.argumentKind = {
                        oneofKind: "enum",
                        enum: FunctionSignature_Argument_EnumArgument.internalBinaryRead(reader, reader.uint32(), options, (message.argumentKind as any).enum)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FunctionSignature_Argument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* substrait.FunctionSignature.Argument.ValueArgument value = 2; */
        if (message.argumentKind.oneofKind === "value")
            FunctionSignature_Argument_ValueArgument.internalBinaryWrite(message.argumentKind.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* substrait.FunctionSignature.Argument.TypeArgument type = 3; */
        if (message.argumentKind.oneofKind === "type")
            FunctionSignature_Argument_TypeArgument.internalBinaryWrite(message.argumentKind.type, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* substrait.FunctionSignature.Argument.EnumArgument enum = 4; */
        if (message.argumentKind.oneofKind === "enum")
            FunctionSignature_Argument_EnumArgument.internalBinaryWrite(message.argumentKind.enum, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.FunctionSignature.Argument
 */
export const FunctionSignature_Argument = new FunctionSignature_Argument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctionSignature_Argument_ValueArgument$Type extends MessageType<FunctionSignature_Argument_ValueArgument> {
    constructor() {
        super("substrait.FunctionSignature.Argument.ValueArgument", [
            { no: 1, name: "type", kind: "message", T: () => ParameterizedType },
            { no: 2, name: "constant", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FunctionSignature_Argument_ValueArgument>): FunctionSignature_Argument_ValueArgument {
        const message = { constant: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FunctionSignature_Argument_ValueArgument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FunctionSignature_Argument_ValueArgument): FunctionSignature_Argument_ValueArgument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.ParameterizedType type */ 1:
                    message.type = ParameterizedType.internalBinaryRead(reader, reader.uint32(), options, message.type);
                    break;
                case /* bool constant */ 2:
                    message.constant = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FunctionSignature_Argument_ValueArgument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.ParameterizedType type = 1; */
        if (message.type)
            ParameterizedType.internalBinaryWrite(message.type, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool constant = 2; */
        if (message.constant !== false)
            writer.tag(2, WireType.Varint).bool(message.constant);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.FunctionSignature.Argument.ValueArgument
 */
export const FunctionSignature_Argument_ValueArgument = new FunctionSignature_Argument_ValueArgument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctionSignature_Argument_TypeArgument$Type extends MessageType<FunctionSignature_Argument_TypeArgument> {
    constructor() {
        super("substrait.FunctionSignature.Argument.TypeArgument", [
            { no: 1, name: "type", kind: "message", T: () => ParameterizedType }
        ]);
    }
    create(value?: PartialMessage<FunctionSignature_Argument_TypeArgument>): FunctionSignature_Argument_TypeArgument {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FunctionSignature_Argument_TypeArgument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FunctionSignature_Argument_TypeArgument): FunctionSignature_Argument_TypeArgument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* substrait.ParameterizedType type */ 1:
                    message.type = ParameterizedType.internalBinaryRead(reader, reader.uint32(), options, message.type);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FunctionSignature_Argument_TypeArgument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* substrait.ParameterizedType type = 1; */
        if (message.type)
            ParameterizedType.internalBinaryWrite(message.type, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.FunctionSignature.Argument.TypeArgument
 */
export const FunctionSignature_Argument_TypeArgument = new FunctionSignature_Argument_TypeArgument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctionSignature_Argument_EnumArgument$Type extends MessageType<FunctionSignature_Argument_EnumArgument> {
    constructor() {
        super("substrait.FunctionSignature.Argument.EnumArgument", [
            { no: 1, name: "options", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "optional", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FunctionSignature_Argument_EnumArgument>): FunctionSignature_Argument_EnumArgument {
        const message = { options: [], optional: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FunctionSignature_Argument_EnumArgument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FunctionSignature_Argument_EnumArgument): FunctionSignature_Argument_EnumArgument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string options */ 1:
                    message.options.push(reader.string());
                    break;
                case /* bool optional */ 2:
                    message.optional = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FunctionSignature_Argument_EnumArgument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string options = 1; */
        for (let i = 0; i < message.options.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.options[i]);
        /* bool optional = 2; */
        if (message.optional !== false)
            writer.tag(2, WireType.Varint).bool(message.optional);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message substrait.FunctionSignature.Argument.EnumArgument
 */
export const FunctionSignature_Argument_EnumArgument = new FunctionSignature_Argument_EnumArgument$Type();
